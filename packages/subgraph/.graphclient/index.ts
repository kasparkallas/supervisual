// @ts-nocheck
import {
  GraphQLResolveInfo,
  SelectionSetNode,
  FieldNode,
  GraphQLScalarType,
  GraphQLScalarTypeConfig,
} from "graphql";
import { TypedDocumentNode as DocumentNode } from "@graphql-typed-document-node/core";
import { gql } from "@graphql-mesh/utils";

import type { GetMeshOptions } from "@graphql-mesh/runtime";
import type { YamlConfig } from "@graphql-mesh/types";
import { PubSub } from "@graphql-mesh/utils";
import { DefaultLogger } from "@graphql-mesh/utils";
import MeshCache from "@graphql-mesh/cache-localforage";
import { fetch as fetchFn } from "@whatwg-node/fetch";

import { MeshResolvedSource } from "@graphql-mesh/runtime";
import { MeshTransform, MeshPlugin } from "@graphql-mesh/types";
import GraphqlHandler from "@graphql-mesh/graphql";
import BareMerger from "@graphql-mesh/merger-bare";
import { printWithCache } from "@graphql-mesh/utils";
import { createMeshHTTPHandler, MeshHTTPHandler } from "@graphql-mesh/http";
import {
  getMesh,
  ExecuteMeshFn,
  SubscribeMeshFn,
  MeshContext as BaseMeshContext,
  MeshInstance,
} from "@graphql-mesh/runtime";
import { MeshStore, FsStoreStorageAdapter } from "@graphql-mesh/store";
import { path as pathModule } from "@graphql-mesh/cross-helpers";
import { ImportFn } from "@graphql-mesh/types";
import type { ProtocolTypes } from "./sources/protocol/types";
import * as importedModule$0 from "./sources/protocol/introspectionSchema";
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
export type RequireFields<T, K extends keyof T> = Omit<T, K> & {
  [P in K]-?: NonNullable<T[P]>;
};

/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  BigDecimal: string;
  BigInt: string;
  Bytes: string;
  Int8: any;
};

/**
 * Account: A higher order entity created for any addresses which interact with Superfluid contracts.
 *
 */
export type Account = {
  id: Scalars["ID"];
  createdAtTimestamp: Scalars["BigInt"];
  createdAtBlockNumber: Scalars["BigInt"];
  updatedAtTimestamp: Scalars["BigInt"];
  updatedAtBlockNumber: Scalars["BigInt"];
  /**
   * Indicates whether the address/account is a super app.
   *
   */
  isSuperApp: Scalars["Boolean"];
  inflows: Array<Stream>;
  outflows: Array<Stream>;
  subscriptions: Array<IndexSubscription>;
  publishedIndexes: Array<Index>;
  pools: Array<Pool>;
  poolMemberships: Array<PoolMember>;
  sentTransferEvents: Array<TransferEvent>;
  receivedTransferEvents: Array<TransferEvent>;
  tokenUpgradedEvents: Array<TokenUpgradedEvent>;
  tokenDowngradedEvents: Array<TokenDowngradedEvent>;
  accountTokenSnapshots: Array<AccountTokenSnapshot>;
};

/**
 * Account: A higher order entity created for any addresses which interact with Superfluid contracts.
 *
 */
export type AccountinflowsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<Stream_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<Stream_filter>;
};

/**
 * Account: A higher order entity created for any addresses which interact with Superfluid contracts.
 *
 */
export type AccountoutflowsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<Stream_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<Stream_filter>;
};

/**
 * Account: A higher order entity created for any addresses which interact with Superfluid contracts.
 *
 */
export type AccountsubscriptionsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<IndexSubscription_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<IndexSubscription_filter>;
};

/**
 * Account: A higher order entity created for any addresses which interact with Superfluid contracts.
 *
 */
export type AccountpublishedIndexesArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<Index_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<Index_filter>;
};

/**
 * Account: A higher order entity created for any addresses which interact with Superfluid contracts.
 *
 */
export type AccountpoolsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<Pool_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<Pool_filter>;
};

/**
 * Account: A higher order entity created for any addresses which interact with Superfluid contracts.
 *
 */
export type AccountpoolMembershipsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<PoolMember_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<PoolMember_filter>;
};

/**
 * Account: A higher order entity created for any addresses which interact with Superfluid contracts.
 *
 */
export type AccountsentTransferEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<TransferEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<TransferEvent_filter>;
};

/**
 * Account: A higher order entity created for any addresses which interact with Superfluid contracts.
 *
 */
export type AccountreceivedTransferEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<TransferEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<TransferEvent_filter>;
};

/**
 * Account: A higher order entity created for any addresses which interact with Superfluid contracts.
 *
 */
export type AccounttokenUpgradedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<TokenUpgradedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<TokenUpgradedEvent_filter>;
};

/**
 * Account: A higher order entity created for any addresses which interact with Superfluid contracts.
 *
 */
export type AccounttokenDowngradedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<TokenDowngradedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<TokenDowngradedEvent_filter>;
};

/**
 * Account: A higher order entity created for any addresses which interact with Superfluid contracts.
 *
 */
export type AccountaccountTokenSnapshotsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<AccountTokenSnapshot_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<AccountTokenSnapshot_filter>;
};

/**
 * AccountTokenSnapshot: An aggregate entity which aggregates data between an `account`'s interaction with `token`.
 *
 */
export type AccountTokenSnapshot = {
  /**
   * ID composed of: accountID-tokenID
   *
   */
  id: Scalars["ID"];
  createdAtTimestamp: Scalars["BigInt"];
  createdAtBlockNumber: Scalars["BigInt"];
  updatedAtTimestamp: Scalars["BigInt"];
  updatedAtBlockNumber: Scalars["BigInt"];
  /**
   * isLiquidationEstimateOptimistic, If `totalSubscriptionsWithUnits > 0`, it is true.
   * "Optimistic" can be thought of as conservative as it refers to the earliest time the user may be liquidated as they may receive ongoing distributions which aren't tracked by the subgraph.
   *
   */
  isLiquidationEstimateOptimistic: Scalars["Boolean"];
  /**
   * Optimistic liquidation estimation property.
   *
   */
  maybeCriticalAtTimestamp?: Maybe<Scalars["BigInt"]>;
  /**
   * The count of currently open streams for an account, both incoming and outgoing for all agreements.
   *
   */
  totalNumberOfActiveStreams: Scalars["Int"];
  /**
   * The count of currently open streams for an account, both incoming and outgoing for the CFA.
   *
   */
  totalCFANumberOfActiveStreams: Scalars["Int"];
  /**
   * The count of currently open streams for an account, both incoming and outgoing for the GDA.
   *
   */
  totalGDANumberOfActiveStreams: Scalars["Int"];
  /**
   * The count of active outgoing streams from this account for all agreements.
   *
   */
  activeOutgoingStreamCount: Scalars["Int"];
  /**
   * The count of active outgoing streams from this account for the CFA.
   *
   */
  activeCFAOutgoingStreamCount: Scalars["Int"];
  /**
   * The count of active outgoing streams from this account for the GDA.
   *
   */
  activeGDAOutgoingStreamCount: Scalars["Int"];
  /**
   * The count of active incoming streams to this account for the CFA.
   * GDA incoming streams are *NOT* counted here.
   *
   */
  activeIncomingStreamCount: Scalars["Int"];
  /**
   * The count of closed streams by `account`, both incoming and outgoing for all agreements.
   *
   */
  totalNumberOfClosedStreams: Scalars["Int"];
  /**
   * The count of closed streams by `account`, both incoming and outgoing for the CFA.
   *
   */
  totalCFANumberOfClosedStreams: Scalars["Int"];
  /**
   * The count of closed streams by `account`, both incoming and outgoing for the GDA.
   *
   */
  totalGDANumberOfClosedStreams: Scalars["Int"];
  /**
   * The count of closed outgoing streams by `account` for all agreements.
   *
   */
  inactiveOutgoingStreamCount: Scalars["Int"];
  /**
   * The count of closed outgoing streams by `account` for the CFA.
   *
   */
  inactiveCFAOutgoingStreamCount: Scalars["Int"];
  /**
   * The count of closed outgoing streams by `account` for the GDA.
   *
   */
  inactiveGDAOutgoingStreamCount: Scalars["Int"];
  /**
   * The count of closed incoming streams by `account` for the CFA.
   * Close incoming GDA streams are *NOT* counted here.
   *
   */
  inactiveIncomingStreamCount: Scalars["Int"];
  /**
   * The current (as of updatedAt) number of subscriptions with units allocated to them tied to this `account`.
   *
   */
  totalSubscriptionsWithUnits: Scalars["Int"];
  /**
   * Counts all currently (as of updatedAt) approved subscriptions whether or not they have units.
   *
   */
  totalApprovedSubscriptions: Scalars["Int"];
  /**
   * The current (as of updatedAt) number of membership with units allocated to them tied to this `account`.
   *
   */
  totalMembershipsWithUnits: Scalars["Int"];
  /**
   * Counts all currently (as of updatedAt) approved membership whether or not they have units.
   *
   */
  totalConnectedMemberships: Scalars["Int"];
  /**
   * Balance of `account` as of `updatedAtTimestamp`/`updatedAtBlock`.
   *
   */
  balanceUntilUpdatedAt: Scalars["BigInt"];
  /**
   * The total deposit this account has held by all flow agreements for `account` active streams.
   *
   */
  totalDeposit: Scalars["BigInt"];
  /**
   * The total deposit this account has held by the CFA agreement for `account` active streams.
   *
   */
  totalCFADeposit: Scalars["BigInt"];
  /**
   * The total deposit this account has held by the GDA agreement for `account` active streams.
   *
   */
  totalGDADeposit: Scalars["BigInt"];
  /**
   * The total net flow rate of the `account` as of `updatedAtTimestamp`/`updatedAtBlock` for all flow agreements.
   * This can be obtained by: `totalInflowRate - totalOutflowRate`.
   * NOTE: this property will NOT be 100% accurate all the time for receivers of GDA flows.
   *
   */
  totalNetFlowRate: Scalars["BigInt"];
  /**
   * The total net flow rate of the `account` as of `updatedAtTimestamp`/`updatedAtBlock` for the CFA.
   *
   */
  totalCFANetFlowRate: Scalars["BigInt"];
  /**
   * The total inflow rate (receive flowRate per second) of the `account` for the CFA.
   * GDA inflow rate is *NOT* included here.
   *
   */
  totalInflowRate: Scalars["BigInt"];
  /**
   * The total outflow rate (send flowrate per second) of the `account` for all flow agreements.
   *
   */
  totalOutflowRate: Scalars["BigInt"];
  /**
   * The total outflow rate (send flowrate per second) of the `account` for the CFA.
   *
   */
  totalCFAOutflowRate: Scalars["BigInt"];
  /**
   * The total outflow rate (send flowrate per second) of the `account` for the GDA.
   *
   */
  totalGDAOutflowRate: Scalars["BigInt"];
  /**
   * The total amount of `token` streamed into this `account` until the `updatedAtTimestamp`/`updatedAtBlock` for the CFA.
   *
   */
  totalAmountStreamedInUntilUpdatedAt: Scalars["BigInt"];
  /**
   * The total amount of `token` streamed from this `account` until the `updatedAtTimestamp`/`updatedAtBlock` for all flow agreements.
   *
   */
  totalAmountStreamedOutUntilUpdatedAt: Scalars["BigInt"];
  /**
   * The total amount of `token` streamed from this `account` until the `updatedAtTimestamp`/`updatedAtBlock` for the CFA.
   *
   */
  totalCFAAmountStreamedOutUntilUpdatedAt: Scalars["BigInt"];
  /**
   * The total amount of `token` streamed through this `account` until the `updatedAtTimestamp`/`updatedAtBlock` for all flow agreements.
   *
   */
  totalAmountStreamedUntilUpdatedAt: Scalars["BigInt"];
  /**
   * The total amount of `token` streamed through this `account` until the `updatedAtTimestamp`/`updatedAtBlock` for the CFA.
   *
   */
  totalCFAAmountStreamedUntilUpdatedAt: Scalars["BigInt"];
  /**
   * The total amount of `token` this `account` has transferred.
   *
   */
  totalAmountTransferredUntilUpdatedAt: Scalars["BigInt"];
  account: Account;
  token: Token;
  flowOperators: Array<FlowOperator>;
  accountTokenSnapshotLogs: Array<AccountTokenSnapshotLog>;
};

/**
 * AccountTokenSnapshot: An aggregate entity which aggregates data between an `account`'s interaction with `token`.
 *
 */
export type AccountTokenSnapshotflowOperatorsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<FlowOperator_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<FlowOperator_filter>;
};

/**
 * AccountTokenSnapshot: An aggregate entity which aggregates data between an `account`'s interaction with `token`.
 *
 */
export type AccountTokenSnapshotaccountTokenSnapshotLogsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<AccountTokenSnapshotLog_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<AccountTokenSnapshotLog_filter>;
};

/**
 * AccountTokenSnapshotLog: Historical entries of `AccountTokenSnapshot` updates.
 *
 */
export type AccountTokenSnapshotLog = {
  id: Scalars["ID"];
  timestamp: Scalars["BigInt"];
  blockNumber: Scalars["BigInt"];
  transactionHash: Scalars["Bytes"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  triggeredByEventName: Scalars["String"];
  /**
   * Optimistic liquidation estimation property.
   *
   */
  maybeCriticalAtTimestamp?: Maybe<Scalars["BigInt"]>;
  /**
   * The current (as of timestamp) number of open streams for all agreements.
   *
   */
  totalNumberOfActiveStreams: Scalars["Int"];
  /**
   * The current (as of timestamp) number of open streams.
   *
   */
  totalCFANumberOfActiveStreams: Scalars["Int"];
  /**
   * The current (as of timestamp) number of open streams.
   *
   */
  totalGDANumberOfActiveStreams: Scalars["Int"];
  /**
   * The count of active outgoing streams from this account for all agreements.
   *
   */
  activeOutgoingStreamCount: Scalars["Int"];
  /**
   * The count of active outgoing streams from this account.
   *
   */
  activeCFAOutgoingStreamCount: Scalars["Int"];
  /**
   * The count of active outgoing streams from this account.
   *
   */
  activeGDAOutgoingStreamCount: Scalars["Int"];
  /**
   * The count of active incoming streams to this account for all agreements.
   *
   */
  activeIncomingStreamCount: Scalars["Int"];
  /**
   * The current (as of timestamp) count of closed streams for all agreements.
   *
   */
  totalNumberOfClosedStreams: Scalars["Int"];
  /**
   * The current (as of timestamp) count of closed streams for the CFA.
   *
   */
  totalCFANumberOfClosedStreams: Scalars["Int"];
  /**
   * The current (as of timestamp) count of closed streams for the GDA.
   *
   */
  totalGDANumberOfClosedStreams: Scalars["Int"];
  /**
   * The count of closed outgoing streams by `account` for all agreements.
   *
   */
  inactiveOutgoingStreamCount: Scalars["Int"];
  /**
   * The count of closed outgoing streams by `account` for the CFA.
   *
   */
  inactiveCFAOutgoingStreamCount: Scalars["Int"];
  /**
   * The count of closed outgoing streams by `account` for the GDA.
   *
   */
  inactiveGDAOutgoingStreamCount: Scalars["Int"];
  /**
   * The count of closed incoming streams by `account` for the CFA.
   * Close incoming GDA streams are *NOT* counted here.
   *
   */
  inactiveIncomingStreamCount: Scalars["Int"];
  /**
   * The current (as of timestamp) number of subscriptions with units allocated to them tied to this `account`.
   *
   */
  totalSubscriptionsWithUnits: Scalars["Int"];
  /**
   * Counts all currently (as of timestamp) approved subscriptions whether or not they have units.
   *
   */
  totalApprovedSubscriptions: Scalars["Int"];
  /**
   * The current (as of timestamp) number of membership with units allocated to them tied to this `account`.
   *
   */
  totalMembershipsWithUnits: Scalars["Int"];
  /**
   * Counts all currently (as of timestamp) connected membership whether or not they have units.
   *
   */
  totalConnectedMemberships: Scalars["Int"];
  /**
   * Balance of `account` as of `timestamp`/`block`.
   *
   */
  balance: Scalars["BigInt"];
  /**
   * The total (as of timestamp) deposit this account has held by all flow agreements for `account` active streams.
   *
   */
  totalDeposit: Scalars["BigInt"];
  /**
   * The total (as of timestamp) deposit this account has held by the CFA agreement for `account` active streams.
   *
   */
  totalCFADeposit: Scalars["BigInt"];
  /**
   * The total (as of timestamp) deposit this account has held by the GDA agreement for `account` active streams.
   *
   */
  totalGDADeposit: Scalars["BigInt"];
  /**
   * The total (as of timestamp) net flow rate of the `account` as of `timestamp`/`block`.
   * This can be obtained by: `totalInflowRate - totalOutflowRate`
   *
   */
  totalNetFlowRate: Scalars["BigInt"];
  /**
   * The total (as of timestamp) net flow rate of the `account` as of `timestamp`/`block` for the CFA.
   *
   */
  totalCFANetFlowRate: Scalars["BigInt"];
  /**
   * The total (as of timestamp) inflow rate (receive flowRate per second) of the `account`.
   *
   */
  totalInflowRate: Scalars["BigInt"];
  /**
   * The total (as of timestamp) outflow rate (send flowrate per second) of the `account`.
   *
   */
  totalOutflowRate: Scalars["BigInt"];
  /**
   * The total (as of timestamp) outflow rate (send flowrate per second) of the `account` for the CFA.
   *
   */
  totalCFAOutflowRate: Scalars["BigInt"];
  /**
   * The total (as of timestamp) outflow rate (send flowrate per second) of the `account` for the GDA.
   *
   */
  totalGDAOutflowRate: Scalars["BigInt"];
  /**
   * The total (as of timestamp) amount of `token` streamed into this `account` until the `timestamp`/`block`.
   *
   */
  totalAmountStreamedIn: Scalars["BigInt"];
  /**
   * The total (as of timestamp) amount of `token` streamed from this `account` until the `timestamp`/`block`.
   *
   */
  totalAmountStreamedOut: Scalars["BigInt"];
  /**
   * The total (as of timestamp) amount of `token` streamed from this `account` until the `timestamp`/`block` for the CFA.
   *
   */
  totalCFAAmountStreamedOut: Scalars["BigInt"];
  /**
   * The total (as of timestamp) net amount of `token` streamed through this `account` until the `timestamp`/`block`.
   *
   */
  totalAmountStreamed: Scalars["BigInt"];
  /**
   * The total (as of timestamp) net amount of `token` streamed through this `account` until the `timestamp`/`block` for the CFA.
   *
   */
  totalCFAAmountStreamed: Scalars["BigInt"];
  /**
   * The total (as of timestamp) amount of `token` this `account` has transferred out until the `timestamp`/`block`.
   *
   */
  totalAmountTransferred: Scalars["BigInt"];
  account: Account;
  token: Token;
  accountTokenSnapshot: AccountTokenSnapshot;
};

export type AccountTokenSnapshotLog_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  triggeredByEventName?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_not?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_gt?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_lt?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_gte?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_lte?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_in?: InputMaybe<Array<Scalars["String"]>>;
  triggeredByEventName_not_in?: InputMaybe<Array<Scalars["String"]>>;
  triggeredByEventName_contains?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_contains_nocase?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_not_contains?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_starts_with?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_not_starts_with?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_ends_with?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_not_ends_with?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  maybeCriticalAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  maybeCriticalAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  maybeCriticalAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  maybeCriticalAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  maybeCriticalAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  maybeCriticalAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  maybeCriticalAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  maybeCriticalAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalNumberOfActiveStreams?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_not?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfActiveStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalCFANumberOfActiveStreams?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_not?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalCFANumberOfActiveStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalGDANumberOfActiveStreams?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_not?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalGDANumberOfActiveStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  activeOutgoingStreamCount?: InputMaybe<Scalars["Int"]>;
  activeOutgoingStreamCount_not?: InputMaybe<Scalars["Int"]>;
  activeOutgoingStreamCount_gt?: InputMaybe<Scalars["Int"]>;
  activeOutgoingStreamCount_lt?: InputMaybe<Scalars["Int"]>;
  activeOutgoingStreamCount_gte?: InputMaybe<Scalars["Int"]>;
  activeOutgoingStreamCount_lte?: InputMaybe<Scalars["Int"]>;
  activeOutgoingStreamCount_in?: InputMaybe<Array<Scalars["Int"]>>;
  activeOutgoingStreamCount_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  activeCFAOutgoingStreamCount?: InputMaybe<Scalars["Int"]>;
  activeCFAOutgoingStreamCount_not?: InputMaybe<Scalars["Int"]>;
  activeCFAOutgoingStreamCount_gt?: InputMaybe<Scalars["Int"]>;
  activeCFAOutgoingStreamCount_lt?: InputMaybe<Scalars["Int"]>;
  activeCFAOutgoingStreamCount_gte?: InputMaybe<Scalars["Int"]>;
  activeCFAOutgoingStreamCount_lte?: InputMaybe<Scalars["Int"]>;
  activeCFAOutgoingStreamCount_in?: InputMaybe<Array<Scalars["Int"]>>;
  activeCFAOutgoingStreamCount_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  activeGDAOutgoingStreamCount?: InputMaybe<Scalars["Int"]>;
  activeGDAOutgoingStreamCount_not?: InputMaybe<Scalars["Int"]>;
  activeGDAOutgoingStreamCount_gt?: InputMaybe<Scalars["Int"]>;
  activeGDAOutgoingStreamCount_lt?: InputMaybe<Scalars["Int"]>;
  activeGDAOutgoingStreamCount_gte?: InputMaybe<Scalars["Int"]>;
  activeGDAOutgoingStreamCount_lte?: InputMaybe<Scalars["Int"]>;
  activeGDAOutgoingStreamCount_in?: InputMaybe<Array<Scalars["Int"]>>;
  activeGDAOutgoingStreamCount_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  activeIncomingStreamCount?: InputMaybe<Scalars["Int"]>;
  activeIncomingStreamCount_not?: InputMaybe<Scalars["Int"]>;
  activeIncomingStreamCount_gt?: InputMaybe<Scalars["Int"]>;
  activeIncomingStreamCount_lt?: InputMaybe<Scalars["Int"]>;
  activeIncomingStreamCount_gte?: InputMaybe<Scalars["Int"]>;
  activeIncomingStreamCount_lte?: InputMaybe<Scalars["Int"]>;
  activeIncomingStreamCount_in?: InputMaybe<Array<Scalars["Int"]>>;
  activeIncomingStreamCount_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfClosedStreams?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_not?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfClosedStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalCFANumberOfClosedStreams?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_not?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalCFANumberOfClosedStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalGDANumberOfClosedStreams?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_not?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalGDANumberOfClosedStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  inactiveOutgoingStreamCount?: InputMaybe<Scalars["Int"]>;
  inactiveOutgoingStreamCount_not?: InputMaybe<Scalars["Int"]>;
  inactiveOutgoingStreamCount_gt?: InputMaybe<Scalars["Int"]>;
  inactiveOutgoingStreamCount_lt?: InputMaybe<Scalars["Int"]>;
  inactiveOutgoingStreamCount_gte?: InputMaybe<Scalars["Int"]>;
  inactiveOutgoingStreamCount_lte?: InputMaybe<Scalars["Int"]>;
  inactiveOutgoingStreamCount_in?: InputMaybe<Array<Scalars["Int"]>>;
  inactiveOutgoingStreamCount_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  inactiveCFAOutgoingStreamCount?: InputMaybe<Scalars["Int"]>;
  inactiveCFAOutgoingStreamCount_not?: InputMaybe<Scalars["Int"]>;
  inactiveCFAOutgoingStreamCount_gt?: InputMaybe<Scalars["Int"]>;
  inactiveCFAOutgoingStreamCount_lt?: InputMaybe<Scalars["Int"]>;
  inactiveCFAOutgoingStreamCount_gte?: InputMaybe<Scalars["Int"]>;
  inactiveCFAOutgoingStreamCount_lte?: InputMaybe<Scalars["Int"]>;
  inactiveCFAOutgoingStreamCount_in?: InputMaybe<Array<Scalars["Int"]>>;
  inactiveCFAOutgoingStreamCount_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  inactiveGDAOutgoingStreamCount?: InputMaybe<Scalars["Int"]>;
  inactiveGDAOutgoingStreamCount_not?: InputMaybe<Scalars["Int"]>;
  inactiveGDAOutgoingStreamCount_gt?: InputMaybe<Scalars["Int"]>;
  inactiveGDAOutgoingStreamCount_lt?: InputMaybe<Scalars["Int"]>;
  inactiveGDAOutgoingStreamCount_gte?: InputMaybe<Scalars["Int"]>;
  inactiveGDAOutgoingStreamCount_lte?: InputMaybe<Scalars["Int"]>;
  inactiveGDAOutgoingStreamCount_in?: InputMaybe<Array<Scalars["Int"]>>;
  inactiveGDAOutgoingStreamCount_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  inactiveIncomingStreamCount?: InputMaybe<Scalars["Int"]>;
  inactiveIncomingStreamCount_not?: InputMaybe<Scalars["Int"]>;
  inactiveIncomingStreamCount_gt?: InputMaybe<Scalars["Int"]>;
  inactiveIncomingStreamCount_lt?: InputMaybe<Scalars["Int"]>;
  inactiveIncomingStreamCount_gte?: InputMaybe<Scalars["Int"]>;
  inactiveIncomingStreamCount_lte?: InputMaybe<Scalars["Int"]>;
  inactiveIncomingStreamCount_in?: InputMaybe<Array<Scalars["Int"]>>;
  inactiveIncomingStreamCount_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalSubscriptionsWithUnits?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_not?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_gt?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_lt?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_gte?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_lte?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalSubscriptionsWithUnits_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalApprovedSubscriptions?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_not?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_gt?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_lt?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_gte?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_lte?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalApprovedSubscriptions_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalMembershipsWithUnits?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_not?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_gt?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_lt?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_gte?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_lte?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalMembershipsWithUnits_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalConnectedMemberships?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_not?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_gt?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_lt?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_gte?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_lte?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalConnectedMemberships_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  balance?: InputMaybe<Scalars["BigInt"]>;
  balance_not?: InputMaybe<Scalars["BigInt"]>;
  balance_gt?: InputMaybe<Scalars["BigInt"]>;
  balance_lt?: InputMaybe<Scalars["BigInt"]>;
  balance_gte?: InputMaybe<Scalars["BigInt"]>;
  balance_lte?: InputMaybe<Scalars["BigInt"]>;
  balance_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  balance_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalDeposit?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_not?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_gt?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_lt?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_gte?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_lte?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalDeposit_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFADeposit?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_not?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_gt?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_lt?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_gte?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_lte?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFADeposit_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalGDADeposit?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_not?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_gt?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_lt?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_gte?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_lte?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalGDADeposit_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalNetFlowRate?: InputMaybe<Scalars["BigInt"]>;
  totalNetFlowRate_not?: InputMaybe<Scalars["BigInt"]>;
  totalNetFlowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  totalNetFlowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  totalNetFlowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  totalNetFlowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  totalNetFlowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalNetFlowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFANetFlowRate?: InputMaybe<Scalars["BigInt"]>;
  totalCFANetFlowRate_not?: InputMaybe<Scalars["BigInt"]>;
  totalCFANetFlowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  totalCFANetFlowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  totalCFANetFlowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  totalCFANetFlowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  totalCFANetFlowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFANetFlowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalInflowRate?: InputMaybe<Scalars["BigInt"]>;
  totalInflowRate_not?: InputMaybe<Scalars["BigInt"]>;
  totalInflowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  totalInflowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  totalInflowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  totalInflowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  totalInflowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalInflowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalOutflowRate?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_not?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalOutflowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFAOutflowRate?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_not?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFAOutflowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalGDAOutflowRate?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_not?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalGDAOutflowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountStreamedIn?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedIn_not?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedIn_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedIn_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedIn_gte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedIn_lte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedIn_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountStreamedIn_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountStreamedOut?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedOut_not?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedOut_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedOut_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedOut_gte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedOut_lte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedOut_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountStreamedOut_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFAAmountStreamedOut?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedOut_not?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedOut_gt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedOut_lt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedOut_gte?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedOut_lte?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedOut_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFAAmountStreamedOut_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountStreamed?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamed_not?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamed_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamed_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamed_gte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamed_lte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountStreamed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFAAmountStreamed?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamed_not?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamed_gt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamed_lt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamed_gte?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamed_lte?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFAAmountStreamed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountTransferred?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferred_not?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferred_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferred_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferred_gte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferred_lte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferred_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountTransferred_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  account?: InputMaybe<Scalars["String"]>;
  account_not?: InputMaybe<Scalars["String"]>;
  account_gt?: InputMaybe<Scalars["String"]>;
  account_lt?: InputMaybe<Scalars["String"]>;
  account_gte?: InputMaybe<Scalars["String"]>;
  account_lte?: InputMaybe<Scalars["String"]>;
  account_in?: InputMaybe<Array<Scalars["String"]>>;
  account_not_in?: InputMaybe<Array<Scalars["String"]>>;
  account_contains?: InputMaybe<Scalars["String"]>;
  account_contains_nocase?: InputMaybe<Scalars["String"]>;
  account_not_contains?: InputMaybe<Scalars["String"]>;
  account_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  account_starts_with?: InputMaybe<Scalars["String"]>;
  account_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  account_not_starts_with?: InputMaybe<Scalars["String"]>;
  account_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  account_ends_with?: InputMaybe<Scalars["String"]>;
  account_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  account_not_ends_with?: InputMaybe<Scalars["String"]>;
  account_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  account_?: InputMaybe<Account_filter>;
  token?: InputMaybe<Scalars["String"]>;
  token_not?: InputMaybe<Scalars["String"]>;
  token_gt?: InputMaybe<Scalars["String"]>;
  token_lt?: InputMaybe<Scalars["String"]>;
  token_gte?: InputMaybe<Scalars["String"]>;
  token_lte?: InputMaybe<Scalars["String"]>;
  token_in?: InputMaybe<Array<Scalars["String"]>>;
  token_not_in?: InputMaybe<Array<Scalars["String"]>>;
  token_contains?: InputMaybe<Scalars["String"]>;
  token_contains_nocase?: InputMaybe<Scalars["String"]>;
  token_not_contains?: InputMaybe<Scalars["String"]>;
  token_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  token_starts_with?: InputMaybe<Scalars["String"]>;
  token_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  token_not_starts_with?: InputMaybe<Scalars["String"]>;
  token_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  token_ends_with?: InputMaybe<Scalars["String"]>;
  token_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  token_not_ends_with?: InputMaybe<Scalars["String"]>;
  token_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  token_?: InputMaybe<Token_filter>;
  accountTokenSnapshot?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_not?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_gt?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_lt?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_gte?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_lte?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_in?: InputMaybe<Array<Scalars["String"]>>;
  accountTokenSnapshot_not_in?: InputMaybe<Array<Scalars["String"]>>;
  accountTokenSnapshot_contains?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_contains_nocase?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_not_contains?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_starts_with?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_not_starts_with?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_ends_with?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_not_ends_with?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_?: InputMaybe<AccountTokenSnapshot_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<AccountTokenSnapshotLog_filter>>>;
  or?: InputMaybe<Array<InputMaybe<AccountTokenSnapshotLog_filter>>>;
};

export type AccountTokenSnapshotLog_orderBy =
  | "id"
  | "timestamp"
  | "blockNumber"
  | "transactionHash"
  | "logIndex"
  | "order"
  | "triggeredByEventName"
  | "maybeCriticalAtTimestamp"
  | "totalNumberOfActiveStreams"
  | "totalCFANumberOfActiveStreams"
  | "totalGDANumberOfActiveStreams"
  | "activeOutgoingStreamCount"
  | "activeCFAOutgoingStreamCount"
  | "activeGDAOutgoingStreamCount"
  | "activeIncomingStreamCount"
  | "totalNumberOfClosedStreams"
  | "totalCFANumberOfClosedStreams"
  | "totalGDANumberOfClosedStreams"
  | "inactiveOutgoingStreamCount"
  | "inactiveCFAOutgoingStreamCount"
  | "inactiveGDAOutgoingStreamCount"
  | "inactiveIncomingStreamCount"
  | "totalSubscriptionsWithUnits"
  | "totalApprovedSubscriptions"
  | "totalMembershipsWithUnits"
  | "totalConnectedMemberships"
  | "balance"
  | "totalDeposit"
  | "totalCFADeposit"
  | "totalGDADeposit"
  | "totalNetFlowRate"
  | "totalCFANetFlowRate"
  | "totalInflowRate"
  | "totalOutflowRate"
  | "totalCFAOutflowRate"
  | "totalGDAOutflowRate"
  | "totalAmountStreamedIn"
  | "totalAmountStreamedOut"
  | "totalCFAAmountStreamedOut"
  | "totalAmountStreamed"
  | "totalCFAAmountStreamed"
  | "totalAmountTransferred"
  | "account"
  | "account__id"
  | "account__createdAtTimestamp"
  | "account__createdAtBlockNumber"
  | "account__updatedAtTimestamp"
  | "account__updatedAtBlockNumber"
  | "account__isSuperApp"
  | "token"
  | "token__id"
  | "token__createdAtTimestamp"
  | "token__createdAtBlockNumber"
  | "token__decimals"
  | "token__name"
  | "token__symbol"
  | "token__isSuperToken"
  | "token__isNativeAssetSuperToken"
  | "token__isListed"
  | "token__underlyingAddress"
  | "accountTokenSnapshot"
  | "accountTokenSnapshot__id"
  | "accountTokenSnapshot__createdAtTimestamp"
  | "accountTokenSnapshot__createdAtBlockNumber"
  | "accountTokenSnapshot__updatedAtTimestamp"
  | "accountTokenSnapshot__updatedAtBlockNumber"
  | "accountTokenSnapshot__isLiquidationEstimateOptimistic"
  | "accountTokenSnapshot__maybeCriticalAtTimestamp"
  | "accountTokenSnapshot__totalNumberOfActiveStreams"
  | "accountTokenSnapshot__totalCFANumberOfActiveStreams"
  | "accountTokenSnapshot__totalGDANumberOfActiveStreams"
  | "accountTokenSnapshot__activeOutgoingStreamCount"
  | "accountTokenSnapshot__activeCFAOutgoingStreamCount"
  | "accountTokenSnapshot__activeGDAOutgoingStreamCount"
  | "accountTokenSnapshot__activeIncomingStreamCount"
  | "accountTokenSnapshot__totalNumberOfClosedStreams"
  | "accountTokenSnapshot__totalCFANumberOfClosedStreams"
  | "accountTokenSnapshot__totalGDANumberOfClosedStreams"
  | "accountTokenSnapshot__inactiveOutgoingStreamCount"
  | "accountTokenSnapshot__inactiveCFAOutgoingStreamCount"
  | "accountTokenSnapshot__inactiveGDAOutgoingStreamCount"
  | "accountTokenSnapshot__inactiveIncomingStreamCount"
  | "accountTokenSnapshot__totalSubscriptionsWithUnits"
  | "accountTokenSnapshot__totalApprovedSubscriptions"
  | "accountTokenSnapshot__totalMembershipsWithUnits"
  | "accountTokenSnapshot__totalConnectedMemberships"
  | "accountTokenSnapshot__balanceUntilUpdatedAt"
  | "accountTokenSnapshot__totalDeposit"
  | "accountTokenSnapshot__totalCFADeposit"
  | "accountTokenSnapshot__totalGDADeposit"
  | "accountTokenSnapshot__totalNetFlowRate"
  | "accountTokenSnapshot__totalCFANetFlowRate"
  | "accountTokenSnapshot__totalInflowRate"
  | "accountTokenSnapshot__totalOutflowRate"
  | "accountTokenSnapshot__totalCFAOutflowRate"
  | "accountTokenSnapshot__totalGDAOutflowRate"
  | "accountTokenSnapshot__totalAmountStreamedInUntilUpdatedAt"
  | "accountTokenSnapshot__totalAmountStreamedOutUntilUpdatedAt"
  | "accountTokenSnapshot__totalCFAAmountStreamedOutUntilUpdatedAt"
  | "accountTokenSnapshot__totalAmountStreamedUntilUpdatedAt"
  | "accountTokenSnapshot__totalCFAAmountStreamedUntilUpdatedAt"
  | "accountTokenSnapshot__totalAmountTransferredUntilUpdatedAt";

export type AccountTokenSnapshot_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  createdAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  isLiquidationEstimateOptimistic?: InputMaybe<Scalars["Boolean"]>;
  isLiquidationEstimateOptimistic_not?: InputMaybe<Scalars["Boolean"]>;
  isLiquidationEstimateOptimistic_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  isLiquidationEstimateOptimistic_not_in?: InputMaybe<
    Array<Scalars["Boolean"]>
  >;
  maybeCriticalAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  maybeCriticalAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  maybeCriticalAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  maybeCriticalAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  maybeCriticalAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  maybeCriticalAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  maybeCriticalAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  maybeCriticalAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalNumberOfActiveStreams?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_not?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfActiveStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalCFANumberOfActiveStreams?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_not?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalCFANumberOfActiveStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalGDANumberOfActiveStreams?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_not?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalGDANumberOfActiveStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  activeOutgoingStreamCount?: InputMaybe<Scalars["Int"]>;
  activeOutgoingStreamCount_not?: InputMaybe<Scalars["Int"]>;
  activeOutgoingStreamCount_gt?: InputMaybe<Scalars["Int"]>;
  activeOutgoingStreamCount_lt?: InputMaybe<Scalars["Int"]>;
  activeOutgoingStreamCount_gte?: InputMaybe<Scalars["Int"]>;
  activeOutgoingStreamCount_lte?: InputMaybe<Scalars["Int"]>;
  activeOutgoingStreamCount_in?: InputMaybe<Array<Scalars["Int"]>>;
  activeOutgoingStreamCount_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  activeCFAOutgoingStreamCount?: InputMaybe<Scalars["Int"]>;
  activeCFAOutgoingStreamCount_not?: InputMaybe<Scalars["Int"]>;
  activeCFAOutgoingStreamCount_gt?: InputMaybe<Scalars["Int"]>;
  activeCFAOutgoingStreamCount_lt?: InputMaybe<Scalars["Int"]>;
  activeCFAOutgoingStreamCount_gte?: InputMaybe<Scalars["Int"]>;
  activeCFAOutgoingStreamCount_lte?: InputMaybe<Scalars["Int"]>;
  activeCFAOutgoingStreamCount_in?: InputMaybe<Array<Scalars["Int"]>>;
  activeCFAOutgoingStreamCount_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  activeGDAOutgoingStreamCount?: InputMaybe<Scalars["Int"]>;
  activeGDAOutgoingStreamCount_not?: InputMaybe<Scalars["Int"]>;
  activeGDAOutgoingStreamCount_gt?: InputMaybe<Scalars["Int"]>;
  activeGDAOutgoingStreamCount_lt?: InputMaybe<Scalars["Int"]>;
  activeGDAOutgoingStreamCount_gte?: InputMaybe<Scalars["Int"]>;
  activeGDAOutgoingStreamCount_lte?: InputMaybe<Scalars["Int"]>;
  activeGDAOutgoingStreamCount_in?: InputMaybe<Array<Scalars["Int"]>>;
  activeGDAOutgoingStreamCount_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  activeIncomingStreamCount?: InputMaybe<Scalars["Int"]>;
  activeIncomingStreamCount_not?: InputMaybe<Scalars["Int"]>;
  activeIncomingStreamCount_gt?: InputMaybe<Scalars["Int"]>;
  activeIncomingStreamCount_lt?: InputMaybe<Scalars["Int"]>;
  activeIncomingStreamCount_gte?: InputMaybe<Scalars["Int"]>;
  activeIncomingStreamCount_lte?: InputMaybe<Scalars["Int"]>;
  activeIncomingStreamCount_in?: InputMaybe<Array<Scalars["Int"]>>;
  activeIncomingStreamCount_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfClosedStreams?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_not?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfClosedStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalCFANumberOfClosedStreams?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_not?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalCFANumberOfClosedStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalGDANumberOfClosedStreams?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_not?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalGDANumberOfClosedStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  inactiveOutgoingStreamCount?: InputMaybe<Scalars["Int"]>;
  inactiveOutgoingStreamCount_not?: InputMaybe<Scalars["Int"]>;
  inactiveOutgoingStreamCount_gt?: InputMaybe<Scalars["Int"]>;
  inactiveOutgoingStreamCount_lt?: InputMaybe<Scalars["Int"]>;
  inactiveOutgoingStreamCount_gte?: InputMaybe<Scalars["Int"]>;
  inactiveOutgoingStreamCount_lte?: InputMaybe<Scalars["Int"]>;
  inactiveOutgoingStreamCount_in?: InputMaybe<Array<Scalars["Int"]>>;
  inactiveOutgoingStreamCount_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  inactiveCFAOutgoingStreamCount?: InputMaybe<Scalars["Int"]>;
  inactiveCFAOutgoingStreamCount_not?: InputMaybe<Scalars["Int"]>;
  inactiveCFAOutgoingStreamCount_gt?: InputMaybe<Scalars["Int"]>;
  inactiveCFAOutgoingStreamCount_lt?: InputMaybe<Scalars["Int"]>;
  inactiveCFAOutgoingStreamCount_gte?: InputMaybe<Scalars["Int"]>;
  inactiveCFAOutgoingStreamCount_lte?: InputMaybe<Scalars["Int"]>;
  inactiveCFAOutgoingStreamCount_in?: InputMaybe<Array<Scalars["Int"]>>;
  inactiveCFAOutgoingStreamCount_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  inactiveGDAOutgoingStreamCount?: InputMaybe<Scalars["Int"]>;
  inactiveGDAOutgoingStreamCount_not?: InputMaybe<Scalars["Int"]>;
  inactiveGDAOutgoingStreamCount_gt?: InputMaybe<Scalars["Int"]>;
  inactiveGDAOutgoingStreamCount_lt?: InputMaybe<Scalars["Int"]>;
  inactiveGDAOutgoingStreamCount_gte?: InputMaybe<Scalars["Int"]>;
  inactiveGDAOutgoingStreamCount_lte?: InputMaybe<Scalars["Int"]>;
  inactiveGDAOutgoingStreamCount_in?: InputMaybe<Array<Scalars["Int"]>>;
  inactiveGDAOutgoingStreamCount_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  inactiveIncomingStreamCount?: InputMaybe<Scalars["Int"]>;
  inactiveIncomingStreamCount_not?: InputMaybe<Scalars["Int"]>;
  inactiveIncomingStreamCount_gt?: InputMaybe<Scalars["Int"]>;
  inactiveIncomingStreamCount_lt?: InputMaybe<Scalars["Int"]>;
  inactiveIncomingStreamCount_gte?: InputMaybe<Scalars["Int"]>;
  inactiveIncomingStreamCount_lte?: InputMaybe<Scalars["Int"]>;
  inactiveIncomingStreamCount_in?: InputMaybe<Array<Scalars["Int"]>>;
  inactiveIncomingStreamCount_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalSubscriptionsWithUnits?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_not?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_gt?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_lt?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_gte?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_lte?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalSubscriptionsWithUnits_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalApprovedSubscriptions?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_not?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_gt?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_lt?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_gte?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_lte?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalApprovedSubscriptions_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalMembershipsWithUnits?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_not?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_gt?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_lt?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_gte?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_lte?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalMembershipsWithUnits_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalConnectedMemberships?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_not?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_gt?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_lt?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_gte?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_lte?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalConnectedMemberships_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  balanceUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  balanceUntilUpdatedAt_not?: InputMaybe<Scalars["BigInt"]>;
  balanceUntilUpdatedAt_gt?: InputMaybe<Scalars["BigInt"]>;
  balanceUntilUpdatedAt_lt?: InputMaybe<Scalars["BigInt"]>;
  balanceUntilUpdatedAt_gte?: InputMaybe<Scalars["BigInt"]>;
  balanceUntilUpdatedAt_lte?: InputMaybe<Scalars["BigInt"]>;
  balanceUntilUpdatedAt_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  balanceUntilUpdatedAt_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalDeposit?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_not?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_gt?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_lt?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_gte?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_lte?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalDeposit_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFADeposit?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_not?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_gt?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_lt?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_gte?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_lte?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFADeposit_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalGDADeposit?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_not?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_gt?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_lt?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_gte?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_lte?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalGDADeposit_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalNetFlowRate?: InputMaybe<Scalars["BigInt"]>;
  totalNetFlowRate_not?: InputMaybe<Scalars["BigInt"]>;
  totalNetFlowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  totalNetFlowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  totalNetFlowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  totalNetFlowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  totalNetFlowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalNetFlowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFANetFlowRate?: InputMaybe<Scalars["BigInt"]>;
  totalCFANetFlowRate_not?: InputMaybe<Scalars["BigInt"]>;
  totalCFANetFlowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  totalCFANetFlowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  totalCFANetFlowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  totalCFANetFlowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  totalCFANetFlowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFANetFlowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalInflowRate?: InputMaybe<Scalars["BigInt"]>;
  totalInflowRate_not?: InputMaybe<Scalars["BigInt"]>;
  totalInflowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  totalInflowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  totalInflowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  totalInflowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  totalInflowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalInflowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalOutflowRate?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_not?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalOutflowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFAOutflowRate?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_not?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFAOutflowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalGDAOutflowRate?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_not?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalGDAOutflowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountStreamedInUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedInUntilUpdatedAt_not?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedInUntilUpdatedAt_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedInUntilUpdatedAt_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedInUntilUpdatedAt_gte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedInUntilUpdatedAt_lte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedInUntilUpdatedAt_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountStreamedInUntilUpdatedAt_not_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalAmountStreamedOutUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedOutUntilUpdatedAt_not?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedOutUntilUpdatedAt_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedOutUntilUpdatedAt_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedOutUntilUpdatedAt_gte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedOutUntilUpdatedAt_lte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedOutUntilUpdatedAt_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalAmountStreamedOutUntilUpdatedAt_not_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalCFAAmountStreamedOutUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedOutUntilUpdatedAt_not?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedOutUntilUpdatedAt_gt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedOutUntilUpdatedAt_lt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedOutUntilUpdatedAt_gte?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedOutUntilUpdatedAt_lte?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedOutUntilUpdatedAt_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalCFAAmountStreamedOutUntilUpdatedAt_not_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalAmountStreamedUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedUntilUpdatedAt_not?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedUntilUpdatedAt_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedUntilUpdatedAt_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedUntilUpdatedAt_gte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedUntilUpdatedAt_lte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedUntilUpdatedAt_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountStreamedUntilUpdatedAt_not_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalCFAAmountStreamedUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedUntilUpdatedAt_not?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedUntilUpdatedAt_gt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedUntilUpdatedAt_lt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedUntilUpdatedAt_gte?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedUntilUpdatedAt_lte?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedUntilUpdatedAt_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalCFAAmountStreamedUntilUpdatedAt_not_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalAmountTransferredUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferredUntilUpdatedAt_not?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferredUntilUpdatedAt_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferredUntilUpdatedAt_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferredUntilUpdatedAt_gte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferredUntilUpdatedAt_lte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferredUntilUpdatedAt_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalAmountTransferredUntilUpdatedAt_not_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  account?: InputMaybe<Scalars["String"]>;
  account_not?: InputMaybe<Scalars["String"]>;
  account_gt?: InputMaybe<Scalars["String"]>;
  account_lt?: InputMaybe<Scalars["String"]>;
  account_gte?: InputMaybe<Scalars["String"]>;
  account_lte?: InputMaybe<Scalars["String"]>;
  account_in?: InputMaybe<Array<Scalars["String"]>>;
  account_not_in?: InputMaybe<Array<Scalars["String"]>>;
  account_contains?: InputMaybe<Scalars["String"]>;
  account_contains_nocase?: InputMaybe<Scalars["String"]>;
  account_not_contains?: InputMaybe<Scalars["String"]>;
  account_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  account_starts_with?: InputMaybe<Scalars["String"]>;
  account_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  account_not_starts_with?: InputMaybe<Scalars["String"]>;
  account_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  account_ends_with?: InputMaybe<Scalars["String"]>;
  account_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  account_not_ends_with?: InputMaybe<Scalars["String"]>;
  account_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  account_?: InputMaybe<Account_filter>;
  token?: InputMaybe<Scalars["String"]>;
  token_not?: InputMaybe<Scalars["String"]>;
  token_gt?: InputMaybe<Scalars["String"]>;
  token_lt?: InputMaybe<Scalars["String"]>;
  token_gte?: InputMaybe<Scalars["String"]>;
  token_lte?: InputMaybe<Scalars["String"]>;
  token_in?: InputMaybe<Array<Scalars["String"]>>;
  token_not_in?: InputMaybe<Array<Scalars["String"]>>;
  token_contains?: InputMaybe<Scalars["String"]>;
  token_contains_nocase?: InputMaybe<Scalars["String"]>;
  token_not_contains?: InputMaybe<Scalars["String"]>;
  token_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  token_starts_with?: InputMaybe<Scalars["String"]>;
  token_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  token_not_starts_with?: InputMaybe<Scalars["String"]>;
  token_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  token_ends_with?: InputMaybe<Scalars["String"]>;
  token_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  token_not_ends_with?: InputMaybe<Scalars["String"]>;
  token_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  token_?: InputMaybe<Token_filter>;
  flowOperators_?: InputMaybe<FlowOperator_filter>;
  accountTokenSnapshotLogs_?: InputMaybe<AccountTokenSnapshotLog_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<AccountTokenSnapshot_filter>>>;
  or?: InputMaybe<Array<InputMaybe<AccountTokenSnapshot_filter>>>;
};

export type AccountTokenSnapshot_orderBy =
  | "id"
  | "createdAtTimestamp"
  | "createdAtBlockNumber"
  | "updatedAtTimestamp"
  | "updatedAtBlockNumber"
  | "isLiquidationEstimateOptimistic"
  | "maybeCriticalAtTimestamp"
  | "totalNumberOfActiveStreams"
  | "totalCFANumberOfActiveStreams"
  | "totalGDANumberOfActiveStreams"
  | "activeOutgoingStreamCount"
  | "activeCFAOutgoingStreamCount"
  | "activeGDAOutgoingStreamCount"
  | "activeIncomingStreamCount"
  | "totalNumberOfClosedStreams"
  | "totalCFANumberOfClosedStreams"
  | "totalGDANumberOfClosedStreams"
  | "inactiveOutgoingStreamCount"
  | "inactiveCFAOutgoingStreamCount"
  | "inactiveGDAOutgoingStreamCount"
  | "inactiveIncomingStreamCount"
  | "totalSubscriptionsWithUnits"
  | "totalApprovedSubscriptions"
  | "totalMembershipsWithUnits"
  | "totalConnectedMemberships"
  | "balanceUntilUpdatedAt"
  | "totalDeposit"
  | "totalCFADeposit"
  | "totalGDADeposit"
  | "totalNetFlowRate"
  | "totalCFANetFlowRate"
  | "totalInflowRate"
  | "totalOutflowRate"
  | "totalCFAOutflowRate"
  | "totalGDAOutflowRate"
  | "totalAmountStreamedInUntilUpdatedAt"
  | "totalAmountStreamedOutUntilUpdatedAt"
  | "totalCFAAmountStreamedOutUntilUpdatedAt"
  | "totalAmountStreamedUntilUpdatedAt"
  | "totalCFAAmountStreamedUntilUpdatedAt"
  | "totalAmountTransferredUntilUpdatedAt"
  | "account"
  | "account__id"
  | "account__createdAtTimestamp"
  | "account__createdAtBlockNumber"
  | "account__updatedAtTimestamp"
  | "account__updatedAtBlockNumber"
  | "account__isSuperApp"
  | "token"
  | "token__id"
  | "token__createdAtTimestamp"
  | "token__createdAtBlockNumber"
  | "token__decimals"
  | "token__name"
  | "token__symbol"
  | "token__isSuperToken"
  | "token__isNativeAssetSuperToken"
  | "token__isListed"
  | "token__underlyingAddress"
  | "flowOperators"
  | "accountTokenSnapshotLogs";

export type Account_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  createdAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  isSuperApp?: InputMaybe<Scalars["Boolean"]>;
  isSuperApp_not?: InputMaybe<Scalars["Boolean"]>;
  isSuperApp_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  isSuperApp_not_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  inflows_?: InputMaybe<Stream_filter>;
  outflows_?: InputMaybe<Stream_filter>;
  subscriptions_?: InputMaybe<IndexSubscription_filter>;
  publishedIndexes_?: InputMaybe<Index_filter>;
  pools_?: InputMaybe<Pool_filter>;
  poolMemberships_?: InputMaybe<PoolMember_filter>;
  sentTransferEvents_?: InputMaybe<TransferEvent_filter>;
  receivedTransferEvents_?: InputMaybe<TransferEvent_filter>;
  tokenUpgradedEvents_?: InputMaybe<TokenUpgradedEvent_filter>;
  tokenDowngradedEvents_?: InputMaybe<TokenDowngradedEvent_filter>;
  accountTokenSnapshots_?: InputMaybe<AccountTokenSnapshot_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<Account_filter>>>;
  or?: InputMaybe<Array<InputMaybe<Account_filter>>>;
};

export type Account_orderBy =
  | "id"
  | "createdAtTimestamp"
  | "createdAtBlockNumber"
  | "updatedAtTimestamp"
  | "updatedAtBlockNumber"
  | "isSuperApp"
  | "inflows"
  | "outflows"
  | "subscriptions"
  | "publishedIndexes"
  | "pools"
  | "poolMemberships"
  | "sentTransferEvents"
  | "receivedTransferEvents"
  | "tokenUpgradedEvents"
  | "tokenDowngradedEvents"
  | "accountTokenSnapshots";

export type AgreementClassRegisteredEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `code`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  agreementType: Scalars["Bytes"];
  code: Scalars["Bytes"];
};

export type AgreementClassRegisteredEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  agreementType?: InputMaybe<Scalars["Bytes"]>;
  agreementType_not?: InputMaybe<Scalars["Bytes"]>;
  agreementType_gt?: InputMaybe<Scalars["Bytes"]>;
  agreementType_lt?: InputMaybe<Scalars["Bytes"]>;
  agreementType_gte?: InputMaybe<Scalars["Bytes"]>;
  agreementType_lte?: InputMaybe<Scalars["Bytes"]>;
  agreementType_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  agreementType_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  agreementType_contains?: InputMaybe<Scalars["Bytes"]>;
  agreementType_not_contains?: InputMaybe<Scalars["Bytes"]>;
  code?: InputMaybe<Scalars["Bytes"]>;
  code_not?: InputMaybe<Scalars["Bytes"]>;
  code_gt?: InputMaybe<Scalars["Bytes"]>;
  code_lt?: InputMaybe<Scalars["Bytes"]>;
  code_gte?: InputMaybe<Scalars["Bytes"]>;
  code_lte?: InputMaybe<Scalars["Bytes"]>;
  code_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  code_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  code_contains?: InputMaybe<Scalars["Bytes"]>;
  code_not_contains?: InputMaybe<Scalars["Bytes"]>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<AgreementClassRegisteredEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<AgreementClassRegisteredEvent_filter>>>;
};

export type AgreementClassRegisteredEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "agreementType"
  | "code";

export type AgreementClassUpdatedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `code`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  agreementType: Scalars["Bytes"];
  code: Scalars["Bytes"];
};

export type AgreementClassUpdatedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  agreementType?: InputMaybe<Scalars["Bytes"]>;
  agreementType_not?: InputMaybe<Scalars["Bytes"]>;
  agreementType_gt?: InputMaybe<Scalars["Bytes"]>;
  agreementType_lt?: InputMaybe<Scalars["Bytes"]>;
  agreementType_gte?: InputMaybe<Scalars["Bytes"]>;
  agreementType_lte?: InputMaybe<Scalars["Bytes"]>;
  agreementType_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  agreementType_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  agreementType_contains?: InputMaybe<Scalars["Bytes"]>;
  agreementType_not_contains?: InputMaybe<Scalars["Bytes"]>;
  code?: InputMaybe<Scalars["Bytes"]>;
  code_not?: InputMaybe<Scalars["Bytes"]>;
  code_gt?: InputMaybe<Scalars["Bytes"]>;
  code_lt?: InputMaybe<Scalars["Bytes"]>;
  code_gte?: InputMaybe<Scalars["Bytes"]>;
  code_lte?: InputMaybe<Scalars["Bytes"]>;
  code_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  code_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  code_contains?: InputMaybe<Scalars["Bytes"]>;
  code_not_contains?: InputMaybe<Scalars["Bytes"]>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<AgreementClassUpdatedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<AgreementClassUpdatedEvent_filter>>>;
};

export type AgreementClassUpdatedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "agreementType"
  | "code";

/**
 * NOTE: This event was deprecated since the introduction of the 3Ps system.
 * Replaced by: `AgreementLiquidatedV2Event`
 * See: https://docs.superfluid.finance/superfluid/sentinels/liquidations-and-toga#patricians-plebs-and-pirates-3ps for more details on the 3Ps system.
 * See: https://github.com/superfluid-finance/protocol-monorepo/blob/dev/packages/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidToken.sol#L425 for more details on the events.
 *
 */
export type AgreementLiquidatedByEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = liquidatorAccount (executor of liquidation)
   * addresses[2] = penaltyAccount (the sender of the flow/stream)
   * addresses[3] = bondAccount (the address receiving the reward - the reward account for the token, pre 3Ps)
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
  liquidatorAccount: Scalars["Bytes"];
  agreementClass: Scalars["Bytes"];
  agreementId: Scalars["Bytes"];
  penaltyAccount: Scalars["Bytes"];
  bondAccount: Scalars["Bytes"];
  rewardAmount: Scalars["BigInt"];
  bailoutAmount: Scalars["BigInt"];
  /**
   * The full deposit amount of the stream that was liquidated.
   *
   */
  deposit: Scalars["BigInt"];
  /**
   * The flow rate of the stream at the time of liquidation.
   *
   */
  flowRateAtLiquidation: Scalars["BigInt"];
};

export type AgreementLiquidatedByEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  liquidatorAccount?: InputMaybe<Scalars["Bytes"]>;
  liquidatorAccount_not?: InputMaybe<Scalars["Bytes"]>;
  liquidatorAccount_gt?: InputMaybe<Scalars["Bytes"]>;
  liquidatorAccount_lt?: InputMaybe<Scalars["Bytes"]>;
  liquidatorAccount_gte?: InputMaybe<Scalars["Bytes"]>;
  liquidatorAccount_lte?: InputMaybe<Scalars["Bytes"]>;
  liquidatorAccount_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  liquidatorAccount_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  liquidatorAccount_contains?: InputMaybe<Scalars["Bytes"]>;
  liquidatorAccount_not_contains?: InputMaybe<Scalars["Bytes"]>;
  agreementClass?: InputMaybe<Scalars["Bytes"]>;
  agreementClass_not?: InputMaybe<Scalars["Bytes"]>;
  agreementClass_gt?: InputMaybe<Scalars["Bytes"]>;
  agreementClass_lt?: InputMaybe<Scalars["Bytes"]>;
  agreementClass_gte?: InputMaybe<Scalars["Bytes"]>;
  agreementClass_lte?: InputMaybe<Scalars["Bytes"]>;
  agreementClass_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  agreementClass_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  agreementClass_contains?: InputMaybe<Scalars["Bytes"]>;
  agreementClass_not_contains?: InputMaybe<Scalars["Bytes"]>;
  agreementId?: InputMaybe<Scalars["Bytes"]>;
  agreementId_not?: InputMaybe<Scalars["Bytes"]>;
  agreementId_gt?: InputMaybe<Scalars["Bytes"]>;
  agreementId_lt?: InputMaybe<Scalars["Bytes"]>;
  agreementId_gte?: InputMaybe<Scalars["Bytes"]>;
  agreementId_lte?: InputMaybe<Scalars["Bytes"]>;
  agreementId_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  agreementId_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  agreementId_contains?: InputMaybe<Scalars["Bytes"]>;
  agreementId_not_contains?: InputMaybe<Scalars["Bytes"]>;
  penaltyAccount?: InputMaybe<Scalars["Bytes"]>;
  penaltyAccount_not?: InputMaybe<Scalars["Bytes"]>;
  penaltyAccount_gt?: InputMaybe<Scalars["Bytes"]>;
  penaltyAccount_lt?: InputMaybe<Scalars["Bytes"]>;
  penaltyAccount_gte?: InputMaybe<Scalars["Bytes"]>;
  penaltyAccount_lte?: InputMaybe<Scalars["Bytes"]>;
  penaltyAccount_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  penaltyAccount_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  penaltyAccount_contains?: InputMaybe<Scalars["Bytes"]>;
  penaltyAccount_not_contains?: InputMaybe<Scalars["Bytes"]>;
  bondAccount?: InputMaybe<Scalars["Bytes"]>;
  bondAccount_not?: InputMaybe<Scalars["Bytes"]>;
  bondAccount_gt?: InputMaybe<Scalars["Bytes"]>;
  bondAccount_lt?: InputMaybe<Scalars["Bytes"]>;
  bondAccount_gte?: InputMaybe<Scalars["Bytes"]>;
  bondAccount_lte?: InputMaybe<Scalars["Bytes"]>;
  bondAccount_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  bondAccount_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  bondAccount_contains?: InputMaybe<Scalars["Bytes"]>;
  bondAccount_not_contains?: InputMaybe<Scalars["Bytes"]>;
  rewardAmount?: InputMaybe<Scalars["BigInt"]>;
  rewardAmount_not?: InputMaybe<Scalars["BigInt"]>;
  rewardAmount_gt?: InputMaybe<Scalars["BigInt"]>;
  rewardAmount_lt?: InputMaybe<Scalars["BigInt"]>;
  rewardAmount_gte?: InputMaybe<Scalars["BigInt"]>;
  rewardAmount_lte?: InputMaybe<Scalars["BigInt"]>;
  rewardAmount_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  rewardAmount_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  bailoutAmount?: InputMaybe<Scalars["BigInt"]>;
  bailoutAmount_not?: InputMaybe<Scalars["BigInt"]>;
  bailoutAmount_gt?: InputMaybe<Scalars["BigInt"]>;
  bailoutAmount_lt?: InputMaybe<Scalars["BigInt"]>;
  bailoutAmount_gte?: InputMaybe<Scalars["BigInt"]>;
  bailoutAmount_lte?: InputMaybe<Scalars["BigInt"]>;
  bailoutAmount_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  bailoutAmount_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  deposit?: InputMaybe<Scalars["BigInt"]>;
  deposit_not?: InputMaybe<Scalars["BigInt"]>;
  deposit_gt?: InputMaybe<Scalars["BigInt"]>;
  deposit_lt?: InputMaybe<Scalars["BigInt"]>;
  deposit_gte?: InputMaybe<Scalars["BigInt"]>;
  deposit_lte?: InputMaybe<Scalars["BigInt"]>;
  deposit_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  deposit_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  flowRateAtLiquidation?: InputMaybe<Scalars["BigInt"]>;
  flowRateAtLiquidation_not?: InputMaybe<Scalars["BigInt"]>;
  flowRateAtLiquidation_gt?: InputMaybe<Scalars["BigInt"]>;
  flowRateAtLiquidation_lt?: InputMaybe<Scalars["BigInt"]>;
  flowRateAtLiquidation_gte?: InputMaybe<Scalars["BigInt"]>;
  flowRateAtLiquidation_lte?: InputMaybe<Scalars["BigInt"]>;
  flowRateAtLiquidation_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  flowRateAtLiquidation_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<AgreementLiquidatedByEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<AgreementLiquidatedByEvent_filter>>>;
};

export type AgreementLiquidatedByEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "liquidatorAccount"
  | "agreementClass"
  | "agreementId"
  | "penaltyAccount"
  | "bondAccount"
  | "rewardAmount"
  | "bailoutAmount"
  | "deposit"
  | "flowRateAtLiquidation";

export type AgreementLiquidatedV2Event = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `liquidatorAccount` (executor of liquidation)
   * addresses[2] = `targetAccount` (the sender of the flow/stream)
   * addresses[3] = `rewardAmountReceiver` (the address receiving the reward) addresses
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
  agreementClass: Scalars["Bytes"];
  agreementId: Scalars["Bytes"];
  liquidatorAccount: Scalars["Bytes"];
  targetAccount: Scalars["Bytes"];
  rewardAmountReceiver: Scalars["Bytes"];
  rewardAmount: Scalars["BigInt"];
  targetAccountBalanceDelta: Scalars["BigInt"];
  version: Scalars["BigInt"];
  liquidationType: Scalars["Int"];
  /**
   * The full deposit amount of the stream that was liquidated.
   *
   */
  deposit: Scalars["BigInt"];
  /**
   * The flow rate of the stream at the time of liquidation.
   *
   */
  flowRateAtLiquidation: Scalars["BigInt"];
  /**
   * TO BE DEPRECATED in v2 endpoint - use rewardAmountReceiver instead
   *
   */
  rewardAccount: Scalars["Bytes"];
};

export type AgreementLiquidatedV2Event_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  agreementClass?: InputMaybe<Scalars["Bytes"]>;
  agreementClass_not?: InputMaybe<Scalars["Bytes"]>;
  agreementClass_gt?: InputMaybe<Scalars["Bytes"]>;
  agreementClass_lt?: InputMaybe<Scalars["Bytes"]>;
  agreementClass_gte?: InputMaybe<Scalars["Bytes"]>;
  agreementClass_lte?: InputMaybe<Scalars["Bytes"]>;
  agreementClass_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  agreementClass_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  agreementClass_contains?: InputMaybe<Scalars["Bytes"]>;
  agreementClass_not_contains?: InputMaybe<Scalars["Bytes"]>;
  agreementId?: InputMaybe<Scalars["Bytes"]>;
  agreementId_not?: InputMaybe<Scalars["Bytes"]>;
  agreementId_gt?: InputMaybe<Scalars["Bytes"]>;
  agreementId_lt?: InputMaybe<Scalars["Bytes"]>;
  agreementId_gte?: InputMaybe<Scalars["Bytes"]>;
  agreementId_lte?: InputMaybe<Scalars["Bytes"]>;
  agreementId_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  agreementId_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  agreementId_contains?: InputMaybe<Scalars["Bytes"]>;
  agreementId_not_contains?: InputMaybe<Scalars["Bytes"]>;
  liquidatorAccount?: InputMaybe<Scalars["Bytes"]>;
  liquidatorAccount_not?: InputMaybe<Scalars["Bytes"]>;
  liquidatorAccount_gt?: InputMaybe<Scalars["Bytes"]>;
  liquidatorAccount_lt?: InputMaybe<Scalars["Bytes"]>;
  liquidatorAccount_gte?: InputMaybe<Scalars["Bytes"]>;
  liquidatorAccount_lte?: InputMaybe<Scalars["Bytes"]>;
  liquidatorAccount_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  liquidatorAccount_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  liquidatorAccount_contains?: InputMaybe<Scalars["Bytes"]>;
  liquidatorAccount_not_contains?: InputMaybe<Scalars["Bytes"]>;
  targetAccount?: InputMaybe<Scalars["Bytes"]>;
  targetAccount_not?: InputMaybe<Scalars["Bytes"]>;
  targetAccount_gt?: InputMaybe<Scalars["Bytes"]>;
  targetAccount_lt?: InputMaybe<Scalars["Bytes"]>;
  targetAccount_gte?: InputMaybe<Scalars["Bytes"]>;
  targetAccount_lte?: InputMaybe<Scalars["Bytes"]>;
  targetAccount_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  targetAccount_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  targetAccount_contains?: InputMaybe<Scalars["Bytes"]>;
  targetAccount_not_contains?: InputMaybe<Scalars["Bytes"]>;
  rewardAmountReceiver?: InputMaybe<Scalars["Bytes"]>;
  rewardAmountReceiver_not?: InputMaybe<Scalars["Bytes"]>;
  rewardAmountReceiver_gt?: InputMaybe<Scalars["Bytes"]>;
  rewardAmountReceiver_lt?: InputMaybe<Scalars["Bytes"]>;
  rewardAmountReceiver_gte?: InputMaybe<Scalars["Bytes"]>;
  rewardAmountReceiver_lte?: InputMaybe<Scalars["Bytes"]>;
  rewardAmountReceiver_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  rewardAmountReceiver_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  rewardAmountReceiver_contains?: InputMaybe<Scalars["Bytes"]>;
  rewardAmountReceiver_not_contains?: InputMaybe<Scalars["Bytes"]>;
  rewardAmount?: InputMaybe<Scalars["BigInt"]>;
  rewardAmount_not?: InputMaybe<Scalars["BigInt"]>;
  rewardAmount_gt?: InputMaybe<Scalars["BigInt"]>;
  rewardAmount_lt?: InputMaybe<Scalars["BigInt"]>;
  rewardAmount_gte?: InputMaybe<Scalars["BigInt"]>;
  rewardAmount_lte?: InputMaybe<Scalars["BigInt"]>;
  rewardAmount_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  rewardAmount_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  targetAccountBalanceDelta?: InputMaybe<Scalars["BigInt"]>;
  targetAccountBalanceDelta_not?: InputMaybe<Scalars["BigInt"]>;
  targetAccountBalanceDelta_gt?: InputMaybe<Scalars["BigInt"]>;
  targetAccountBalanceDelta_lt?: InputMaybe<Scalars["BigInt"]>;
  targetAccountBalanceDelta_gte?: InputMaybe<Scalars["BigInt"]>;
  targetAccountBalanceDelta_lte?: InputMaybe<Scalars["BigInt"]>;
  targetAccountBalanceDelta_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  targetAccountBalanceDelta_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  version?: InputMaybe<Scalars["BigInt"]>;
  version_not?: InputMaybe<Scalars["BigInt"]>;
  version_gt?: InputMaybe<Scalars["BigInt"]>;
  version_lt?: InputMaybe<Scalars["BigInt"]>;
  version_gte?: InputMaybe<Scalars["BigInt"]>;
  version_lte?: InputMaybe<Scalars["BigInt"]>;
  version_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  version_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  liquidationType?: InputMaybe<Scalars["Int"]>;
  liquidationType_not?: InputMaybe<Scalars["Int"]>;
  liquidationType_gt?: InputMaybe<Scalars["Int"]>;
  liquidationType_lt?: InputMaybe<Scalars["Int"]>;
  liquidationType_gte?: InputMaybe<Scalars["Int"]>;
  liquidationType_lte?: InputMaybe<Scalars["Int"]>;
  liquidationType_in?: InputMaybe<Array<Scalars["Int"]>>;
  liquidationType_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  deposit?: InputMaybe<Scalars["BigInt"]>;
  deposit_not?: InputMaybe<Scalars["BigInt"]>;
  deposit_gt?: InputMaybe<Scalars["BigInt"]>;
  deposit_lt?: InputMaybe<Scalars["BigInt"]>;
  deposit_gte?: InputMaybe<Scalars["BigInt"]>;
  deposit_lte?: InputMaybe<Scalars["BigInt"]>;
  deposit_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  deposit_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  flowRateAtLiquidation?: InputMaybe<Scalars["BigInt"]>;
  flowRateAtLiquidation_not?: InputMaybe<Scalars["BigInt"]>;
  flowRateAtLiquidation_gt?: InputMaybe<Scalars["BigInt"]>;
  flowRateAtLiquidation_lt?: InputMaybe<Scalars["BigInt"]>;
  flowRateAtLiquidation_gte?: InputMaybe<Scalars["BigInt"]>;
  flowRateAtLiquidation_lte?: InputMaybe<Scalars["BigInt"]>;
  flowRateAtLiquidation_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  flowRateAtLiquidation_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  rewardAccount?: InputMaybe<Scalars["Bytes"]>;
  rewardAccount_not?: InputMaybe<Scalars["Bytes"]>;
  rewardAccount_gt?: InputMaybe<Scalars["Bytes"]>;
  rewardAccount_lt?: InputMaybe<Scalars["Bytes"]>;
  rewardAccount_gte?: InputMaybe<Scalars["Bytes"]>;
  rewardAccount_lte?: InputMaybe<Scalars["Bytes"]>;
  rewardAccount_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  rewardAccount_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  rewardAccount_contains?: InputMaybe<Scalars["Bytes"]>;
  rewardAccount_not_contains?: InputMaybe<Scalars["Bytes"]>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<AgreementLiquidatedV2Event_filter>>>;
  or?: InputMaybe<Array<InputMaybe<AgreementLiquidatedV2Event_filter>>>;
};

export type AgreementLiquidatedV2Event_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "agreementClass"
  | "agreementId"
  | "liquidatorAccount"
  | "targetAccount"
  | "rewardAmountReceiver"
  | "rewardAmount"
  | "targetAccountBalanceDelta"
  | "version"
  | "liquidationType"
  | "deposit"
  | "flowRateAtLiquidation"
  | "rewardAccount";

export type AppRegisteredEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `app`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  app: Scalars["Bytes"];
};

export type AppRegisteredEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  app?: InputMaybe<Scalars["Bytes"]>;
  app_not?: InputMaybe<Scalars["Bytes"]>;
  app_gt?: InputMaybe<Scalars["Bytes"]>;
  app_lt?: InputMaybe<Scalars["Bytes"]>;
  app_gte?: InputMaybe<Scalars["Bytes"]>;
  app_lte?: InputMaybe<Scalars["Bytes"]>;
  app_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  app_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  app_contains?: InputMaybe<Scalars["Bytes"]>;
  app_not_contains?: InputMaybe<Scalars["Bytes"]>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<AppRegisteredEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<AppRegisteredEvent_filter>>>;
};

export type AppRegisteredEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "app";

export type ApprovalEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `isNFTApproval` ? `nft address` : `token` (superToken)
   * addresses[1] = `owner`
   * addresses[2] = `to`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  /**
   * The address that will be granting allowance to transfer ERC20/NFT.
   *
   */
  owner: Account;
  /**
   * The address that will be granted allowance to transfer ERC20/NFT.
   *
   */
  to: Account;
  /**
   * Indicates whether the event was emitted for the approval of an NFT.
   *
   */
  isNFTApproval: Scalars["Boolean"];
  /**
   * If `amount` is non-zero, this event was emitted for the approval of an ERC20.
   * Tne amount of ERC20 tokens that will be granted allowance to transfer.
   *
   */
  amount: Scalars["BigInt"];
  /**
   * If `tokenId` is non-zero, this event was emitted for the approval of an NFT.
   * The id of the NFT that will be granted allowance to transfer.
   * The id is: uint256(keccak256(abi.encode(block.chainid, superToken, sender, receiver)))
   *
   */
  tokenId: Scalars["BigInt"];
};

export type ApprovalEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  owner?: InputMaybe<Scalars["String"]>;
  owner_not?: InputMaybe<Scalars["String"]>;
  owner_gt?: InputMaybe<Scalars["String"]>;
  owner_lt?: InputMaybe<Scalars["String"]>;
  owner_gte?: InputMaybe<Scalars["String"]>;
  owner_lte?: InputMaybe<Scalars["String"]>;
  owner_in?: InputMaybe<Array<Scalars["String"]>>;
  owner_not_in?: InputMaybe<Array<Scalars["String"]>>;
  owner_contains?: InputMaybe<Scalars["String"]>;
  owner_contains_nocase?: InputMaybe<Scalars["String"]>;
  owner_not_contains?: InputMaybe<Scalars["String"]>;
  owner_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  owner_starts_with?: InputMaybe<Scalars["String"]>;
  owner_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  owner_not_starts_with?: InputMaybe<Scalars["String"]>;
  owner_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  owner_ends_with?: InputMaybe<Scalars["String"]>;
  owner_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  owner_not_ends_with?: InputMaybe<Scalars["String"]>;
  owner_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  owner_?: InputMaybe<Account_filter>;
  to?: InputMaybe<Scalars["String"]>;
  to_not?: InputMaybe<Scalars["String"]>;
  to_gt?: InputMaybe<Scalars["String"]>;
  to_lt?: InputMaybe<Scalars["String"]>;
  to_gte?: InputMaybe<Scalars["String"]>;
  to_lte?: InputMaybe<Scalars["String"]>;
  to_in?: InputMaybe<Array<Scalars["String"]>>;
  to_not_in?: InputMaybe<Array<Scalars["String"]>>;
  to_contains?: InputMaybe<Scalars["String"]>;
  to_contains_nocase?: InputMaybe<Scalars["String"]>;
  to_not_contains?: InputMaybe<Scalars["String"]>;
  to_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  to_starts_with?: InputMaybe<Scalars["String"]>;
  to_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  to_not_starts_with?: InputMaybe<Scalars["String"]>;
  to_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  to_ends_with?: InputMaybe<Scalars["String"]>;
  to_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  to_not_ends_with?: InputMaybe<Scalars["String"]>;
  to_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  to_?: InputMaybe<Account_filter>;
  isNFTApproval?: InputMaybe<Scalars["Boolean"]>;
  isNFTApproval_not?: InputMaybe<Scalars["Boolean"]>;
  isNFTApproval_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  isNFTApproval_not_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  amount?: InputMaybe<Scalars["BigInt"]>;
  amount_not?: InputMaybe<Scalars["BigInt"]>;
  amount_gt?: InputMaybe<Scalars["BigInt"]>;
  amount_lt?: InputMaybe<Scalars["BigInt"]>;
  amount_gte?: InputMaybe<Scalars["BigInt"]>;
  amount_lte?: InputMaybe<Scalars["BigInt"]>;
  amount_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  amount_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  tokenId?: InputMaybe<Scalars["BigInt"]>;
  tokenId_not?: InputMaybe<Scalars["BigInt"]>;
  tokenId_gt?: InputMaybe<Scalars["BigInt"]>;
  tokenId_lt?: InputMaybe<Scalars["BigInt"]>;
  tokenId_gte?: InputMaybe<Scalars["BigInt"]>;
  tokenId_lte?: InputMaybe<Scalars["BigInt"]>;
  tokenId_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  tokenId_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<ApprovalEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<ApprovalEvent_filter>>>;
};

export type ApprovalEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "owner"
  | "owner__id"
  | "owner__createdAtTimestamp"
  | "owner__createdAtBlockNumber"
  | "owner__updatedAtTimestamp"
  | "owner__updatedAtBlockNumber"
  | "owner__isSuperApp"
  | "to"
  | "to__id"
  | "to__createdAtTimestamp"
  | "to__createdAtBlockNumber"
  | "to__updatedAtTimestamp"
  | "to__updatedAtBlockNumber"
  | "to__isSuperApp"
  | "isNFTApproval"
  | "amount"
  | "tokenId";

export type ApprovalForAllEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = NFT address
   * addresses[1] = `owner`
   * addresses[2] = `operator`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  owner: Account;
  /**
   * The address that will be granted operator permissions for the all of the owner's tokens.
   *
   */
  operator: Account;
  /**
   * Whether the operator is enabled or disabled for `owner`.
   *
   */
  approved: Scalars["Boolean"];
};

export type ApprovalForAllEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  owner?: InputMaybe<Scalars["String"]>;
  owner_not?: InputMaybe<Scalars["String"]>;
  owner_gt?: InputMaybe<Scalars["String"]>;
  owner_lt?: InputMaybe<Scalars["String"]>;
  owner_gte?: InputMaybe<Scalars["String"]>;
  owner_lte?: InputMaybe<Scalars["String"]>;
  owner_in?: InputMaybe<Array<Scalars["String"]>>;
  owner_not_in?: InputMaybe<Array<Scalars["String"]>>;
  owner_contains?: InputMaybe<Scalars["String"]>;
  owner_contains_nocase?: InputMaybe<Scalars["String"]>;
  owner_not_contains?: InputMaybe<Scalars["String"]>;
  owner_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  owner_starts_with?: InputMaybe<Scalars["String"]>;
  owner_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  owner_not_starts_with?: InputMaybe<Scalars["String"]>;
  owner_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  owner_ends_with?: InputMaybe<Scalars["String"]>;
  owner_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  owner_not_ends_with?: InputMaybe<Scalars["String"]>;
  owner_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  owner_?: InputMaybe<Account_filter>;
  operator?: InputMaybe<Scalars["String"]>;
  operator_not?: InputMaybe<Scalars["String"]>;
  operator_gt?: InputMaybe<Scalars["String"]>;
  operator_lt?: InputMaybe<Scalars["String"]>;
  operator_gte?: InputMaybe<Scalars["String"]>;
  operator_lte?: InputMaybe<Scalars["String"]>;
  operator_in?: InputMaybe<Array<Scalars["String"]>>;
  operator_not_in?: InputMaybe<Array<Scalars["String"]>>;
  operator_contains?: InputMaybe<Scalars["String"]>;
  operator_contains_nocase?: InputMaybe<Scalars["String"]>;
  operator_not_contains?: InputMaybe<Scalars["String"]>;
  operator_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  operator_starts_with?: InputMaybe<Scalars["String"]>;
  operator_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  operator_not_starts_with?: InputMaybe<Scalars["String"]>;
  operator_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  operator_ends_with?: InputMaybe<Scalars["String"]>;
  operator_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  operator_not_ends_with?: InputMaybe<Scalars["String"]>;
  operator_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  operator_?: InputMaybe<Account_filter>;
  approved?: InputMaybe<Scalars["Boolean"]>;
  approved_not?: InputMaybe<Scalars["Boolean"]>;
  approved_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  approved_not_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<ApprovalForAllEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<ApprovalForAllEvent_filter>>>;
};

export type ApprovalForAllEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "owner"
  | "owner__id"
  | "owner__createdAtTimestamp"
  | "owner__createdAtBlockNumber"
  | "owner__updatedAtTimestamp"
  | "owner__updatedAtBlockNumber"
  | "owner__isSuperApp"
  | "operator"
  | "operator__id"
  | "operator__createdAtTimestamp"
  | "operator__createdAtBlockNumber"
  | "operator__updatedAtTimestamp"
  | "operator__updatedAtBlockNumber"
  | "operator__isSuperApp"
  | "approved";

export type BlockChangedFilter = {
  number_gte: Scalars["Int"];
};

export type Block_height = {
  hash?: InputMaybe<Scalars["Bytes"]>;
  number?: InputMaybe<Scalars["Int"]>;
  number_gte?: InputMaybe<Scalars["Int"]>;
};

export type BondIncreasedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  /**
   * The address of the `token` (supertoken).
   *
   */
  token: Scalars["Bytes"];
  /**
   * The additional amount added to the bond by the current Patrician In Charge (PIC).
   *
   */
  additionalBond: Scalars["BigInt"];
};

export type BondIncreasedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  additionalBond?: InputMaybe<Scalars["BigInt"]>;
  additionalBond_not?: InputMaybe<Scalars["BigInt"]>;
  additionalBond_gt?: InputMaybe<Scalars["BigInt"]>;
  additionalBond_lt?: InputMaybe<Scalars["BigInt"]>;
  additionalBond_gte?: InputMaybe<Scalars["BigInt"]>;
  additionalBond_lte?: InputMaybe<Scalars["BigInt"]>;
  additionalBond_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  additionalBond_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<BondIncreasedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<BondIncreasedEvent_filter>>>;
};

export type BondIncreasedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "additionalBond";

export type BufferAdjustedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `pool`
   * addresses[2] = `distributor`
   * addresses[3] = `operator`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
  bufferDelta: Scalars["BigInt"];
  newBufferAmount: Scalars["BigInt"];
  totalBufferAmount: Scalars["BigInt"];
  pool: Pool;
  poolDistributor: PoolDistributor;
};

export type BufferAdjustedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  bufferDelta?: InputMaybe<Scalars["BigInt"]>;
  bufferDelta_not?: InputMaybe<Scalars["BigInt"]>;
  bufferDelta_gt?: InputMaybe<Scalars["BigInt"]>;
  bufferDelta_lt?: InputMaybe<Scalars["BigInt"]>;
  bufferDelta_gte?: InputMaybe<Scalars["BigInt"]>;
  bufferDelta_lte?: InputMaybe<Scalars["BigInt"]>;
  bufferDelta_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  bufferDelta_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  newBufferAmount?: InputMaybe<Scalars["BigInt"]>;
  newBufferAmount_not?: InputMaybe<Scalars["BigInt"]>;
  newBufferAmount_gt?: InputMaybe<Scalars["BigInt"]>;
  newBufferAmount_lt?: InputMaybe<Scalars["BigInt"]>;
  newBufferAmount_gte?: InputMaybe<Scalars["BigInt"]>;
  newBufferAmount_lte?: InputMaybe<Scalars["BigInt"]>;
  newBufferAmount_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  newBufferAmount_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalBufferAmount?: InputMaybe<Scalars["BigInt"]>;
  totalBufferAmount_not?: InputMaybe<Scalars["BigInt"]>;
  totalBufferAmount_gt?: InputMaybe<Scalars["BigInt"]>;
  totalBufferAmount_lt?: InputMaybe<Scalars["BigInt"]>;
  totalBufferAmount_gte?: InputMaybe<Scalars["BigInt"]>;
  totalBufferAmount_lte?: InputMaybe<Scalars["BigInt"]>;
  totalBufferAmount_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalBufferAmount_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  pool?: InputMaybe<Scalars["String"]>;
  pool_not?: InputMaybe<Scalars["String"]>;
  pool_gt?: InputMaybe<Scalars["String"]>;
  pool_lt?: InputMaybe<Scalars["String"]>;
  pool_gte?: InputMaybe<Scalars["String"]>;
  pool_lte?: InputMaybe<Scalars["String"]>;
  pool_in?: InputMaybe<Array<Scalars["String"]>>;
  pool_not_in?: InputMaybe<Array<Scalars["String"]>>;
  pool_contains?: InputMaybe<Scalars["String"]>;
  pool_contains_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_contains?: InputMaybe<Scalars["String"]>;
  pool_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  pool_starts_with?: InputMaybe<Scalars["String"]>;
  pool_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_starts_with?: InputMaybe<Scalars["String"]>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_ends_with?: InputMaybe<Scalars["String"]>;
  pool_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_ends_with?: InputMaybe<Scalars["String"]>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_?: InputMaybe<Pool_filter>;
  poolDistributor?: InputMaybe<Scalars["String"]>;
  poolDistributor_not?: InputMaybe<Scalars["String"]>;
  poolDistributor_gt?: InputMaybe<Scalars["String"]>;
  poolDistributor_lt?: InputMaybe<Scalars["String"]>;
  poolDistributor_gte?: InputMaybe<Scalars["String"]>;
  poolDistributor_lte?: InputMaybe<Scalars["String"]>;
  poolDistributor_in?: InputMaybe<Array<Scalars["String"]>>;
  poolDistributor_not_in?: InputMaybe<Array<Scalars["String"]>>;
  poolDistributor_contains?: InputMaybe<Scalars["String"]>;
  poolDistributor_contains_nocase?: InputMaybe<Scalars["String"]>;
  poolDistributor_not_contains?: InputMaybe<Scalars["String"]>;
  poolDistributor_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  poolDistributor_starts_with?: InputMaybe<Scalars["String"]>;
  poolDistributor_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  poolDistributor_not_starts_with?: InputMaybe<Scalars["String"]>;
  poolDistributor_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  poolDistributor_ends_with?: InputMaybe<Scalars["String"]>;
  poolDistributor_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  poolDistributor_not_ends_with?: InputMaybe<Scalars["String"]>;
  poolDistributor_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  poolDistributor_?: InputMaybe<PoolDistributor_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<BufferAdjustedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<BufferAdjustedEvent_filter>>>;
};

export type BufferAdjustedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "bufferDelta"
  | "newBufferAmount"
  | "totalBufferAmount"
  | "pool"
  | "pool__id"
  | "pool__createdAtTimestamp"
  | "pool__createdAtBlockNumber"
  | "pool__updatedAtTimestamp"
  | "pool__updatedAtBlockNumber"
  | "pool__totalUnits"
  | "pool__totalConnectedUnits"
  | "pool__totalDisconnectedUnits"
  | "pool__totalAmountInstantlyDistributedUntilUpdatedAt"
  | "pool__totalAmountFlowedDistributedUntilUpdatedAt"
  | "pool__totalAmountDistributedUntilUpdatedAt"
  | "pool__totalFlowAdjustmentAmountDistributedUntilUpdatedAt"
  | "pool__perUnitSettledValue"
  | "pool__perUnitFlowRate"
  | "pool__totalMembers"
  | "pool__totalConnectedMembers"
  | "pool__totalDisconnectedMembers"
  | "pool__adjustmentFlowRate"
  | "pool__flowRate"
  | "pool__totalBuffer"
  | "poolDistributor"
  | "poolDistributor__id"
  | "poolDistributor__createdAtTimestamp"
  | "poolDistributor__createdAtBlockNumber"
  | "poolDistributor__updatedAtTimestamp"
  | "poolDistributor__updatedAtBlockNumber"
  | "poolDistributor__totalAmountInstantlyDistributedUntilUpdatedAt"
  | "poolDistributor__totalAmountFlowedDistributedUntilUpdatedAt"
  | "poolDistributor__totalAmountDistributedUntilUpdatedAt"
  | "poolDistributor__totalBuffer"
  | "poolDistributor__flowRate";

export type BurnedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `from`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  operator: Scalars["Bytes"];
  from: Scalars["Bytes"];
  token: Scalars["Bytes"];
  amount: Scalars["BigInt"];
  data: Scalars["Bytes"];
  operatorData: Scalars["Bytes"];
};

export type BurnedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  operator?: InputMaybe<Scalars["Bytes"]>;
  operator_not?: InputMaybe<Scalars["Bytes"]>;
  operator_gt?: InputMaybe<Scalars["Bytes"]>;
  operator_lt?: InputMaybe<Scalars["Bytes"]>;
  operator_gte?: InputMaybe<Scalars["Bytes"]>;
  operator_lte?: InputMaybe<Scalars["Bytes"]>;
  operator_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  operator_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  operator_contains?: InputMaybe<Scalars["Bytes"]>;
  operator_not_contains?: InputMaybe<Scalars["Bytes"]>;
  from?: InputMaybe<Scalars["Bytes"]>;
  from_not?: InputMaybe<Scalars["Bytes"]>;
  from_gt?: InputMaybe<Scalars["Bytes"]>;
  from_lt?: InputMaybe<Scalars["Bytes"]>;
  from_gte?: InputMaybe<Scalars["Bytes"]>;
  from_lte?: InputMaybe<Scalars["Bytes"]>;
  from_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  from_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  from_contains?: InputMaybe<Scalars["Bytes"]>;
  from_not_contains?: InputMaybe<Scalars["Bytes"]>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  amount?: InputMaybe<Scalars["BigInt"]>;
  amount_not?: InputMaybe<Scalars["BigInt"]>;
  amount_gt?: InputMaybe<Scalars["BigInt"]>;
  amount_lt?: InputMaybe<Scalars["BigInt"]>;
  amount_gte?: InputMaybe<Scalars["BigInt"]>;
  amount_lte?: InputMaybe<Scalars["BigInt"]>;
  amount_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  amount_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  data?: InputMaybe<Scalars["Bytes"]>;
  data_not?: InputMaybe<Scalars["Bytes"]>;
  data_gt?: InputMaybe<Scalars["Bytes"]>;
  data_lt?: InputMaybe<Scalars["Bytes"]>;
  data_gte?: InputMaybe<Scalars["Bytes"]>;
  data_lte?: InputMaybe<Scalars["Bytes"]>;
  data_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  data_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  data_contains?: InputMaybe<Scalars["Bytes"]>;
  data_not_contains?: InputMaybe<Scalars["Bytes"]>;
  operatorData?: InputMaybe<Scalars["Bytes"]>;
  operatorData_not?: InputMaybe<Scalars["Bytes"]>;
  operatorData_gt?: InputMaybe<Scalars["Bytes"]>;
  operatorData_lt?: InputMaybe<Scalars["Bytes"]>;
  operatorData_gte?: InputMaybe<Scalars["Bytes"]>;
  operatorData_lte?: InputMaybe<Scalars["Bytes"]>;
  operatorData_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  operatorData_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  operatorData_contains?: InputMaybe<Scalars["Bytes"]>;
  operatorData_not_contains?: InputMaybe<Scalars["Bytes"]>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<BurnedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<BurnedEvent_filter>>>;
};

export type BurnedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "operator"
  | "from"
  | "token"
  | "amount"
  | "data"
  | "operatorData";

export type CFAv1LiquidationPeriodChangedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * The address of the governance contract the event was emitted from.
   *
   */
  governanceAddress: Scalars["Bytes"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `governanceAddress`
   * addresses[1] = `host`
   * addresses[2] = `superToken`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  order: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  host: Scalars["Bytes"];
  superToken: Scalars["Bytes"];
  isKeySet: Scalars["Boolean"];
  liquidationPeriod: Scalars["BigInt"];
};

export type CFAv1LiquidationPeriodChangedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  governanceAddress?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_not?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_gt?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_lt?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_gte?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_lte?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  governanceAddress_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  governanceAddress_contains?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_not_contains?: InputMaybe<Scalars["Bytes"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  host?: InputMaybe<Scalars["Bytes"]>;
  host_not?: InputMaybe<Scalars["Bytes"]>;
  host_gt?: InputMaybe<Scalars["Bytes"]>;
  host_lt?: InputMaybe<Scalars["Bytes"]>;
  host_gte?: InputMaybe<Scalars["Bytes"]>;
  host_lte?: InputMaybe<Scalars["Bytes"]>;
  host_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  host_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  host_contains?: InputMaybe<Scalars["Bytes"]>;
  host_not_contains?: InputMaybe<Scalars["Bytes"]>;
  superToken?: InputMaybe<Scalars["Bytes"]>;
  superToken_not?: InputMaybe<Scalars["Bytes"]>;
  superToken_gt?: InputMaybe<Scalars["Bytes"]>;
  superToken_lt?: InputMaybe<Scalars["Bytes"]>;
  superToken_gte?: InputMaybe<Scalars["Bytes"]>;
  superToken_lte?: InputMaybe<Scalars["Bytes"]>;
  superToken_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  superToken_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  superToken_contains?: InputMaybe<Scalars["Bytes"]>;
  superToken_not_contains?: InputMaybe<Scalars["Bytes"]>;
  isKeySet?: InputMaybe<Scalars["Boolean"]>;
  isKeySet_not?: InputMaybe<Scalars["Boolean"]>;
  isKeySet_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  isKeySet_not_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  liquidationPeriod?: InputMaybe<Scalars["BigInt"]>;
  liquidationPeriod_not?: InputMaybe<Scalars["BigInt"]>;
  liquidationPeriod_gt?: InputMaybe<Scalars["BigInt"]>;
  liquidationPeriod_lt?: InputMaybe<Scalars["BigInt"]>;
  liquidationPeriod_gte?: InputMaybe<Scalars["BigInt"]>;
  liquidationPeriod_lte?: InputMaybe<Scalars["BigInt"]>;
  liquidationPeriod_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  liquidationPeriod_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<
    Array<InputMaybe<CFAv1LiquidationPeriodChangedEvent_filter>>
  >;
  or?: InputMaybe<Array<InputMaybe<CFAv1LiquidationPeriodChangedEvent_filter>>>;
};

export type CFAv1LiquidationPeriodChangedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "governanceAddress"
  | "addresses"
  | "blockNumber"
  | "order"
  | "logIndex"
  | "host"
  | "superToken"
  | "isKeySet"
  | "liquidationPeriod";

export type ConfigChangedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * The address of the governance contract the event was emitted from.
   *
   */
  governanceAddress: Scalars["Bytes"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `governanceAddress`
   * addresses[1] = `host`
   * addresses[2] = `superToken`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  host: Scalars["Bytes"];
  superToken: Scalars["Bytes"];
  key: Scalars["Bytes"];
  isKeySet: Scalars["Boolean"];
  value: Scalars["BigInt"];
};

export type ConfigChangedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  governanceAddress?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_not?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_gt?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_lt?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_gte?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_lte?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  governanceAddress_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  governanceAddress_contains?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_not_contains?: InputMaybe<Scalars["Bytes"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  host?: InputMaybe<Scalars["Bytes"]>;
  host_not?: InputMaybe<Scalars["Bytes"]>;
  host_gt?: InputMaybe<Scalars["Bytes"]>;
  host_lt?: InputMaybe<Scalars["Bytes"]>;
  host_gte?: InputMaybe<Scalars["Bytes"]>;
  host_lte?: InputMaybe<Scalars["Bytes"]>;
  host_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  host_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  host_contains?: InputMaybe<Scalars["Bytes"]>;
  host_not_contains?: InputMaybe<Scalars["Bytes"]>;
  superToken?: InputMaybe<Scalars["Bytes"]>;
  superToken_not?: InputMaybe<Scalars["Bytes"]>;
  superToken_gt?: InputMaybe<Scalars["Bytes"]>;
  superToken_lt?: InputMaybe<Scalars["Bytes"]>;
  superToken_gte?: InputMaybe<Scalars["Bytes"]>;
  superToken_lte?: InputMaybe<Scalars["Bytes"]>;
  superToken_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  superToken_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  superToken_contains?: InputMaybe<Scalars["Bytes"]>;
  superToken_not_contains?: InputMaybe<Scalars["Bytes"]>;
  key?: InputMaybe<Scalars["Bytes"]>;
  key_not?: InputMaybe<Scalars["Bytes"]>;
  key_gt?: InputMaybe<Scalars["Bytes"]>;
  key_lt?: InputMaybe<Scalars["Bytes"]>;
  key_gte?: InputMaybe<Scalars["Bytes"]>;
  key_lte?: InputMaybe<Scalars["Bytes"]>;
  key_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  key_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  key_contains?: InputMaybe<Scalars["Bytes"]>;
  key_not_contains?: InputMaybe<Scalars["Bytes"]>;
  isKeySet?: InputMaybe<Scalars["Boolean"]>;
  isKeySet_not?: InputMaybe<Scalars["Boolean"]>;
  isKeySet_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  isKeySet_not_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  value?: InputMaybe<Scalars["BigInt"]>;
  value_not?: InputMaybe<Scalars["BigInt"]>;
  value_gt?: InputMaybe<Scalars["BigInt"]>;
  value_lt?: InputMaybe<Scalars["BigInt"]>;
  value_gte?: InputMaybe<Scalars["BigInt"]>;
  value_lte?: InputMaybe<Scalars["BigInt"]>;
  value_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  value_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<ConfigChangedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<ConfigChangedEvent_filter>>>;
};

export type ConfigChangedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "governanceAddress"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "host"
  | "superToken"
  | "key"
  | "isKeySet"
  | "value";

export type CustomSuperTokenCreatedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
};

export type CustomSuperTokenCreatedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<CustomSuperTokenCreatedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<CustomSuperTokenCreatedEvent_filter>>>;
};

export type CustomSuperTokenCreatedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token";

export type DistributionClaimedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `pool`
   * addresses[2] = `member`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
  claimedAmount: Scalars["BigInt"];
  totalClaimed: Scalars["BigInt"];
  pool: Pool;
  poolMember: PoolMember;
};

export type DistributionClaimedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  claimedAmount?: InputMaybe<Scalars["BigInt"]>;
  claimedAmount_not?: InputMaybe<Scalars["BigInt"]>;
  claimedAmount_gt?: InputMaybe<Scalars["BigInt"]>;
  claimedAmount_lt?: InputMaybe<Scalars["BigInt"]>;
  claimedAmount_gte?: InputMaybe<Scalars["BigInt"]>;
  claimedAmount_lte?: InputMaybe<Scalars["BigInt"]>;
  claimedAmount_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  claimedAmount_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalClaimed?: InputMaybe<Scalars["BigInt"]>;
  totalClaimed_not?: InputMaybe<Scalars["BigInt"]>;
  totalClaimed_gt?: InputMaybe<Scalars["BigInt"]>;
  totalClaimed_lt?: InputMaybe<Scalars["BigInt"]>;
  totalClaimed_gte?: InputMaybe<Scalars["BigInt"]>;
  totalClaimed_lte?: InputMaybe<Scalars["BigInt"]>;
  totalClaimed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalClaimed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  pool?: InputMaybe<Scalars["String"]>;
  pool_not?: InputMaybe<Scalars["String"]>;
  pool_gt?: InputMaybe<Scalars["String"]>;
  pool_lt?: InputMaybe<Scalars["String"]>;
  pool_gte?: InputMaybe<Scalars["String"]>;
  pool_lte?: InputMaybe<Scalars["String"]>;
  pool_in?: InputMaybe<Array<Scalars["String"]>>;
  pool_not_in?: InputMaybe<Array<Scalars["String"]>>;
  pool_contains?: InputMaybe<Scalars["String"]>;
  pool_contains_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_contains?: InputMaybe<Scalars["String"]>;
  pool_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  pool_starts_with?: InputMaybe<Scalars["String"]>;
  pool_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_starts_with?: InputMaybe<Scalars["String"]>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_ends_with?: InputMaybe<Scalars["String"]>;
  pool_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_ends_with?: InputMaybe<Scalars["String"]>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_?: InputMaybe<Pool_filter>;
  poolMember?: InputMaybe<Scalars["String"]>;
  poolMember_not?: InputMaybe<Scalars["String"]>;
  poolMember_gt?: InputMaybe<Scalars["String"]>;
  poolMember_lt?: InputMaybe<Scalars["String"]>;
  poolMember_gte?: InputMaybe<Scalars["String"]>;
  poolMember_lte?: InputMaybe<Scalars["String"]>;
  poolMember_in?: InputMaybe<Array<Scalars["String"]>>;
  poolMember_not_in?: InputMaybe<Array<Scalars["String"]>>;
  poolMember_contains?: InputMaybe<Scalars["String"]>;
  poolMember_contains_nocase?: InputMaybe<Scalars["String"]>;
  poolMember_not_contains?: InputMaybe<Scalars["String"]>;
  poolMember_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  poolMember_starts_with?: InputMaybe<Scalars["String"]>;
  poolMember_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  poolMember_not_starts_with?: InputMaybe<Scalars["String"]>;
  poolMember_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  poolMember_ends_with?: InputMaybe<Scalars["String"]>;
  poolMember_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  poolMember_not_ends_with?: InputMaybe<Scalars["String"]>;
  poolMember_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  poolMember_?: InputMaybe<PoolMember_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<DistributionClaimedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<DistributionClaimedEvent_filter>>>;
};

export type DistributionClaimedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "claimedAmount"
  | "totalClaimed"
  | "pool"
  | "pool__id"
  | "pool__createdAtTimestamp"
  | "pool__createdAtBlockNumber"
  | "pool__updatedAtTimestamp"
  | "pool__updatedAtBlockNumber"
  | "pool__totalUnits"
  | "pool__totalConnectedUnits"
  | "pool__totalDisconnectedUnits"
  | "pool__totalAmountInstantlyDistributedUntilUpdatedAt"
  | "pool__totalAmountFlowedDistributedUntilUpdatedAt"
  | "pool__totalAmountDistributedUntilUpdatedAt"
  | "pool__totalFlowAdjustmentAmountDistributedUntilUpdatedAt"
  | "pool__perUnitSettledValue"
  | "pool__perUnitFlowRate"
  | "pool__totalMembers"
  | "pool__totalConnectedMembers"
  | "pool__totalDisconnectedMembers"
  | "pool__adjustmentFlowRate"
  | "pool__flowRate"
  | "pool__totalBuffer"
  | "poolMember"
  | "poolMember__id"
  | "poolMember__createdAtTimestamp"
  | "poolMember__createdAtBlockNumber"
  | "poolMember__updatedAtTimestamp"
  | "poolMember__updatedAtBlockNumber"
  | "poolMember__units"
  | "poolMember__isConnected"
  | "poolMember__totalAmountClaimed"
  | "poolMember__poolTotalAmountDistributedUntilUpdatedAt"
  | "poolMember__totalAmountReceivedUntilUpdatedAt"
  | "poolMember__syncedPerUnitSettledValue"
  | "poolMember__syncedPerUnitFlowRate";

/**
 * Event: An interface which is shared by all event entities and contains basic transaction data.
 *
 */
export type Event = {
  /**
   * The id of the event entity.
   *
   */
  id: Scalars["ID"];
  /**
   * The block number which the event was logged in.
   *
   */
  blockNumber: Scalars["BigInt"];
  /**
   * The index of the event, e.g. first event emitted would have `logIndex` of 0.
   *
   */
  logIndex: Scalars["BigInt"];
  /**
   * A number used internally to sort the order of transactions.
   * The formula: `blockNumber * ORDER_MULTIPLIER + logIndex`
   * where: ORDER_MULTIPLIER = 10000
   *
   */
  order: Scalars["BigInt"];
  /**
   * The name of the event - is a 1-to-1 match with the name in our smart contracts.
   *
   */
  name: Scalars["String"];
  /**
   * Contains the addresses for accounts that were "impacted" by the event.
   * This typically involves accounts which experienced a state change as a result of the transaction which emitted this event.
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  /**
   * The block timestamp which the event was logged in.
   *
   */
  timestamp: Scalars["BigInt"];
  /**
   * The transaction hash of the transaction that the event was logged in.
   *
   */
  transactionHash: Scalars["Bytes"];
  /**
   * The gas price of the transaction that the event was logged in.
   *
   */
  gasPrice: Scalars["BigInt"];
  /**
   * The gas used for this transaction.
   *
   */
  gasUsed: Scalars["BigInt"];
};

export type Event_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<Event_filter>>>;
  or?: InputMaybe<Array<InputMaybe<Event_filter>>>;
};

export type Event_orderBy =
  | "id"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "name"
  | "addresses"
  | "timestamp"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed";

export type ExitRateChangedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  /**
   * The address of the `token` (supertoken).
   *
   */
  token: Scalars["Bytes"];
  /**
   * The flowrate at which the bond is streamed back to the Patrician In Charge.
   *
   */
  exitRate: Scalars["BigInt"];
};

export type ExitRateChangedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  exitRate?: InputMaybe<Scalars["BigInt"]>;
  exitRate_not?: InputMaybe<Scalars["BigInt"]>;
  exitRate_gt?: InputMaybe<Scalars["BigInt"]>;
  exitRate_lt?: InputMaybe<Scalars["BigInt"]>;
  exitRate_gte?: InputMaybe<Scalars["BigInt"]>;
  exitRate_lte?: InputMaybe<Scalars["BigInt"]>;
  exitRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  exitRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<ExitRateChangedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<ExitRateChangedEvent_filter>>>;
};

export type ExitRateChangedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "exitRate";

export type FlowDistributionUpdatedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `pool`
   * addresses[2] = `poolDistributor`
   * addresses[3] = `operator`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
  operator: Scalars["Bytes"];
  oldFlowRate: Scalars["BigInt"];
  newDistributorToPoolFlowRate: Scalars["BigInt"];
  newTotalDistributionFlowRate: Scalars["BigInt"];
  adjustmentFlowRecipient: Scalars["Bytes"];
  adjustmentFlowRate: Scalars["BigInt"];
  totalUnits: Scalars["BigInt"];
  userData: Scalars["Bytes"];
  pool: Pool;
  poolDistributor: PoolDistributor;
};

export type FlowDistributionUpdatedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  operator?: InputMaybe<Scalars["Bytes"]>;
  operator_not?: InputMaybe<Scalars["Bytes"]>;
  operator_gt?: InputMaybe<Scalars["Bytes"]>;
  operator_lt?: InputMaybe<Scalars["Bytes"]>;
  operator_gte?: InputMaybe<Scalars["Bytes"]>;
  operator_lte?: InputMaybe<Scalars["Bytes"]>;
  operator_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  operator_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  operator_contains?: InputMaybe<Scalars["Bytes"]>;
  operator_not_contains?: InputMaybe<Scalars["Bytes"]>;
  oldFlowRate?: InputMaybe<Scalars["BigInt"]>;
  oldFlowRate_not?: InputMaybe<Scalars["BigInt"]>;
  oldFlowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  oldFlowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  oldFlowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  oldFlowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  oldFlowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  oldFlowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  newDistributorToPoolFlowRate?: InputMaybe<Scalars["BigInt"]>;
  newDistributorToPoolFlowRate_not?: InputMaybe<Scalars["BigInt"]>;
  newDistributorToPoolFlowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  newDistributorToPoolFlowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  newDistributorToPoolFlowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  newDistributorToPoolFlowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  newDistributorToPoolFlowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  newDistributorToPoolFlowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  newTotalDistributionFlowRate?: InputMaybe<Scalars["BigInt"]>;
  newTotalDistributionFlowRate_not?: InputMaybe<Scalars["BigInt"]>;
  newTotalDistributionFlowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  newTotalDistributionFlowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  newTotalDistributionFlowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  newTotalDistributionFlowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  newTotalDistributionFlowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  newTotalDistributionFlowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  adjustmentFlowRecipient?: InputMaybe<Scalars["Bytes"]>;
  adjustmentFlowRecipient_not?: InputMaybe<Scalars["Bytes"]>;
  adjustmentFlowRecipient_gt?: InputMaybe<Scalars["Bytes"]>;
  adjustmentFlowRecipient_lt?: InputMaybe<Scalars["Bytes"]>;
  adjustmentFlowRecipient_gte?: InputMaybe<Scalars["Bytes"]>;
  adjustmentFlowRecipient_lte?: InputMaybe<Scalars["Bytes"]>;
  adjustmentFlowRecipient_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  adjustmentFlowRecipient_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  adjustmentFlowRecipient_contains?: InputMaybe<Scalars["Bytes"]>;
  adjustmentFlowRecipient_not_contains?: InputMaybe<Scalars["Bytes"]>;
  adjustmentFlowRate?: InputMaybe<Scalars["BigInt"]>;
  adjustmentFlowRate_not?: InputMaybe<Scalars["BigInt"]>;
  adjustmentFlowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  adjustmentFlowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  adjustmentFlowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  adjustmentFlowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  adjustmentFlowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  adjustmentFlowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalUnits?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_not?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_gt?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_lt?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_gte?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_lte?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalUnits_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  userData?: InputMaybe<Scalars["Bytes"]>;
  userData_not?: InputMaybe<Scalars["Bytes"]>;
  userData_gt?: InputMaybe<Scalars["Bytes"]>;
  userData_lt?: InputMaybe<Scalars["Bytes"]>;
  userData_gte?: InputMaybe<Scalars["Bytes"]>;
  userData_lte?: InputMaybe<Scalars["Bytes"]>;
  userData_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_contains?: InputMaybe<Scalars["Bytes"]>;
  userData_not_contains?: InputMaybe<Scalars["Bytes"]>;
  pool?: InputMaybe<Scalars["String"]>;
  pool_not?: InputMaybe<Scalars["String"]>;
  pool_gt?: InputMaybe<Scalars["String"]>;
  pool_lt?: InputMaybe<Scalars["String"]>;
  pool_gte?: InputMaybe<Scalars["String"]>;
  pool_lte?: InputMaybe<Scalars["String"]>;
  pool_in?: InputMaybe<Array<Scalars["String"]>>;
  pool_not_in?: InputMaybe<Array<Scalars["String"]>>;
  pool_contains?: InputMaybe<Scalars["String"]>;
  pool_contains_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_contains?: InputMaybe<Scalars["String"]>;
  pool_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  pool_starts_with?: InputMaybe<Scalars["String"]>;
  pool_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_starts_with?: InputMaybe<Scalars["String"]>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_ends_with?: InputMaybe<Scalars["String"]>;
  pool_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_ends_with?: InputMaybe<Scalars["String"]>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_?: InputMaybe<Pool_filter>;
  poolDistributor?: InputMaybe<Scalars["String"]>;
  poolDistributor_not?: InputMaybe<Scalars["String"]>;
  poolDistributor_gt?: InputMaybe<Scalars["String"]>;
  poolDistributor_lt?: InputMaybe<Scalars["String"]>;
  poolDistributor_gte?: InputMaybe<Scalars["String"]>;
  poolDistributor_lte?: InputMaybe<Scalars["String"]>;
  poolDistributor_in?: InputMaybe<Array<Scalars["String"]>>;
  poolDistributor_not_in?: InputMaybe<Array<Scalars["String"]>>;
  poolDistributor_contains?: InputMaybe<Scalars["String"]>;
  poolDistributor_contains_nocase?: InputMaybe<Scalars["String"]>;
  poolDistributor_not_contains?: InputMaybe<Scalars["String"]>;
  poolDistributor_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  poolDistributor_starts_with?: InputMaybe<Scalars["String"]>;
  poolDistributor_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  poolDistributor_not_starts_with?: InputMaybe<Scalars["String"]>;
  poolDistributor_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  poolDistributor_ends_with?: InputMaybe<Scalars["String"]>;
  poolDistributor_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  poolDistributor_not_ends_with?: InputMaybe<Scalars["String"]>;
  poolDistributor_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  poolDistributor_?: InputMaybe<PoolDistributor_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<FlowDistributionUpdatedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<FlowDistributionUpdatedEvent_filter>>>;
};

export type FlowDistributionUpdatedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "operator"
  | "oldFlowRate"
  | "newDistributorToPoolFlowRate"
  | "newTotalDistributionFlowRate"
  | "adjustmentFlowRecipient"
  | "adjustmentFlowRate"
  | "totalUnits"
  | "userData"
  | "pool"
  | "pool__id"
  | "pool__createdAtTimestamp"
  | "pool__createdAtBlockNumber"
  | "pool__updatedAtTimestamp"
  | "pool__updatedAtBlockNumber"
  | "pool__totalUnits"
  | "pool__totalConnectedUnits"
  | "pool__totalDisconnectedUnits"
  | "pool__totalAmountInstantlyDistributedUntilUpdatedAt"
  | "pool__totalAmountFlowedDistributedUntilUpdatedAt"
  | "pool__totalAmountDistributedUntilUpdatedAt"
  | "pool__totalFlowAdjustmentAmountDistributedUntilUpdatedAt"
  | "pool__perUnitSettledValue"
  | "pool__perUnitFlowRate"
  | "pool__totalMembers"
  | "pool__totalConnectedMembers"
  | "pool__totalDisconnectedMembers"
  | "pool__adjustmentFlowRate"
  | "pool__flowRate"
  | "pool__totalBuffer"
  | "poolDistributor"
  | "poolDistributor__id"
  | "poolDistributor__createdAtTimestamp"
  | "poolDistributor__createdAtBlockNumber"
  | "poolDistributor__updatedAtTimestamp"
  | "poolDistributor__updatedAtBlockNumber"
  | "poolDistributor__totalAmountInstantlyDistributedUntilUpdatedAt"
  | "poolDistributor__totalAmountFlowedDistributedUntilUpdatedAt"
  | "poolDistributor__totalAmountDistributedUntilUpdatedAt"
  | "poolDistributor__totalBuffer"
  | "poolDistributor__flowRate";

/**
 * FlowOperator: A higher order entity that of a flow operator for an `AccountTokenSnapshot`.
 *
 */
export type FlowOperator = {
  /**
   * ID composed of: flowOperator-token-sender
   *
   */
  id: Scalars["ID"];
  createdAtTimestamp: Scalars["BigInt"];
  createdAtBlockNumber: Scalars["BigInt"];
  updatedAtTimestamp: Scalars["BigInt"];
  updatedAtBlockNumber: Scalars["BigInt"];
  /**
   * The permissions granted to the `flowOperator`.
   * Bitmask representation:
   * Delete | Update | Create
   * | D | U | C |
   * | 0 | 0 | 0 |
   *
   */
  permissions: Scalars["Int"];
  /**
   * The flow rate allowance granted to the `flowOperator` by the `sender`. This can be reset if the `sender` updates the `flowOperator` flow rate allowance.
   *
   */
  flowRateAllowanceGranted: Scalars["BigInt"];
  /**
   * The remaining flow rate allowance the `flowOperator` has.
   * This will go down every time when the `flowOperator` uses the allowance, that is, if they increase flowRate for `sender` or create a new flow on behalf of `sender`.
   * It can only be reset if the `sender` updates the flow rate allowance.
   * NOTE: this value will NOT go down if max flow rate allowance is set.
   *
   */
  flowRateAllowanceRemaining: Scalars["BigInt"];
  /**
   * The transfer allowance granted to the `flowOperator` by the `sender`.
   *
   */
  allowance: Scalars["BigInt"];
  flowOperator: Scalars["Bytes"];
  sender: Account;
  token: Token;
  accountTokenSnapshot: AccountTokenSnapshot;
  flowOperatorUpdatedEvents: Array<FlowOperatorUpdatedEvent>;
};

/**
 * FlowOperator: A higher order entity that of a flow operator for an `AccountTokenSnapshot`.
 *
 */
export type FlowOperatorflowOperatorUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<FlowOperatorUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<FlowOperatorUpdatedEvent_filter>;
};

export type FlowOperatorUpdatedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = sender
   * addresses[2] = `flowOperator`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  /**
   * The address of the `token` being streamed.
   *
   */
  token: Scalars["Bytes"];
  sender: Scalars["Bytes"];
  /**
   * The permissions granted to the `flowOperator`.
   * Octo bitmask representation.
   *
   */
  permissions: Scalars["Int"];
  flowRateAllowance: Scalars["BigInt"];
  flowOperator: FlowOperator;
};

export type FlowOperatorUpdatedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  sender?: InputMaybe<Scalars["Bytes"]>;
  sender_not?: InputMaybe<Scalars["Bytes"]>;
  sender_gt?: InputMaybe<Scalars["Bytes"]>;
  sender_lt?: InputMaybe<Scalars["Bytes"]>;
  sender_gte?: InputMaybe<Scalars["Bytes"]>;
  sender_lte?: InputMaybe<Scalars["Bytes"]>;
  sender_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  sender_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  sender_contains?: InputMaybe<Scalars["Bytes"]>;
  sender_not_contains?: InputMaybe<Scalars["Bytes"]>;
  permissions?: InputMaybe<Scalars["Int"]>;
  permissions_not?: InputMaybe<Scalars["Int"]>;
  permissions_gt?: InputMaybe<Scalars["Int"]>;
  permissions_lt?: InputMaybe<Scalars["Int"]>;
  permissions_gte?: InputMaybe<Scalars["Int"]>;
  permissions_lte?: InputMaybe<Scalars["Int"]>;
  permissions_in?: InputMaybe<Array<Scalars["Int"]>>;
  permissions_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  flowRateAllowance?: InputMaybe<Scalars["BigInt"]>;
  flowRateAllowance_not?: InputMaybe<Scalars["BigInt"]>;
  flowRateAllowance_gt?: InputMaybe<Scalars["BigInt"]>;
  flowRateAllowance_lt?: InputMaybe<Scalars["BigInt"]>;
  flowRateAllowance_gte?: InputMaybe<Scalars["BigInt"]>;
  flowRateAllowance_lte?: InputMaybe<Scalars["BigInt"]>;
  flowRateAllowance_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  flowRateAllowance_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  flowOperator?: InputMaybe<Scalars["String"]>;
  flowOperator_not?: InputMaybe<Scalars["String"]>;
  flowOperator_gt?: InputMaybe<Scalars["String"]>;
  flowOperator_lt?: InputMaybe<Scalars["String"]>;
  flowOperator_gte?: InputMaybe<Scalars["String"]>;
  flowOperator_lte?: InputMaybe<Scalars["String"]>;
  flowOperator_in?: InputMaybe<Array<Scalars["String"]>>;
  flowOperator_not_in?: InputMaybe<Array<Scalars["String"]>>;
  flowOperator_contains?: InputMaybe<Scalars["String"]>;
  flowOperator_contains_nocase?: InputMaybe<Scalars["String"]>;
  flowOperator_not_contains?: InputMaybe<Scalars["String"]>;
  flowOperator_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  flowOperator_starts_with?: InputMaybe<Scalars["String"]>;
  flowOperator_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  flowOperator_not_starts_with?: InputMaybe<Scalars["String"]>;
  flowOperator_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  flowOperator_ends_with?: InputMaybe<Scalars["String"]>;
  flowOperator_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  flowOperator_not_ends_with?: InputMaybe<Scalars["String"]>;
  flowOperator_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  flowOperator_?: InputMaybe<FlowOperator_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<FlowOperatorUpdatedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<FlowOperatorUpdatedEvent_filter>>>;
};

export type FlowOperatorUpdatedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "sender"
  | "permissions"
  | "flowRateAllowance"
  | "flowOperator"
  | "flowOperator__id"
  | "flowOperator__createdAtTimestamp"
  | "flowOperator__createdAtBlockNumber"
  | "flowOperator__updatedAtTimestamp"
  | "flowOperator__updatedAtBlockNumber"
  | "flowOperator__permissions"
  | "flowOperator__flowRateAllowanceGranted"
  | "flowOperator__flowRateAllowanceRemaining"
  | "flowOperator__allowance"
  | "flowOperator__flowOperator";

export type FlowOperator_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  createdAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  permissions?: InputMaybe<Scalars["Int"]>;
  permissions_not?: InputMaybe<Scalars["Int"]>;
  permissions_gt?: InputMaybe<Scalars["Int"]>;
  permissions_lt?: InputMaybe<Scalars["Int"]>;
  permissions_gte?: InputMaybe<Scalars["Int"]>;
  permissions_lte?: InputMaybe<Scalars["Int"]>;
  permissions_in?: InputMaybe<Array<Scalars["Int"]>>;
  permissions_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  flowRateAllowanceGranted?: InputMaybe<Scalars["BigInt"]>;
  flowRateAllowanceGranted_not?: InputMaybe<Scalars["BigInt"]>;
  flowRateAllowanceGranted_gt?: InputMaybe<Scalars["BigInt"]>;
  flowRateAllowanceGranted_lt?: InputMaybe<Scalars["BigInt"]>;
  flowRateAllowanceGranted_gte?: InputMaybe<Scalars["BigInt"]>;
  flowRateAllowanceGranted_lte?: InputMaybe<Scalars["BigInt"]>;
  flowRateAllowanceGranted_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  flowRateAllowanceGranted_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  flowRateAllowanceRemaining?: InputMaybe<Scalars["BigInt"]>;
  flowRateAllowanceRemaining_not?: InputMaybe<Scalars["BigInt"]>;
  flowRateAllowanceRemaining_gt?: InputMaybe<Scalars["BigInt"]>;
  flowRateAllowanceRemaining_lt?: InputMaybe<Scalars["BigInt"]>;
  flowRateAllowanceRemaining_gte?: InputMaybe<Scalars["BigInt"]>;
  flowRateAllowanceRemaining_lte?: InputMaybe<Scalars["BigInt"]>;
  flowRateAllowanceRemaining_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  flowRateAllowanceRemaining_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  allowance?: InputMaybe<Scalars["BigInt"]>;
  allowance_not?: InputMaybe<Scalars["BigInt"]>;
  allowance_gt?: InputMaybe<Scalars["BigInt"]>;
  allowance_lt?: InputMaybe<Scalars["BigInt"]>;
  allowance_gte?: InputMaybe<Scalars["BigInt"]>;
  allowance_lte?: InputMaybe<Scalars["BigInt"]>;
  allowance_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  allowance_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  flowOperator?: InputMaybe<Scalars["Bytes"]>;
  flowOperator_not?: InputMaybe<Scalars["Bytes"]>;
  flowOperator_gt?: InputMaybe<Scalars["Bytes"]>;
  flowOperator_lt?: InputMaybe<Scalars["Bytes"]>;
  flowOperator_gte?: InputMaybe<Scalars["Bytes"]>;
  flowOperator_lte?: InputMaybe<Scalars["Bytes"]>;
  flowOperator_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  flowOperator_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  flowOperator_contains?: InputMaybe<Scalars["Bytes"]>;
  flowOperator_not_contains?: InputMaybe<Scalars["Bytes"]>;
  sender?: InputMaybe<Scalars["String"]>;
  sender_not?: InputMaybe<Scalars["String"]>;
  sender_gt?: InputMaybe<Scalars["String"]>;
  sender_lt?: InputMaybe<Scalars["String"]>;
  sender_gte?: InputMaybe<Scalars["String"]>;
  sender_lte?: InputMaybe<Scalars["String"]>;
  sender_in?: InputMaybe<Array<Scalars["String"]>>;
  sender_not_in?: InputMaybe<Array<Scalars["String"]>>;
  sender_contains?: InputMaybe<Scalars["String"]>;
  sender_contains_nocase?: InputMaybe<Scalars["String"]>;
  sender_not_contains?: InputMaybe<Scalars["String"]>;
  sender_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  sender_starts_with?: InputMaybe<Scalars["String"]>;
  sender_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  sender_not_starts_with?: InputMaybe<Scalars["String"]>;
  sender_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  sender_ends_with?: InputMaybe<Scalars["String"]>;
  sender_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  sender_not_ends_with?: InputMaybe<Scalars["String"]>;
  sender_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  sender_?: InputMaybe<Account_filter>;
  token?: InputMaybe<Scalars["String"]>;
  token_not?: InputMaybe<Scalars["String"]>;
  token_gt?: InputMaybe<Scalars["String"]>;
  token_lt?: InputMaybe<Scalars["String"]>;
  token_gte?: InputMaybe<Scalars["String"]>;
  token_lte?: InputMaybe<Scalars["String"]>;
  token_in?: InputMaybe<Array<Scalars["String"]>>;
  token_not_in?: InputMaybe<Array<Scalars["String"]>>;
  token_contains?: InputMaybe<Scalars["String"]>;
  token_contains_nocase?: InputMaybe<Scalars["String"]>;
  token_not_contains?: InputMaybe<Scalars["String"]>;
  token_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  token_starts_with?: InputMaybe<Scalars["String"]>;
  token_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  token_not_starts_with?: InputMaybe<Scalars["String"]>;
  token_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  token_ends_with?: InputMaybe<Scalars["String"]>;
  token_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  token_not_ends_with?: InputMaybe<Scalars["String"]>;
  token_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  token_?: InputMaybe<Token_filter>;
  accountTokenSnapshot?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_not?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_gt?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_lt?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_gte?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_lte?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_in?: InputMaybe<Array<Scalars["String"]>>;
  accountTokenSnapshot_not_in?: InputMaybe<Array<Scalars["String"]>>;
  accountTokenSnapshot_contains?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_contains_nocase?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_not_contains?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_starts_with?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_not_starts_with?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_ends_with?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_not_ends_with?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  accountTokenSnapshot_?: InputMaybe<AccountTokenSnapshot_filter>;
  flowOperatorUpdatedEvents_?: InputMaybe<FlowOperatorUpdatedEvent_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<FlowOperator_filter>>>;
  or?: InputMaybe<Array<InputMaybe<FlowOperator_filter>>>;
};

export type FlowOperator_orderBy =
  | "id"
  | "createdAtTimestamp"
  | "createdAtBlockNumber"
  | "updatedAtTimestamp"
  | "updatedAtBlockNumber"
  | "permissions"
  | "flowRateAllowanceGranted"
  | "flowRateAllowanceRemaining"
  | "allowance"
  | "flowOperator"
  | "sender"
  | "sender__id"
  | "sender__createdAtTimestamp"
  | "sender__createdAtBlockNumber"
  | "sender__updatedAtTimestamp"
  | "sender__updatedAtBlockNumber"
  | "sender__isSuperApp"
  | "token"
  | "token__id"
  | "token__createdAtTimestamp"
  | "token__createdAtBlockNumber"
  | "token__decimals"
  | "token__name"
  | "token__symbol"
  | "token__isSuperToken"
  | "token__isNativeAssetSuperToken"
  | "token__isListed"
  | "token__underlyingAddress"
  | "accountTokenSnapshot"
  | "accountTokenSnapshot__id"
  | "accountTokenSnapshot__createdAtTimestamp"
  | "accountTokenSnapshot__createdAtBlockNumber"
  | "accountTokenSnapshot__updatedAtTimestamp"
  | "accountTokenSnapshot__updatedAtBlockNumber"
  | "accountTokenSnapshot__isLiquidationEstimateOptimistic"
  | "accountTokenSnapshot__maybeCriticalAtTimestamp"
  | "accountTokenSnapshot__totalNumberOfActiveStreams"
  | "accountTokenSnapshot__totalCFANumberOfActiveStreams"
  | "accountTokenSnapshot__totalGDANumberOfActiveStreams"
  | "accountTokenSnapshot__activeOutgoingStreamCount"
  | "accountTokenSnapshot__activeCFAOutgoingStreamCount"
  | "accountTokenSnapshot__activeGDAOutgoingStreamCount"
  | "accountTokenSnapshot__activeIncomingStreamCount"
  | "accountTokenSnapshot__totalNumberOfClosedStreams"
  | "accountTokenSnapshot__totalCFANumberOfClosedStreams"
  | "accountTokenSnapshot__totalGDANumberOfClosedStreams"
  | "accountTokenSnapshot__inactiveOutgoingStreamCount"
  | "accountTokenSnapshot__inactiveCFAOutgoingStreamCount"
  | "accountTokenSnapshot__inactiveGDAOutgoingStreamCount"
  | "accountTokenSnapshot__inactiveIncomingStreamCount"
  | "accountTokenSnapshot__totalSubscriptionsWithUnits"
  | "accountTokenSnapshot__totalApprovedSubscriptions"
  | "accountTokenSnapshot__totalMembershipsWithUnits"
  | "accountTokenSnapshot__totalConnectedMemberships"
  | "accountTokenSnapshot__balanceUntilUpdatedAt"
  | "accountTokenSnapshot__totalDeposit"
  | "accountTokenSnapshot__totalCFADeposit"
  | "accountTokenSnapshot__totalGDADeposit"
  | "accountTokenSnapshot__totalNetFlowRate"
  | "accountTokenSnapshot__totalCFANetFlowRate"
  | "accountTokenSnapshot__totalInflowRate"
  | "accountTokenSnapshot__totalOutflowRate"
  | "accountTokenSnapshot__totalCFAOutflowRate"
  | "accountTokenSnapshot__totalGDAOutflowRate"
  | "accountTokenSnapshot__totalAmountStreamedInUntilUpdatedAt"
  | "accountTokenSnapshot__totalAmountStreamedOutUntilUpdatedAt"
  | "accountTokenSnapshot__totalCFAAmountStreamedOutUntilUpdatedAt"
  | "accountTokenSnapshot__totalAmountStreamedUntilUpdatedAt"
  | "accountTokenSnapshot__totalCFAAmountStreamedUntilUpdatedAt"
  | "accountTokenSnapshot__totalAmountTransferredUntilUpdatedAt"
  | "flowOperatorUpdatedEvents";

/**
 * FlowUpdated: An `Event` entity that is emitted
 * when a flow is created, updated, or deleted.
 *
 */
export type FlowUpdatedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (supertoken)
   * addresses[1] = `sender`
   * addresses[2] = `receiver`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  /**
   * The address of the `token` (supertoken) being streamed.
   *
   */
  token: Scalars["Bytes"];
  /**
   * The address of the flow sender.
   *
   */
  sender: Scalars["Bytes"];
  /**
   * The address of the flow receiver.
   *
   */
  receiver: Scalars["Bytes"];
  /**
   * The address that is executing the flow update transaction.
   * This will be the zero address until the flowOperator feature is live.
   *
   */
  flowOperator: Scalars["Bytes"];
  /**
   * The flow rate per second.
   *
   */
  flowRate: Scalars["BigInt"];
  /**
   * The total (global/account level) flow rate of `sender` for `token` as of this event.
   *
   */
  totalSenderFlowRate: Scalars["BigInt"];
  /**
   * The total (global/account level) flow rate of `receiver` for `token` as of this event.
   *
   */
  totalReceiverFlowRate: Scalars["BigInt"];
  /**
   * The deposit amount put up for the creation of the flow.
   *
   */
  deposit: Scalars["BigInt"];
  /**
   * Arbitrary bytes (additional data) passed upon flow creation.
   *
   */
  userData: Scalars["Bytes"];
  /**
   * The previous flow rate, the absolute (positive) value.
   *
   */
  oldFlowRate: Scalars["BigInt"];
  /**
   * The "type" of the `FlowUpdated` event.
   * 0 = create
   * 1 = update
   * 2 = terminate
   *
   */
  type: Scalars["Int"];
  /**
   * The total amount streamed until the timestamp
   * for the Stream entity linked to this event.
   *
   */
  totalAmountStreamedUntilTimestamp: Scalars["BigInt"];
  /**
   * The stream entity which is being modified.
   *
   */
  stream: Stream;
};

export type FlowUpdatedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  sender?: InputMaybe<Scalars["Bytes"]>;
  sender_not?: InputMaybe<Scalars["Bytes"]>;
  sender_gt?: InputMaybe<Scalars["Bytes"]>;
  sender_lt?: InputMaybe<Scalars["Bytes"]>;
  sender_gte?: InputMaybe<Scalars["Bytes"]>;
  sender_lte?: InputMaybe<Scalars["Bytes"]>;
  sender_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  sender_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  sender_contains?: InputMaybe<Scalars["Bytes"]>;
  sender_not_contains?: InputMaybe<Scalars["Bytes"]>;
  receiver?: InputMaybe<Scalars["Bytes"]>;
  receiver_not?: InputMaybe<Scalars["Bytes"]>;
  receiver_gt?: InputMaybe<Scalars["Bytes"]>;
  receiver_lt?: InputMaybe<Scalars["Bytes"]>;
  receiver_gte?: InputMaybe<Scalars["Bytes"]>;
  receiver_lte?: InputMaybe<Scalars["Bytes"]>;
  receiver_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  receiver_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  receiver_contains?: InputMaybe<Scalars["Bytes"]>;
  receiver_not_contains?: InputMaybe<Scalars["Bytes"]>;
  flowOperator?: InputMaybe<Scalars["Bytes"]>;
  flowOperator_not?: InputMaybe<Scalars["Bytes"]>;
  flowOperator_gt?: InputMaybe<Scalars["Bytes"]>;
  flowOperator_lt?: InputMaybe<Scalars["Bytes"]>;
  flowOperator_gte?: InputMaybe<Scalars["Bytes"]>;
  flowOperator_lte?: InputMaybe<Scalars["Bytes"]>;
  flowOperator_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  flowOperator_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  flowOperator_contains?: InputMaybe<Scalars["Bytes"]>;
  flowOperator_not_contains?: InputMaybe<Scalars["Bytes"]>;
  flowRate?: InputMaybe<Scalars["BigInt"]>;
  flowRate_not?: InputMaybe<Scalars["BigInt"]>;
  flowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  flowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  flowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  flowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  flowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  flowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalSenderFlowRate?: InputMaybe<Scalars["BigInt"]>;
  totalSenderFlowRate_not?: InputMaybe<Scalars["BigInt"]>;
  totalSenderFlowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  totalSenderFlowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  totalSenderFlowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  totalSenderFlowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  totalSenderFlowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalSenderFlowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalReceiverFlowRate?: InputMaybe<Scalars["BigInt"]>;
  totalReceiverFlowRate_not?: InputMaybe<Scalars["BigInt"]>;
  totalReceiverFlowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  totalReceiverFlowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  totalReceiverFlowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  totalReceiverFlowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  totalReceiverFlowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalReceiverFlowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  deposit?: InputMaybe<Scalars["BigInt"]>;
  deposit_not?: InputMaybe<Scalars["BigInt"]>;
  deposit_gt?: InputMaybe<Scalars["BigInt"]>;
  deposit_lt?: InputMaybe<Scalars["BigInt"]>;
  deposit_gte?: InputMaybe<Scalars["BigInt"]>;
  deposit_lte?: InputMaybe<Scalars["BigInt"]>;
  deposit_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  deposit_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  userData?: InputMaybe<Scalars["Bytes"]>;
  userData_not?: InputMaybe<Scalars["Bytes"]>;
  userData_gt?: InputMaybe<Scalars["Bytes"]>;
  userData_lt?: InputMaybe<Scalars["Bytes"]>;
  userData_gte?: InputMaybe<Scalars["Bytes"]>;
  userData_lte?: InputMaybe<Scalars["Bytes"]>;
  userData_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_contains?: InputMaybe<Scalars["Bytes"]>;
  userData_not_contains?: InputMaybe<Scalars["Bytes"]>;
  oldFlowRate?: InputMaybe<Scalars["BigInt"]>;
  oldFlowRate_not?: InputMaybe<Scalars["BigInt"]>;
  oldFlowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  oldFlowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  oldFlowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  oldFlowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  oldFlowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  oldFlowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  type?: InputMaybe<Scalars["Int"]>;
  type_not?: InputMaybe<Scalars["Int"]>;
  type_gt?: InputMaybe<Scalars["Int"]>;
  type_lt?: InputMaybe<Scalars["Int"]>;
  type_gte?: InputMaybe<Scalars["Int"]>;
  type_lte?: InputMaybe<Scalars["Int"]>;
  type_in?: InputMaybe<Array<Scalars["Int"]>>;
  type_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalAmountStreamedUntilTimestamp?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedUntilTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedUntilTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedUntilTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedUntilTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedUntilTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedUntilTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountStreamedUntilTimestamp_not_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  stream?: InputMaybe<Scalars["String"]>;
  stream_not?: InputMaybe<Scalars["String"]>;
  stream_gt?: InputMaybe<Scalars["String"]>;
  stream_lt?: InputMaybe<Scalars["String"]>;
  stream_gte?: InputMaybe<Scalars["String"]>;
  stream_lte?: InputMaybe<Scalars["String"]>;
  stream_in?: InputMaybe<Array<Scalars["String"]>>;
  stream_not_in?: InputMaybe<Array<Scalars["String"]>>;
  stream_contains?: InputMaybe<Scalars["String"]>;
  stream_contains_nocase?: InputMaybe<Scalars["String"]>;
  stream_not_contains?: InputMaybe<Scalars["String"]>;
  stream_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  stream_starts_with?: InputMaybe<Scalars["String"]>;
  stream_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  stream_not_starts_with?: InputMaybe<Scalars["String"]>;
  stream_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  stream_ends_with?: InputMaybe<Scalars["String"]>;
  stream_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  stream_not_ends_with?: InputMaybe<Scalars["String"]>;
  stream_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  stream_?: InputMaybe<Stream_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<FlowUpdatedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<FlowUpdatedEvent_filter>>>;
};

export type FlowUpdatedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "sender"
  | "receiver"
  | "flowOperator"
  | "flowRate"
  | "totalSenderFlowRate"
  | "totalReceiverFlowRate"
  | "deposit"
  | "userData"
  | "oldFlowRate"
  | "type"
  | "totalAmountStreamedUntilTimestamp"
  | "stream"
  | "stream__id"
  | "stream__createdAtTimestamp"
  | "stream__createdAtBlockNumber"
  | "stream__updatedAtTimestamp"
  | "stream__updatedAtBlockNumber"
  | "stream__currentFlowRate"
  | "stream__deposit"
  | "stream__streamedUntilUpdatedAt"
  | "stream__userData";

export type GovernanceReplacedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `oldGovernance`
   * addresses[1] = `newGovernance`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  oldGovernance: Scalars["Bytes"];
  newGovernance: Scalars["Bytes"];
};

export type GovernanceReplacedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  oldGovernance?: InputMaybe<Scalars["Bytes"]>;
  oldGovernance_not?: InputMaybe<Scalars["Bytes"]>;
  oldGovernance_gt?: InputMaybe<Scalars["Bytes"]>;
  oldGovernance_lt?: InputMaybe<Scalars["Bytes"]>;
  oldGovernance_gte?: InputMaybe<Scalars["Bytes"]>;
  oldGovernance_lte?: InputMaybe<Scalars["Bytes"]>;
  oldGovernance_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  oldGovernance_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  oldGovernance_contains?: InputMaybe<Scalars["Bytes"]>;
  oldGovernance_not_contains?: InputMaybe<Scalars["Bytes"]>;
  newGovernance?: InputMaybe<Scalars["Bytes"]>;
  newGovernance_not?: InputMaybe<Scalars["Bytes"]>;
  newGovernance_gt?: InputMaybe<Scalars["Bytes"]>;
  newGovernance_lt?: InputMaybe<Scalars["Bytes"]>;
  newGovernance_gte?: InputMaybe<Scalars["Bytes"]>;
  newGovernance_lte?: InputMaybe<Scalars["Bytes"]>;
  newGovernance_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  newGovernance_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  newGovernance_contains?: InputMaybe<Scalars["Bytes"]>;
  newGovernance_not_contains?: InputMaybe<Scalars["Bytes"]>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<GovernanceReplacedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<GovernanceReplacedEvent_filter>>>;
};

export type GovernanceReplacedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "addresses"
  | "oldGovernance"
  | "newGovernance";

/**
 * Index: An Index higher order entity.
 *
 */
export type Index = {
  /**
   * ID composed of: publisherAddress-tokenAddress-indexId
   *
   */
  id: Scalars["ID"];
  createdAtTimestamp: Scalars["BigInt"];
  createdAtBlockNumber: Scalars["BigInt"];
  updatedAtTimestamp: Scalars["BigInt"];
  updatedAtBlockNumber: Scalars["BigInt"];
  /**
   * NOTE: indexId is not the same as the id of the `Index` entity.
   * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
   *
   */
  indexId: Scalars["BigInt"];
  indexValue: Scalars["BigInt"];
  /**
   * The number of subscriptions which have units allocated to them on the `Index`.
   *
   */
  totalSubscriptionsWithUnits: Scalars["Int"];
  /**
   * The number of units allocated by the `Index` that are pending.
   * This refers to the current (as of updatedAt) `totalUnitsPending`-not all that has ever been pending.
   *
   */
  totalUnitsPending: Scalars["BigInt"];
  /**
   * The number of units allocated by the `Index` that are approved.
   * This refers to the current (as of updatedAt) `totalUnitsApproved`-not all that has ever been approved.
   *
   */
  totalUnitsApproved: Scalars["BigInt"];
  /**
   * The sum of `totalUnitsPending` and `totalUnitsApproved`.
   *
   */
  totalUnits: Scalars["BigInt"];
  /**
   * The total amount distributed from this `Index`.
   *
   */
  totalAmountDistributedUntilUpdatedAt: Scalars["BigInt"];
  token: Token;
  publisher: Account;
  /**
   * The subscriptions of the index, it will include approved, unapproved
   * and deleted subscriptions.
   *
   */
  subscriptions: Array<IndexSubscription>;
  /**
   * IndexCreated event, there will only be one.
   *
   */
  indexCreatedEvent: IndexCreatedEvent;
  indexDistributionClaimedEvents: Array<IndexDistributionClaimedEvent>;
  indexUpdatedEvents: Array<IndexUpdatedEvent>;
  indexSubscribedEvents: Array<IndexSubscribedEvent>;
  indexUnitsUpdatedEvents: Array<IndexUnitsUpdatedEvent>;
  indexUnsubscribedEvents: Array<IndexUnsubscribedEvent>;
};

/**
 * Index: An Index higher order entity.
 *
 */
export type IndexsubscriptionsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<IndexSubscription_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<IndexSubscription_filter>;
};

/**
 * Index: An Index higher order entity.
 *
 */
export type IndexindexDistributionClaimedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<IndexDistributionClaimedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<IndexDistributionClaimedEvent_filter>;
};

/**
 * Index: An Index higher order entity.
 *
 */
export type IndexindexUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<IndexUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<IndexUpdatedEvent_filter>;
};

/**
 * Index: An Index higher order entity.
 *
 */
export type IndexindexSubscribedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<IndexSubscribedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<IndexSubscribedEvent_filter>;
};

/**
 * Index: An Index higher order entity.
 *
 */
export type IndexindexUnitsUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<IndexUnitsUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<IndexUnitsUpdatedEvent_filter>;
};

/**
 * Index: An Index higher order entity.
 *
 */
export type IndexindexUnsubscribedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<IndexUnsubscribedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<IndexUnsubscribedEvent_filter>;
};

export type IndexCreatedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `publisher`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
  /**
   * The creator of the `index`.
   *
   */
  publisher: Scalars["Bytes"];
  /**
   * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
   *
   */
  indexId: Scalars["BigInt"];
  userData: Scalars["Bytes"];
  index: Index;
};

export type IndexCreatedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  publisher?: InputMaybe<Scalars["Bytes"]>;
  publisher_not?: InputMaybe<Scalars["Bytes"]>;
  publisher_gt?: InputMaybe<Scalars["Bytes"]>;
  publisher_lt?: InputMaybe<Scalars["Bytes"]>;
  publisher_gte?: InputMaybe<Scalars["Bytes"]>;
  publisher_lte?: InputMaybe<Scalars["Bytes"]>;
  publisher_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  publisher_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  publisher_contains?: InputMaybe<Scalars["Bytes"]>;
  publisher_not_contains?: InputMaybe<Scalars["Bytes"]>;
  indexId?: InputMaybe<Scalars["BigInt"]>;
  indexId_not?: InputMaybe<Scalars["BigInt"]>;
  indexId_gt?: InputMaybe<Scalars["BigInt"]>;
  indexId_lt?: InputMaybe<Scalars["BigInt"]>;
  indexId_gte?: InputMaybe<Scalars["BigInt"]>;
  indexId_lte?: InputMaybe<Scalars["BigInt"]>;
  indexId_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  indexId_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  userData?: InputMaybe<Scalars["Bytes"]>;
  userData_not?: InputMaybe<Scalars["Bytes"]>;
  userData_gt?: InputMaybe<Scalars["Bytes"]>;
  userData_lt?: InputMaybe<Scalars["Bytes"]>;
  userData_gte?: InputMaybe<Scalars["Bytes"]>;
  userData_lte?: InputMaybe<Scalars["Bytes"]>;
  userData_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_contains?: InputMaybe<Scalars["Bytes"]>;
  userData_not_contains?: InputMaybe<Scalars["Bytes"]>;
  index?: InputMaybe<Scalars["String"]>;
  index_not?: InputMaybe<Scalars["String"]>;
  index_gt?: InputMaybe<Scalars["String"]>;
  index_lt?: InputMaybe<Scalars["String"]>;
  index_gte?: InputMaybe<Scalars["String"]>;
  index_lte?: InputMaybe<Scalars["String"]>;
  index_in?: InputMaybe<Array<Scalars["String"]>>;
  index_not_in?: InputMaybe<Array<Scalars["String"]>>;
  index_contains?: InputMaybe<Scalars["String"]>;
  index_contains_nocase?: InputMaybe<Scalars["String"]>;
  index_not_contains?: InputMaybe<Scalars["String"]>;
  index_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  index_starts_with?: InputMaybe<Scalars["String"]>;
  index_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  index_not_starts_with?: InputMaybe<Scalars["String"]>;
  index_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  index_ends_with?: InputMaybe<Scalars["String"]>;
  index_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  index_not_ends_with?: InputMaybe<Scalars["String"]>;
  index_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  index_?: InputMaybe<Index_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<IndexCreatedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<IndexCreatedEvent_filter>>>;
};

export type IndexCreatedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "publisher"
  | "indexId"
  | "userData"
  | "index"
  | "index__id"
  | "index__createdAtTimestamp"
  | "index__createdAtBlockNumber"
  | "index__updatedAtTimestamp"
  | "index__updatedAtBlockNumber"
  | "index__indexId"
  | "index__indexValue"
  | "index__totalSubscriptionsWithUnits"
  | "index__totalUnitsPending"
  | "index__totalUnitsApproved"
  | "index__totalUnits"
  | "index__totalAmountDistributedUntilUpdatedAt";

export type IndexDistributionClaimedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `publisher`
   * addresses[2] = `subscriber`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
  /**
   * The creator of the `index`.
   *
   */
  publisher: Scalars["Bytes"];
  /**
   * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
   *
   */
  indexId: Scalars["BigInt"];
  /**
   * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
   * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
   *
   */
  subscriber: Scalars["Bytes"];
  amount: Scalars["BigInt"];
  index: Index;
};

export type IndexDistributionClaimedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  publisher?: InputMaybe<Scalars["Bytes"]>;
  publisher_not?: InputMaybe<Scalars["Bytes"]>;
  publisher_gt?: InputMaybe<Scalars["Bytes"]>;
  publisher_lt?: InputMaybe<Scalars["Bytes"]>;
  publisher_gte?: InputMaybe<Scalars["Bytes"]>;
  publisher_lte?: InputMaybe<Scalars["Bytes"]>;
  publisher_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  publisher_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  publisher_contains?: InputMaybe<Scalars["Bytes"]>;
  publisher_not_contains?: InputMaybe<Scalars["Bytes"]>;
  indexId?: InputMaybe<Scalars["BigInt"]>;
  indexId_not?: InputMaybe<Scalars["BigInt"]>;
  indexId_gt?: InputMaybe<Scalars["BigInt"]>;
  indexId_lt?: InputMaybe<Scalars["BigInt"]>;
  indexId_gte?: InputMaybe<Scalars["BigInt"]>;
  indexId_lte?: InputMaybe<Scalars["BigInt"]>;
  indexId_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  indexId_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  subscriber?: InputMaybe<Scalars["Bytes"]>;
  subscriber_not?: InputMaybe<Scalars["Bytes"]>;
  subscriber_gt?: InputMaybe<Scalars["Bytes"]>;
  subscriber_lt?: InputMaybe<Scalars["Bytes"]>;
  subscriber_gte?: InputMaybe<Scalars["Bytes"]>;
  subscriber_lte?: InputMaybe<Scalars["Bytes"]>;
  subscriber_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  subscriber_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  subscriber_contains?: InputMaybe<Scalars["Bytes"]>;
  subscriber_not_contains?: InputMaybe<Scalars["Bytes"]>;
  amount?: InputMaybe<Scalars["BigInt"]>;
  amount_not?: InputMaybe<Scalars["BigInt"]>;
  amount_gt?: InputMaybe<Scalars["BigInt"]>;
  amount_lt?: InputMaybe<Scalars["BigInt"]>;
  amount_gte?: InputMaybe<Scalars["BigInt"]>;
  amount_lte?: InputMaybe<Scalars["BigInt"]>;
  amount_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  amount_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  index?: InputMaybe<Scalars["String"]>;
  index_not?: InputMaybe<Scalars["String"]>;
  index_gt?: InputMaybe<Scalars["String"]>;
  index_lt?: InputMaybe<Scalars["String"]>;
  index_gte?: InputMaybe<Scalars["String"]>;
  index_lte?: InputMaybe<Scalars["String"]>;
  index_in?: InputMaybe<Array<Scalars["String"]>>;
  index_not_in?: InputMaybe<Array<Scalars["String"]>>;
  index_contains?: InputMaybe<Scalars["String"]>;
  index_contains_nocase?: InputMaybe<Scalars["String"]>;
  index_not_contains?: InputMaybe<Scalars["String"]>;
  index_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  index_starts_with?: InputMaybe<Scalars["String"]>;
  index_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  index_not_starts_with?: InputMaybe<Scalars["String"]>;
  index_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  index_ends_with?: InputMaybe<Scalars["String"]>;
  index_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  index_not_ends_with?: InputMaybe<Scalars["String"]>;
  index_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  index_?: InputMaybe<Index_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<IndexDistributionClaimedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<IndexDistributionClaimedEvent_filter>>>;
};

export type IndexDistributionClaimedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "publisher"
  | "indexId"
  | "subscriber"
  | "amount"
  | "index"
  | "index__id"
  | "index__createdAtTimestamp"
  | "index__createdAtBlockNumber"
  | "index__updatedAtTimestamp"
  | "index__updatedAtBlockNumber"
  | "index__indexId"
  | "index__indexValue"
  | "index__totalSubscriptionsWithUnits"
  | "index__totalUnitsPending"
  | "index__totalUnitsApproved"
  | "index__totalUnits"
  | "index__totalAmountDistributedUntilUpdatedAt";

export type IndexSubscribedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `publisher`
   * addresses[2] = `subscriber`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
  /**
   * The creator of the `index`.
   *
   */
  publisher: Scalars["Bytes"];
  /**
   * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
   *
   */
  indexId: Scalars["BigInt"];
  /**
   * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
   * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
   *
   */
  subscriber: Scalars["Bytes"];
  userData: Scalars["Bytes"];
  index: Index;
};

export type IndexSubscribedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  publisher?: InputMaybe<Scalars["Bytes"]>;
  publisher_not?: InputMaybe<Scalars["Bytes"]>;
  publisher_gt?: InputMaybe<Scalars["Bytes"]>;
  publisher_lt?: InputMaybe<Scalars["Bytes"]>;
  publisher_gte?: InputMaybe<Scalars["Bytes"]>;
  publisher_lte?: InputMaybe<Scalars["Bytes"]>;
  publisher_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  publisher_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  publisher_contains?: InputMaybe<Scalars["Bytes"]>;
  publisher_not_contains?: InputMaybe<Scalars["Bytes"]>;
  indexId?: InputMaybe<Scalars["BigInt"]>;
  indexId_not?: InputMaybe<Scalars["BigInt"]>;
  indexId_gt?: InputMaybe<Scalars["BigInt"]>;
  indexId_lt?: InputMaybe<Scalars["BigInt"]>;
  indexId_gte?: InputMaybe<Scalars["BigInt"]>;
  indexId_lte?: InputMaybe<Scalars["BigInt"]>;
  indexId_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  indexId_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  subscriber?: InputMaybe<Scalars["Bytes"]>;
  subscriber_not?: InputMaybe<Scalars["Bytes"]>;
  subscriber_gt?: InputMaybe<Scalars["Bytes"]>;
  subscriber_lt?: InputMaybe<Scalars["Bytes"]>;
  subscriber_gte?: InputMaybe<Scalars["Bytes"]>;
  subscriber_lte?: InputMaybe<Scalars["Bytes"]>;
  subscriber_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  subscriber_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  subscriber_contains?: InputMaybe<Scalars["Bytes"]>;
  subscriber_not_contains?: InputMaybe<Scalars["Bytes"]>;
  userData?: InputMaybe<Scalars["Bytes"]>;
  userData_not?: InputMaybe<Scalars["Bytes"]>;
  userData_gt?: InputMaybe<Scalars["Bytes"]>;
  userData_lt?: InputMaybe<Scalars["Bytes"]>;
  userData_gte?: InputMaybe<Scalars["Bytes"]>;
  userData_lte?: InputMaybe<Scalars["Bytes"]>;
  userData_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_contains?: InputMaybe<Scalars["Bytes"]>;
  userData_not_contains?: InputMaybe<Scalars["Bytes"]>;
  index?: InputMaybe<Scalars["String"]>;
  index_not?: InputMaybe<Scalars["String"]>;
  index_gt?: InputMaybe<Scalars["String"]>;
  index_lt?: InputMaybe<Scalars["String"]>;
  index_gte?: InputMaybe<Scalars["String"]>;
  index_lte?: InputMaybe<Scalars["String"]>;
  index_in?: InputMaybe<Array<Scalars["String"]>>;
  index_not_in?: InputMaybe<Array<Scalars["String"]>>;
  index_contains?: InputMaybe<Scalars["String"]>;
  index_contains_nocase?: InputMaybe<Scalars["String"]>;
  index_not_contains?: InputMaybe<Scalars["String"]>;
  index_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  index_starts_with?: InputMaybe<Scalars["String"]>;
  index_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  index_not_starts_with?: InputMaybe<Scalars["String"]>;
  index_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  index_ends_with?: InputMaybe<Scalars["String"]>;
  index_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  index_not_ends_with?: InputMaybe<Scalars["String"]>;
  index_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  index_?: InputMaybe<Index_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<IndexSubscribedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<IndexSubscribedEvent_filter>>>;
};

export type IndexSubscribedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "publisher"
  | "indexId"
  | "subscriber"
  | "userData"
  | "index"
  | "index__id"
  | "index__createdAtTimestamp"
  | "index__createdAtBlockNumber"
  | "index__updatedAtTimestamp"
  | "index__updatedAtBlockNumber"
  | "index__indexId"
  | "index__indexValue"
  | "index__totalSubscriptionsWithUnits"
  | "index__totalUnitsPending"
  | "index__totalUnitsApproved"
  | "index__totalUnits"
  | "index__totalAmountDistributedUntilUpdatedAt";

/**
 * IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular `Index`.
 *
 */
export type IndexSubscription = {
  /**
   * ID composed of: subscriberAddress-publisherAddress-tokenAddress-IndexId
   *
   */
  id: Scalars["ID"];
  createdAtTimestamp: Scalars["BigInt"];
  createdAtBlockNumber: Scalars["BigInt"];
  updatedAtTimestamp: Scalars["BigInt"];
  updatedAtBlockNumber: Scalars["BigInt"];
  subscriber: Account;
  /**
   * A boolean indicating whether the `IndexSubscription` is approved.
   * Approved subscriptions don't require `subscriber` to claim tokens that are distributed from the publisher.
   *
   */
  approved: Scalars["Boolean"];
  /**
   * If `units` is `0`, it indicates that the subscription is "deleted" and `subscriber` is no longer subscribed to `index`.
   *
   */
  units: Scalars["BigInt"];
  /**
   * The total amount of tokens you've received via IDA until
   * `updatedAtTimestamp`/`updatedAtBlock`.
   *
   */
  totalAmountReceivedUntilUpdatedAt: Scalars["BigInt"];
  /**
   * The previous index value - used to calculate `totalAmountReceivedUntilUpdatedAt` field as of the `index.updatedAtTimestamp`.
   * The formula to get this value is:
   * `IndexSubscription.totalAmountReceivedUntilUpdatedAt + ((index.newIndexValue - indexSubscription.indexValueUntilUpdatedAt) * indexSubscription.units)`.
   *
   */
  indexValueUntilUpdatedAt: Scalars["BigInt"];
  index: Index;
  /**
   * IndexSubscription approved events on the subscription.
   *
   */
  subscriptionApprovedEvents: Array<SubscriptionApprovedEvent>;
  subscriptionDistributionClaimedEvents: Array<SubscriptionDistributionClaimedEvent>;
  subscriptionRevokedEvents: Array<SubscriptionRevokedEvent>;
  subscriptionUnitsUpdatedEvents: Array<SubscriptionUnitsUpdatedEvent>;
};

/**
 * IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular `Index`.
 *
 */
export type IndexSubscriptionsubscriptionApprovedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SubscriptionApprovedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SubscriptionApprovedEvent_filter>;
};

/**
 * IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular `Index`.
 *
 */
export type IndexSubscriptionsubscriptionDistributionClaimedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SubscriptionDistributionClaimedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SubscriptionDistributionClaimedEvent_filter>;
};

/**
 * IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular `Index`.
 *
 */
export type IndexSubscriptionsubscriptionRevokedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SubscriptionRevokedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SubscriptionRevokedEvent_filter>;
};

/**
 * IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular `Index`.
 *
 */
export type IndexSubscriptionsubscriptionUnitsUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SubscriptionUnitsUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SubscriptionUnitsUpdatedEvent_filter>;
};

export type IndexSubscription_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  createdAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  subscriber?: InputMaybe<Scalars["String"]>;
  subscriber_not?: InputMaybe<Scalars["String"]>;
  subscriber_gt?: InputMaybe<Scalars["String"]>;
  subscriber_lt?: InputMaybe<Scalars["String"]>;
  subscriber_gte?: InputMaybe<Scalars["String"]>;
  subscriber_lte?: InputMaybe<Scalars["String"]>;
  subscriber_in?: InputMaybe<Array<Scalars["String"]>>;
  subscriber_not_in?: InputMaybe<Array<Scalars["String"]>>;
  subscriber_contains?: InputMaybe<Scalars["String"]>;
  subscriber_contains_nocase?: InputMaybe<Scalars["String"]>;
  subscriber_not_contains?: InputMaybe<Scalars["String"]>;
  subscriber_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  subscriber_starts_with?: InputMaybe<Scalars["String"]>;
  subscriber_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  subscriber_not_starts_with?: InputMaybe<Scalars["String"]>;
  subscriber_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  subscriber_ends_with?: InputMaybe<Scalars["String"]>;
  subscriber_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  subscriber_not_ends_with?: InputMaybe<Scalars["String"]>;
  subscriber_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  subscriber_?: InputMaybe<Account_filter>;
  approved?: InputMaybe<Scalars["Boolean"]>;
  approved_not?: InputMaybe<Scalars["Boolean"]>;
  approved_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  approved_not_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  units?: InputMaybe<Scalars["BigInt"]>;
  units_not?: InputMaybe<Scalars["BigInt"]>;
  units_gt?: InputMaybe<Scalars["BigInt"]>;
  units_lt?: InputMaybe<Scalars["BigInt"]>;
  units_gte?: InputMaybe<Scalars["BigInt"]>;
  units_lte?: InputMaybe<Scalars["BigInt"]>;
  units_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  units_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountReceivedUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountReceivedUntilUpdatedAt_not?: InputMaybe<Scalars["BigInt"]>;
  totalAmountReceivedUntilUpdatedAt_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountReceivedUntilUpdatedAt_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountReceivedUntilUpdatedAt_gte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountReceivedUntilUpdatedAt_lte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountReceivedUntilUpdatedAt_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountReceivedUntilUpdatedAt_not_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  indexValueUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  indexValueUntilUpdatedAt_not?: InputMaybe<Scalars["BigInt"]>;
  indexValueUntilUpdatedAt_gt?: InputMaybe<Scalars["BigInt"]>;
  indexValueUntilUpdatedAt_lt?: InputMaybe<Scalars["BigInt"]>;
  indexValueUntilUpdatedAt_gte?: InputMaybe<Scalars["BigInt"]>;
  indexValueUntilUpdatedAt_lte?: InputMaybe<Scalars["BigInt"]>;
  indexValueUntilUpdatedAt_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  indexValueUntilUpdatedAt_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  index?: InputMaybe<Scalars["String"]>;
  index_not?: InputMaybe<Scalars["String"]>;
  index_gt?: InputMaybe<Scalars["String"]>;
  index_lt?: InputMaybe<Scalars["String"]>;
  index_gte?: InputMaybe<Scalars["String"]>;
  index_lte?: InputMaybe<Scalars["String"]>;
  index_in?: InputMaybe<Array<Scalars["String"]>>;
  index_not_in?: InputMaybe<Array<Scalars["String"]>>;
  index_contains?: InputMaybe<Scalars["String"]>;
  index_contains_nocase?: InputMaybe<Scalars["String"]>;
  index_not_contains?: InputMaybe<Scalars["String"]>;
  index_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  index_starts_with?: InputMaybe<Scalars["String"]>;
  index_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  index_not_starts_with?: InputMaybe<Scalars["String"]>;
  index_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  index_ends_with?: InputMaybe<Scalars["String"]>;
  index_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  index_not_ends_with?: InputMaybe<Scalars["String"]>;
  index_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  index_?: InputMaybe<Index_filter>;
  subscriptionApprovedEvents_?: InputMaybe<SubscriptionApprovedEvent_filter>;
  subscriptionDistributionClaimedEvents_?: InputMaybe<SubscriptionDistributionClaimedEvent_filter>;
  subscriptionRevokedEvents_?: InputMaybe<SubscriptionRevokedEvent_filter>;
  subscriptionUnitsUpdatedEvents_?: InputMaybe<SubscriptionUnitsUpdatedEvent_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<IndexSubscription_filter>>>;
  or?: InputMaybe<Array<InputMaybe<IndexSubscription_filter>>>;
};

export type IndexSubscription_orderBy =
  | "id"
  | "createdAtTimestamp"
  | "createdAtBlockNumber"
  | "updatedAtTimestamp"
  | "updatedAtBlockNumber"
  | "subscriber"
  | "subscriber__id"
  | "subscriber__createdAtTimestamp"
  | "subscriber__createdAtBlockNumber"
  | "subscriber__updatedAtTimestamp"
  | "subscriber__updatedAtBlockNumber"
  | "subscriber__isSuperApp"
  | "approved"
  | "units"
  | "totalAmountReceivedUntilUpdatedAt"
  | "indexValueUntilUpdatedAt"
  | "index"
  | "index__id"
  | "index__createdAtTimestamp"
  | "index__createdAtBlockNumber"
  | "index__updatedAtTimestamp"
  | "index__updatedAtBlockNumber"
  | "index__indexId"
  | "index__indexValue"
  | "index__totalSubscriptionsWithUnits"
  | "index__totalUnitsPending"
  | "index__totalUnitsApproved"
  | "index__totalUnits"
  | "index__totalAmountDistributedUntilUpdatedAt"
  | "subscriptionApprovedEvents"
  | "subscriptionDistributionClaimedEvents"
  | "subscriptionRevokedEvents"
  | "subscriptionUnitsUpdatedEvents";

export type IndexUnitsUpdatedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `publisher`
   * addresses[2] = `subscriber`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
  /**
   * The creator of the `index`.
   *
   */
  publisher: Scalars["Bytes"];
  /**
   * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
   *
   */
  indexId: Scalars["BigInt"];
  /**
   * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
   * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
   *
   */
  subscriber: Scalars["Bytes"];
  units: Scalars["BigInt"];
  userData: Scalars["Bytes"];
  oldUnits: Scalars["BigInt"];
  index: Index;
};

export type IndexUnitsUpdatedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  publisher?: InputMaybe<Scalars["Bytes"]>;
  publisher_not?: InputMaybe<Scalars["Bytes"]>;
  publisher_gt?: InputMaybe<Scalars["Bytes"]>;
  publisher_lt?: InputMaybe<Scalars["Bytes"]>;
  publisher_gte?: InputMaybe<Scalars["Bytes"]>;
  publisher_lte?: InputMaybe<Scalars["Bytes"]>;
  publisher_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  publisher_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  publisher_contains?: InputMaybe<Scalars["Bytes"]>;
  publisher_not_contains?: InputMaybe<Scalars["Bytes"]>;
  indexId?: InputMaybe<Scalars["BigInt"]>;
  indexId_not?: InputMaybe<Scalars["BigInt"]>;
  indexId_gt?: InputMaybe<Scalars["BigInt"]>;
  indexId_lt?: InputMaybe<Scalars["BigInt"]>;
  indexId_gte?: InputMaybe<Scalars["BigInt"]>;
  indexId_lte?: InputMaybe<Scalars["BigInt"]>;
  indexId_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  indexId_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  subscriber?: InputMaybe<Scalars["Bytes"]>;
  subscriber_not?: InputMaybe<Scalars["Bytes"]>;
  subscriber_gt?: InputMaybe<Scalars["Bytes"]>;
  subscriber_lt?: InputMaybe<Scalars["Bytes"]>;
  subscriber_gte?: InputMaybe<Scalars["Bytes"]>;
  subscriber_lte?: InputMaybe<Scalars["Bytes"]>;
  subscriber_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  subscriber_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  subscriber_contains?: InputMaybe<Scalars["Bytes"]>;
  subscriber_not_contains?: InputMaybe<Scalars["Bytes"]>;
  units?: InputMaybe<Scalars["BigInt"]>;
  units_not?: InputMaybe<Scalars["BigInt"]>;
  units_gt?: InputMaybe<Scalars["BigInt"]>;
  units_lt?: InputMaybe<Scalars["BigInt"]>;
  units_gte?: InputMaybe<Scalars["BigInt"]>;
  units_lte?: InputMaybe<Scalars["BigInt"]>;
  units_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  units_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  userData?: InputMaybe<Scalars["Bytes"]>;
  userData_not?: InputMaybe<Scalars["Bytes"]>;
  userData_gt?: InputMaybe<Scalars["Bytes"]>;
  userData_lt?: InputMaybe<Scalars["Bytes"]>;
  userData_gte?: InputMaybe<Scalars["Bytes"]>;
  userData_lte?: InputMaybe<Scalars["Bytes"]>;
  userData_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_contains?: InputMaybe<Scalars["Bytes"]>;
  userData_not_contains?: InputMaybe<Scalars["Bytes"]>;
  oldUnits?: InputMaybe<Scalars["BigInt"]>;
  oldUnits_not?: InputMaybe<Scalars["BigInt"]>;
  oldUnits_gt?: InputMaybe<Scalars["BigInt"]>;
  oldUnits_lt?: InputMaybe<Scalars["BigInt"]>;
  oldUnits_gte?: InputMaybe<Scalars["BigInt"]>;
  oldUnits_lte?: InputMaybe<Scalars["BigInt"]>;
  oldUnits_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  oldUnits_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  index?: InputMaybe<Scalars["String"]>;
  index_not?: InputMaybe<Scalars["String"]>;
  index_gt?: InputMaybe<Scalars["String"]>;
  index_lt?: InputMaybe<Scalars["String"]>;
  index_gte?: InputMaybe<Scalars["String"]>;
  index_lte?: InputMaybe<Scalars["String"]>;
  index_in?: InputMaybe<Array<Scalars["String"]>>;
  index_not_in?: InputMaybe<Array<Scalars["String"]>>;
  index_contains?: InputMaybe<Scalars["String"]>;
  index_contains_nocase?: InputMaybe<Scalars["String"]>;
  index_not_contains?: InputMaybe<Scalars["String"]>;
  index_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  index_starts_with?: InputMaybe<Scalars["String"]>;
  index_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  index_not_starts_with?: InputMaybe<Scalars["String"]>;
  index_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  index_ends_with?: InputMaybe<Scalars["String"]>;
  index_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  index_not_ends_with?: InputMaybe<Scalars["String"]>;
  index_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  index_?: InputMaybe<Index_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<IndexUnitsUpdatedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<IndexUnitsUpdatedEvent_filter>>>;
};

export type IndexUnitsUpdatedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "publisher"
  | "indexId"
  | "subscriber"
  | "units"
  | "userData"
  | "oldUnits"
  | "index"
  | "index__id"
  | "index__createdAtTimestamp"
  | "index__createdAtBlockNumber"
  | "index__updatedAtTimestamp"
  | "index__updatedAtBlockNumber"
  | "index__indexId"
  | "index__indexValue"
  | "index__totalSubscriptionsWithUnits"
  | "index__totalUnitsPending"
  | "index__totalUnitsApproved"
  | "index__totalUnits"
  | "index__totalAmountDistributedUntilUpdatedAt";

export type IndexUnsubscribedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `publisher`
   * addresses[2] = `subscriber`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
  /**
   * The creator of the `index`.
   *
   */
  publisher: Scalars["Bytes"];
  /**
   * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
   *
   */
  indexId: Scalars["BigInt"];
  /**
   * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
   * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
   *
   */
  subscriber: Scalars["Bytes"];
  userData: Scalars["Bytes"];
  index: Index;
};

export type IndexUnsubscribedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  publisher?: InputMaybe<Scalars["Bytes"]>;
  publisher_not?: InputMaybe<Scalars["Bytes"]>;
  publisher_gt?: InputMaybe<Scalars["Bytes"]>;
  publisher_lt?: InputMaybe<Scalars["Bytes"]>;
  publisher_gte?: InputMaybe<Scalars["Bytes"]>;
  publisher_lte?: InputMaybe<Scalars["Bytes"]>;
  publisher_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  publisher_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  publisher_contains?: InputMaybe<Scalars["Bytes"]>;
  publisher_not_contains?: InputMaybe<Scalars["Bytes"]>;
  indexId?: InputMaybe<Scalars["BigInt"]>;
  indexId_not?: InputMaybe<Scalars["BigInt"]>;
  indexId_gt?: InputMaybe<Scalars["BigInt"]>;
  indexId_lt?: InputMaybe<Scalars["BigInt"]>;
  indexId_gte?: InputMaybe<Scalars["BigInt"]>;
  indexId_lte?: InputMaybe<Scalars["BigInt"]>;
  indexId_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  indexId_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  subscriber?: InputMaybe<Scalars["Bytes"]>;
  subscriber_not?: InputMaybe<Scalars["Bytes"]>;
  subscriber_gt?: InputMaybe<Scalars["Bytes"]>;
  subscriber_lt?: InputMaybe<Scalars["Bytes"]>;
  subscriber_gte?: InputMaybe<Scalars["Bytes"]>;
  subscriber_lte?: InputMaybe<Scalars["Bytes"]>;
  subscriber_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  subscriber_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  subscriber_contains?: InputMaybe<Scalars["Bytes"]>;
  subscriber_not_contains?: InputMaybe<Scalars["Bytes"]>;
  userData?: InputMaybe<Scalars["Bytes"]>;
  userData_not?: InputMaybe<Scalars["Bytes"]>;
  userData_gt?: InputMaybe<Scalars["Bytes"]>;
  userData_lt?: InputMaybe<Scalars["Bytes"]>;
  userData_gte?: InputMaybe<Scalars["Bytes"]>;
  userData_lte?: InputMaybe<Scalars["Bytes"]>;
  userData_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_contains?: InputMaybe<Scalars["Bytes"]>;
  userData_not_contains?: InputMaybe<Scalars["Bytes"]>;
  index?: InputMaybe<Scalars["String"]>;
  index_not?: InputMaybe<Scalars["String"]>;
  index_gt?: InputMaybe<Scalars["String"]>;
  index_lt?: InputMaybe<Scalars["String"]>;
  index_gte?: InputMaybe<Scalars["String"]>;
  index_lte?: InputMaybe<Scalars["String"]>;
  index_in?: InputMaybe<Array<Scalars["String"]>>;
  index_not_in?: InputMaybe<Array<Scalars["String"]>>;
  index_contains?: InputMaybe<Scalars["String"]>;
  index_contains_nocase?: InputMaybe<Scalars["String"]>;
  index_not_contains?: InputMaybe<Scalars["String"]>;
  index_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  index_starts_with?: InputMaybe<Scalars["String"]>;
  index_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  index_not_starts_with?: InputMaybe<Scalars["String"]>;
  index_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  index_ends_with?: InputMaybe<Scalars["String"]>;
  index_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  index_not_ends_with?: InputMaybe<Scalars["String"]>;
  index_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  index_?: InputMaybe<Index_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<IndexUnsubscribedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<IndexUnsubscribedEvent_filter>>>;
};

export type IndexUnsubscribedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "publisher"
  | "indexId"
  | "subscriber"
  | "userData"
  | "index"
  | "index__id"
  | "index__createdAtTimestamp"
  | "index__createdAtBlockNumber"
  | "index__updatedAtTimestamp"
  | "index__updatedAtBlockNumber"
  | "index__indexId"
  | "index__indexValue"
  | "index__totalSubscriptionsWithUnits"
  | "index__totalUnitsPending"
  | "index__totalUnitsApproved"
  | "index__totalUnits"
  | "index__totalAmountDistributedUntilUpdatedAt";

export type IndexUpdatedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `publisher`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
  /**
   * The creator of the `index`.
   *
   */
  publisher: Scalars["Bytes"];
  /**
   * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
   *
   */
  indexId: Scalars["BigInt"];
  oldIndexValue: Scalars["BigInt"];
  newIndexValue: Scalars["BigInt"];
  totalUnitsPending: Scalars["BigInt"];
  totalUnitsApproved: Scalars["BigInt"];
  userData: Scalars["Bytes"];
  index: Index;
};

export type IndexUpdatedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  publisher?: InputMaybe<Scalars["Bytes"]>;
  publisher_not?: InputMaybe<Scalars["Bytes"]>;
  publisher_gt?: InputMaybe<Scalars["Bytes"]>;
  publisher_lt?: InputMaybe<Scalars["Bytes"]>;
  publisher_gte?: InputMaybe<Scalars["Bytes"]>;
  publisher_lte?: InputMaybe<Scalars["Bytes"]>;
  publisher_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  publisher_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  publisher_contains?: InputMaybe<Scalars["Bytes"]>;
  publisher_not_contains?: InputMaybe<Scalars["Bytes"]>;
  indexId?: InputMaybe<Scalars["BigInt"]>;
  indexId_not?: InputMaybe<Scalars["BigInt"]>;
  indexId_gt?: InputMaybe<Scalars["BigInt"]>;
  indexId_lt?: InputMaybe<Scalars["BigInt"]>;
  indexId_gte?: InputMaybe<Scalars["BigInt"]>;
  indexId_lte?: InputMaybe<Scalars["BigInt"]>;
  indexId_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  indexId_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  oldIndexValue?: InputMaybe<Scalars["BigInt"]>;
  oldIndexValue_not?: InputMaybe<Scalars["BigInt"]>;
  oldIndexValue_gt?: InputMaybe<Scalars["BigInt"]>;
  oldIndexValue_lt?: InputMaybe<Scalars["BigInt"]>;
  oldIndexValue_gte?: InputMaybe<Scalars["BigInt"]>;
  oldIndexValue_lte?: InputMaybe<Scalars["BigInt"]>;
  oldIndexValue_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  oldIndexValue_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  newIndexValue?: InputMaybe<Scalars["BigInt"]>;
  newIndexValue_not?: InputMaybe<Scalars["BigInt"]>;
  newIndexValue_gt?: InputMaybe<Scalars["BigInt"]>;
  newIndexValue_lt?: InputMaybe<Scalars["BigInt"]>;
  newIndexValue_gte?: InputMaybe<Scalars["BigInt"]>;
  newIndexValue_lte?: InputMaybe<Scalars["BigInt"]>;
  newIndexValue_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  newIndexValue_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalUnitsPending?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsPending_not?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsPending_gt?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsPending_lt?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsPending_gte?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsPending_lte?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsPending_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalUnitsPending_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalUnitsApproved?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsApproved_not?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsApproved_gt?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsApproved_lt?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsApproved_gte?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsApproved_lte?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsApproved_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalUnitsApproved_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  userData?: InputMaybe<Scalars["Bytes"]>;
  userData_not?: InputMaybe<Scalars["Bytes"]>;
  userData_gt?: InputMaybe<Scalars["Bytes"]>;
  userData_lt?: InputMaybe<Scalars["Bytes"]>;
  userData_gte?: InputMaybe<Scalars["Bytes"]>;
  userData_lte?: InputMaybe<Scalars["Bytes"]>;
  userData_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_contains?: InputMaybe<Scalars["Bytes"]>;
  userData_not_contains?: InputMaybe<Scalars["Bytes"]>;
  index?: InputMaybe<Scalars["String"]>;
  index_not?: InputMaybe<Scalars["String"]>;
  index_gt?: InputMaybe<Scalars["String"]>;
  index_lt?: InputMaybe<Scalars["String"]>;
  index_gte?: InputMaybe<Scalars["String"]>;
  index_lte?: InputMaybe<Scalars["String"]>;
  index_in?: InputMaybe<Array<Scalars["String"]>>;
  index_not_in?: InputMaybe<Array<Scalars["String"]>>;
  index_contains?: InputMaybe<Scalars["String"]>;
  index_contains_nocase?: InputMaybe<Scalars["String"]>;
  index_not_contains?: InputMaybe<Scalars["String"]>;
  index_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  index_starts_with?: InputMaybe<Scalars["String"]>;
  index_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  index_not_starts_with?: InputMaybe<Scalars["String"]>;
  index_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  index_ends_with?: InputMaybe<Scalars["String"]>;
  index_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  index_not_ends_with?: InputMaybe<Scalars["String"]>;
  index_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  index_?: InputMaybe<Index_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<IndexUpdatedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<IndexUpdatedEvent_filter>>>;
};

export type IndexUpdatedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "publisher"
  | "indexId"
  | "oldIndexValue"
  | "newIndexValue"
  | "totalUnitsPending"
  | "totalUnitsApproved"
  | "userData"
  | "index"
  | "index__id"
  | "index__createdAtTimestamp"
  | "index__createdAtBlockNumber"
  | "index__updatedAtTimestamp"
  | "index__updatedAtBlockNumber"
  | "index__indexId"
  | "index__indexValue"
  | "index__totalSubscriptionsWithUnits"
  | "index__totalUnitsPending"
  | "index__totalUnitsApproved"
  | "index__totalUnits"
  | "index__totalAmountDistributedUntilUpdatedAt";

export type Index_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  createdAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  indexId?: InputMaybe<Scalars["BigInt"]>;
  indexId_not?: InputMaybe<Scalars["BigInt"]>;
  indexId_gt?: InputMaybe<Scalars["BigInt"]>;
  indexId_lt?: InputMaybe<Scalars["BigInt"]>;
  indexId_gte?: InputMaybe<Scalars["BigInt"]>;
  indexId_lte?: InputMaybe<Scalars["BigInt"]>;
  indexId_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  indexId_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  indexValue?: InputMaybe<Scalars["BigInt"]>;
  indexValue_not?: InputMaybe<Scalars["BigInt"]>;
  indexValue_gt?: InputMaybe<Scalars["BigInt"]>;
  indexValue_lt?: InputMaybe<Scalars["BigInt"]>;
  indexValue_gte?: InputMaybe<Scalars["BigInt"]>;
  indexValue_lte?: InputMaybe<Scalars["BigInt"]>;
  indexValue_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  indexValue_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalSubscriptionsWithUnits?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_not?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_gt?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_lt?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_gte?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_lte?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalSubscriptionsWithUnits_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalUnitsPending?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsPending_not?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsPending_gt?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsPending_lt?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsPending_gte?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsPending_lte?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsPending_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalUnitsPending_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalUnitsApproved?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsApproved_not?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsApproved_gt?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsApproved_lt?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsApproved_gte?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsApproved_lte?: InputMaybe<Scalars["BigInt"]>;
  totalUnitsApproved_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalUnitsApproved_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalUnits?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_not?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_gt?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_lt?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_gte?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_lte?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalUnits_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountDistributedUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_not?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_gte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_lte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalAmountDistributedUntilUpdatedAt_not_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  token?: InputMaybe<Scalars["String"]>;
  token_not?: InputMaybe<Scalars["String"]>;
  token_gt?: InputMaybe<Scalars["String"]>;
  token_lt?: InputMaybe<Scalars["String"]>;
  token_gte?: InputMaybe<Scalars["String"]>;
  token_lte?: InputMaybe<Scalars["String"]>;
  token_in?: InputMaybe<Array<Scalars["String"]>>;
  token_not_in?: InputMaybe<Array<Scalars["String"]>>;
  token_contains?: InputMaybe<Scalars["String"]>;
  token_contains_nocase?: InputMaybe<Scalars["String"]>;
  token_not_contains?: InputMaybe<Scalars["String"]>;
  token_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  token_starts_with?: InputMaybe<Scalars["String"]>;
  token_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  token_not_starts_with?: InputMaybe<Scalars["String"]>;
  token_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  token_ends_with?: InputMaybe<Scalars["String"]>;
  token_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  token_not_ends_with?: InputMaybe<Scalars["String"]>;
  token_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  token_?: InputMaybe<Token_filter>;
  publisher?: InputMaybe<Scalars["String"]>;
  publisher_not?: InputMaybe<Scalars["String"]>;
  publisher_gt?: InputMaybe<Scalars["String"]>;
  publisher_lt?: InputMaybe<Scalars["String"]>;
  publisher_gte?: InputMaybe<Scalars["String"]>;
  publisher_lte?: InputMaybe<Scalars["String"]>;
  publisher_in?: InputMaybe<Array<Scalars["String"]>>;
  publisher_not_in?: InputMaybe<Array<Scalars["String"]>>;
  publisher_contains?: InputMaybe<Scalars["String"]>;
  publisher_contains_nocase?: InputMaybe<Scalars["String"]>;
  publisher_not_contains?: InputMaybe<Scalars["String"]>;
  publisher_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  publisher_starts_with?: InputMaybe<Scalars["String"]>;
  publisher_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  publisher_not_starts_with?: InputMaybe<Scalars["String"]>;
  publisher_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  publisher_ends_with?: InputMaybe<Scalars["String"]>;
  publisher_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  publisher_not_ends_with?: InputMaybe<Scalars["String"]>;
  publisher_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  publisher_?: InputMaybe<Account_filter>;
  subscriptions_?: InputMaybe<IndexSubscription_filter>;
  indexCreatedEvent?: InputMaybe<Scalars["String"]>;
  indexCreatedEvent_not?: InputMaybe<Scalars["String"]>;
  indexCreatedEvent_gt?: InputMaybe<Scalars["String"]>;
  indexCreatedEvent_lt?: InputMaybe<Scalars["String"]>;
  indexCreatedEvent_gte?: InputMaybe<Scalars["String"]>;
  indexCreatedEvent_lte?: InputMaybe<Scalars["String"]>;
  indexCreatedEvent_in?: InputMaybe<Array<Scalars["String"]>>;
  indexCreatedEvent_not_in?: InputMaybe<Array<Scalars["String"]>>;
  indexCreatedEvent_contains?: InputMaybe<Scalars["String"]>;
  indexCreatedEvent_contains_nocase?: InputMaybe<Scalars["String"]>;
  indexCreatedEvent_not_contains?: InputMaybe<Scalars["String"]>;
  indexCreatedEvent_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  indexCreatedEvent_starts_with?: InputMaybe<Scalars["String"]>;
  indexCreatedEvent_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  indexCreatedEvent_not_starts_with?: InputMaybe<Scalars["String"]>;
  indexCreatedEvent_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  indexCreatedEvent_ends_with?: InputMaybe<Scalars["String"]>;
  indexCreatedEvent_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  indexCreatedEvent_not_ends_with?: InputMaybe<Scalars["String"]>;
  indexCreatedEvent_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  indexCreatedEvent_?: InputMaybe<IndexCreatedEvent_filter>;
  indexDistributionClaimedEvents_?: InputMaybe<IndexDistributionClaimedEvent_filter>;
  indexUpdatedEvents_?: InputMaybe<IndexUpdatedEvent_filter>;
  indexSubscribedEvents_?: InputMaybe<IndexSubscribedEvent_filter>;
  indexUnitsUpdatedEvents_?: InputMaybe<IndexUnitsUpdatedEvent_filter>;
  indexUnsubscribedEvents_?: InputMaybe<IndexUnsubscribedEvent_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<Index_filter>>>;
  or?: InputMaybe<Array<InputMaybe<Index_filter>>>;
};

export type Index_orderBy =
  | "id"
  | "createdAtTimestamp"
  | "createdAtBlockNumber"
  | "updatedAtTimestamp"
  | "updatedAtBlockNumber"
  | "indexId"
  | "indexValue"
  | "totalSubscriptionsWithUnits"
  | "totalUnitsPending"
  | "totalUnitsApproved"
  | "totalUnits"
  | "totalAmountDistributedUntilUpdatedAt"
  | "token"
  | "token__id"
  | "token__createdAtTimestamp"
  | "token__createdAtBlockNumber"
  | "token__decimals"
  | "token__name"
  | "token__symbol"
  | "token__isSuperToken"
  | "token__isNativeAssetSuperToken"
  | "token__isListed"
  | "token__underlyingAddress"
  | "publisher"
  | "publisher__id"
  | "publisher__createdAtTimestamp"
  | "publisher__createdAtBlockNumber"
  | "publisher__updatedAtTimestamp"
  | "publisher__updatedAtBlockNumber"
  | "publisher__isSuperApp"
  | "subscriptions"
  | "indexCreatedEvent"
  | "indexCreatedEvent__id"
  | "indexCreatedEvent__transactionHash"
  | "indexCreatedEvent__gasPrice"
  | "indexCreatedEvent__gasUsed"
  | "indexCreatedEvent__timestamp"
  | "indexCreatedEvent__name"
  | "indexCreatedEvent__blockNumber"
  | "indexCreatedEvent__logIndex"
  | "indexCreatedEvent__order"
  | "indexCreatedEvent__token"
  | "indexCreatedEvent__publisher"
  | "indexCreatedEvent__indexId"
  | "indexCreatedEvent__userData"
  | "indexDistributionClaimedEvents"
  | "indexUpdatedEvents"
  | "indexSubscribedEvents"
  | "indexUnitsUpdatedEvents"
  | "indexUnsubscribedEvents";

export type InstantDistributionUpdatedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `pool`
   * addresses[2] = `poolDistributor`
   * addresses[3] = `operator`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
  operator: Scalars["Bytes"];
  requestedAmount: Scalars["BigInt"];
  actualAmount: Scalars["BigInt"];
  totalUnits: Scalars["BigInt"];
  userData: Scalars["Bytes"];
  pool: Pool;
  poolDistributor: PoolDistributor;
};

export type InstantDistributionUpdatedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  operator?: InputMaybe<Scalars["Bytes"]>;
  operator_not?: InputMaybe<Scalars["Bytes"]>;
  operator_gt?: InputMaybe<Scalars["Bytes"]>;
  operator_lt?: InputMaybe<Scalars["Bytes"]>;
  operator_gte?: InputMaybe<Scalars["Bytes"]>;
  operator_lte?: InputMaybe<Scalars["Bytes"]>;
  operator_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  operator_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  operator_contains?: InputMaybe<Scalars["Bytes"]>;
  operator_not_contains?: InputMaybe<Scalars["Bytes"]>;
  requestedAmount?: InputMaybe<Scalars["BigInt"]>;
  requestedAmount_not?: InputMaybe<Scalars["BigInt"]>;
  requestedAmount_gt?: InputMaybe<Scalars["BigInt"]>;
  requestedAmount_lt?: InputMaybe<Scalars["BigInt"]>;
  requestedAmount_gte?: InputMaybe<Scalars["BigInt"]>;
  requestedAmount_lte?: InputMaybe<Scalars["BigInt"]>;
  requestedAmount_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  requestedAmount_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  actualAmount?: InputMaybe<Scalars["BigInt"]>;
  actualAmount_not?: InputMaybe<Scalars["BigInt"]>;
  actualAmount_gt?: InputMaybe<Scalars["BigInt"]>;
  actualAmount_lt?: InputMaybe<Scalars["BigInt"]>;
  actualAmount_gte?: InputMaybe<Scalars["BigInt"]>;
  actualAmount_lte?: InputMaybe<Scalars["BigInt"]>;
  actualAmount_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  actualAmount_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalUnits?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_not?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_gt?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_lt?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_gte?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_lte?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalUnits_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  userData?: InputMaybe<Scalars["Bytes"]>;
  userData_not?: InputMaybe<Scalars["Bytes"]>;
  userData_gt?: InputMaybe<Scalars["Bytes"]>;
  userData_lt?: InputMaybe<Scalars["Bytes"]>;
  userData_gte?: InputMaybe<Scalars["Bytes"]>;
  userData_lte?: InputMaybe<Scalars["Bytes"]>;
  userData_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_contains?: InputMaybe<Scalars["Bytes"]>;
  userData_not_contains?: InputMaybe<Scalars["Bytes"]>;
  pool?: InputMaybe<Scalars["String"]>;
  pool_not?: InputMaybe<Scalars["String"]>;
  pool_gt?: InputMaybe<Scalars["String"]>;
  pool_lt?: InputMaybe<Scalars["String"]>;
  pool_gte?: InputMaybe<Scalars["String"]>;
  pool_lte?: InputMaybe<Scalars["String"]>;
  pool_in?: InputMaybe<Array<Scalars["String"]>>;
  pool_not_in?: InputMaybe<Array<Scalars["String"]>>;
  pool_contains?: InputMaybe<Scalars["String"]>;
  pool_contains_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_contains?: InputMaybe<Scalars["String"]>;
  pool_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  pool_starts_with?: InputMaybe<Scalars["String"]>;
  pool_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_starts_with?: InputMaybe<Scalars["String"]>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_ends_with?: InputMaybe<Scalars["String"]>;
  pool_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_ends_with?: InputMaybe<Scalars["String"]>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_?: InputMaybe<Pool_filter>;
  poolDistributor?: InputMaybe<Scalars["String"]>;
  poolDistributor_not?: InputMaybe<Scalars["String"]>;
  poolDistributor_gt?: InputMaybe<Scalars["String"]>;
  poolDistributor_lt?: InputMaybe<Scalars["String"]>;
  poolDistributor_gte?: InputMaybe<Scalars["String"]>;
  poolDistributor_lte?: InputMaybe<Scalars["String"]>;
  poolDistributor_in?: InputMaybe<Array<Scalars["String"]>>;
  poolDistributor_not_in?: InputMaybe<Array<Scalars["String"]>>;
  poolDistributor_contains?: InputMaybe<Scalars["String"]>;
  poolDistributor_contains_nocase?: InputMaybe<Scalars["String"]>;
  poolDistributor_not_contains?: InputMaybe<Scalars["String"]>;
  poolDistributor_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  poolDistributor_starts_with?: InputMaybe<Scalars["String"]>;
  poolDistributor_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  poolDistributor_not_starts_with?: InputMaybe<Scalars["String"]>;
  poolDistributor_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  poolDistributor_ends_with?: InputMaybe<Scalars["String"]>;
  poolDistributor_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  poolDistributor_not_ends_with?: InputMaybe<Scalars["String"]>;
  poolDistributor_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  poolDistributor_?: InputMaybe<PoolDistributor_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<InstantDistributionUpdatedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<InstantDistributionUpdatedEvent_filter>>>;
};

export type InstantDistributionUpdatedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "operator"
  | "requestedAmount"
  | "actualAmount"
  | "totalUnits"
  | "userData"
  | "pool"
  | "pool__id"
  | "pool__createdAtTimestamp"
  | "pool__createdAtBlockNumber"
  | "pool__updatedAtTimestamp"
  | "pool__updatedAtBlockNumber"
  | "pool__totalUnits"
  | "pool__totalConnectedUnits"
  | "pool__totalDisconnectedUnits"
  | "pool__totalAmountInstantlyDistributedUntilUpdatedAt"
  | "pool__totalAmountFlowedDistributedUntilUpdatedAt"
  | "pool__totalAmountDistributedUntilUpdatedAt"
  | "pool__totalFlowAdjustmentAmountDistributedUntilUpdatedAt"
  | "pool__perUnitSettledValue"
  | "pool__perUnitFlowRate"
  | "pool__totalMembers"
  | "pool__totalConnectedMembers"
  | "pool__totalDisconnectedMembers"
  | "pool__adjustmentFlowRate"
  | "pool__flowRate"
  | "pool__totalBuffer"
  | "poolDistributor"
  | "poolDistributor__id"
  | "poolDistributor__createdAtTimestamp"
  | "poolDistributor__createdAtBlockNumber"
  | "poolDistributor__updatedAtTimestamp"
  | "poolDistributor__updatedAtBlockNumber"
  | "poolDistributor__totalAmountInstantlyDistributedUntilUpdatedAt"
  | "poolDistributor__totalAmountFlowedDistributedUntilUpdatedAt"
  | "poolDistributor__totalAmountDistributedUntilUpdatedAt"
  | "poolDistributor__totalBuffer"
  | "poolDistributor__flowRate";

export type JailEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `app`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  app: Scalars["Bytes"];
  reason: Scalars["BigInt"];
};

export type JailEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  app?: InputMaybe<Scalars["Bytes"]>;
  app_not?: InputMaybe<Scalars["Bytes"]>;
  app_gt?: InputMaybe<Scalars["Bytes"]>;
  app_lt?: InputMaybe<Scalars["Bytes"]>;
  app_gte?: InputMaybe<Scalars["Bytes"]>;
  app_lte?: InputMaybe<Scalars["Bytes"]>;
  app_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  app_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  app_contains?: InputMaybe<Scalars["Bytes"]>;
  app_not_contains?: InputMaybe<Scalars["Bytes"]>;
  reason?: InputMaybe<Scalars["BigInt"]>;
  reason_not?: InputMaybe<Scalars["BigInt"]>;
  reason_gt?: InputMaybe<Scalars["BigInt"]>;
  reason_lt?: InputMaybe<Scalars["BigInt"]>;
  reason_gte?: InputMaybe<Scalars["BigInt"]>;
  reason_lte?: InputMaybe<Scalars["BigInt"]>;
  reason_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  reason_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<JailEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<JailEvent_filter>>>;
};

export type JailEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "app"
  | "reason";

export type MemberUnitsUpdatedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `pool`
   * addresses[2] = `member`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
  oldUnits: Scalars["BigInt"];
  units: Scalars["BigInt"];
  totalUnits: Scalars["BigInt"];
  pool: Pool;
  poolMember: PoolMember;
};

export type MemberUnitsUpdatedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  oldUnits?: InputMaybe<Scalars["BigInt"]>;
  oldUnits_not?: InputMaybe<Scalars["BigInt"]>;
  oldUnits_gt?: InputMaybe<Scalars["BigInt"]>;
  oldUnits_lt?: InputMaybe<Scalars["BigInt"]>;
  oldUnits_gte?: InputMaybe<Scalars["BigInt"]>;
  oldUnits_lte?: InputMaybe<Scalars["BigInt"]>;
  oldUnits_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  oldUnits_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  units?: InputMaybe<Scalars["BigInt"]>;
  units_not?: InputMaybe<Scalars["BigInt"]>;
  units_gt?: InputMaybe<Scalars["BigInt"]>;
  units_lt?: InputMaybe<Scalars["BigInt"]>;
  units_gte?: InputMaybe<Scalars["BigInt"]>;
  units_lte?: InputMaybe<Scalars["BigInt"]>;
  units_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  units_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalUnits?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_not?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_gt?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_lt?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_gte?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_lte?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalUnits_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  pool?: InputMaybe<Scalars["String"]>;
  pool_not?: InputMaybe<Scalars["String"]>;
  pool_gt?: InputMaybe<Scalars["String"]>;
  pool_lt?: InputMaybe<Scalars["String"]>;
  pool_gte?: InputMaybe<Scalars["String"]>;
  pool_lte?: InputMaybe<Scalars["String"]>;
  pool_in?: InputMaybe<Array<Scalars["String"]>>;
  pool_not_in?: InputMaybe<Array<Scalars["String"]>>;
  pool_contains?: InputMaybe<Scalars["String"]>;
  pool_contains_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_contains?: InputMaybe<Scalars["String"]>;
  pool_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  pool_starts_with?: InputMaybe<Scalars["String"]>;
  pool_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_starts_with?: InputMaybe<Scalars["String"]>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_ends_with?: InputMaybe<Scalars["String"]>;
  pool_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_ends_with?: InputMaybe<Scalars["String"]>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_?: InputMaybe<Pool_filter>;
  poolMember?: InputMaybe<Scalars["String"]>;
  poolMember_not?: InputMaybe<Scalars["String"]>;
  poolMember_gt?: InputMaybe<Scalars["String"]>;
  poolMember_lt?: InputMaybe<Scalars["String"]>;
  poolMember_gte?: InputMaybe<Scalars["String"]>;
  poolMember_lte?: InputMaybe<Scalars["String"]>;
  poolMember_in?: InputMaybe<Array<Scalars["String"]>>;
  poolMember_not_in?: InputMaybe<Array<Scalars["String"]>>;
  poolMember_contains?: InputMaybe<Scalars["String"]>;
  poolMember_contains_nocase?: InputMaybe<Scalars["String"]>;
  poolMember_not_contains?: InputMaybe<Scalars["String"]>;
  poolMember_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  poolMember_starts_with?: InputMaybe<Scalars["String"]>;
  poolMember_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  poolMember_not_starts_with?: InputMaybe<Scalars["String"]>;
  poolMember_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  poolMember_ends_with?: InputMaybe<Scalars["String"]>;
  poolMember_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  poolMember_not_ends_with?: InputMaybe<Scalars["String"]>;
  poolMember_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  poolMember_?: InputMaybe<PoolMember_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<MemberUnitsUpdatedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<MemberUnitsUpdatedEvent_filter>>>;
};

export type MemberUnitsUpdatedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "oldUnits"
  | "units"
  | "totalUnits"
  | "pool"
  | "pool__id"
  | "pool__createdAtTimestamp"
  | "pool__createdAtBlockNumber"
  | "pool__updatedAtTimestamp"
  | "pool__updatedAtBlockNumber"
  | "pool__totalUnits"
  | "pool__totalConnectedUnits"
  | "pool__totalDisconnectedUnits"
  | "pool__totalAmountInstantlyDistributedUntilUpdatedAt"
  | "pool__totalAmountFlowedDistributedUntilUpdatedAt"
  | "pool__totalAmountDistributedUntilUpdatedAt"
  | "pool__totalFlowAdjustmentAmountDistributedUntilUpdatedAt"
  | "pool__perUnitSettledValue"
  | "pool__perUnitFlowRate"
  | "pool__totalMembers"
  | "pool__totalConnectedMembers"
  | "pool__totalDisconnectedMembers"
  | "pool__adjustmentFlowRate"
  | "pool__flowRate"
  | "pool__totalBuffer"
  | "poolMember"
  | "poolMember__id"
  | "poolMember__createdAtTimestamp"
  | "poolMember__createdAtBlockNumber"
  | "poolMember__updatedAtTimestamp"
  | "poolMember__updatedAtBlockNumber"
  | "poolMember__units"
  | "poolMember__isConnected"
  | "poolMember__totalAmountClaimed"
  | "poolMember__poolTotalAmountDistributedUntilUpdatedAt"
  | "poolMember__totalAmountReceivedUntilUpdatedAt"
  | "poolMember__syncedPerUnitSettledValue"
  | "poolMember__syncedPerUnitFlowRate";

export type MetadataUpdateEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Empty addresses array.
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  /**
   * The id of the NFT that will be granted allowance to transfer.
   * The id is: uint256(keccak256(abi.encode(block.chainid, superToken, sender, receiver)))
   *
   */
  tokenId: Scalars["BigInt"];
};

export type MetadataUpdateEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  tokenId?: InputMaybe<Scalars["BigInt"]>;
  tokenId_not?: InputMaybe<Scalars["BigInt"]>;
  tokenId_gt?: InputMaybe<Scalars["BigInt"]>;
  tokenId_lt?: InputMaybe<Scalars["BigInt"]>;
  tokenId_gte?: InputMaybe<Scalars["BigInt"]>;
  tokenId_lte?: InputMaybe<Scalars["BigInt"]>;
  tokenId_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  tokenId_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<MetadataUpdateEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<MetadataUpdateEvent_filter>>>;
};

export type MetadataUpdateEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "tokenId";

export type MintedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `operator`
   * addresses[2] = `to`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  operator: Scalars["Bytes"];
  to: Scalars["Bytes"];
  amount: Scalars["BigInt"];
  data: Scalars["Bytes"];
  token: Scalars["Bytes"];
  operatorData: Scalars["Bytes"];
};

export type MintedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  operator?: InputMaybe<Scalars["Bytes"]>;
  operator_not?: InputMaybe<Scalars["Bytes"]>;
  operator_gt?: InputMaybe<Scalars["Bytes"]>;
  operator_lt?: InputMaybe<Scalars["Bytes"]>;
  operator_gte?: InputMaybe<Scalars["Bytes"]>;
  operator_lte?: InputMaybe<Scalars["Bytes"]>;
  operator_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  operator_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  operator_contains?: InputMaybe<Scalars["Bytes"]>;
  operator_not_contains?: InputMaybe<Scalars["Bytes"]>;
  to?: InputMaybe<Scalars["Bytes"]>;
  to_not?: InputMaybe<Scalars["Bytes"]>;
  to_gt?: InputMaybe<Scalars["Bytes"]>;
  to_lt?: InputMaybe<Scalars["Bytes"]>;
  to_gte?: InputMaybe<Scalars["Bytes"]>;
  to_lte?: InputMaybe<Scalars["Bytes"]>;
  to_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  to_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  to_contains?: InputMaybe<Scalars["Bytes"]>;
  to_not_contains?: InputMaybe<Scalars["Bytes"]>;
  amount?: InputMaybe<Scalars["BigInt"]>;
  amount_not?: InputMaybe<Scalars["BigInt"]>;
  amount_gt?: InputMaybe<Scalars["BigInt"]>;
  amount_lt?: InputMaybe<Scalars["BigInt"]>;
  amount_gte?: InputMaybe<Scalars["BigInt"]>;
  amount_lte?: InputMaybe<Scalars["BigInt"]>;
  amount_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  amount_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  data?: InputMaybe<Scalars["Bytes"]>;
  data_not?: InputMaybe<Scalars["Bytes"]>;
  data_gt?: InputMaybe<Scalars["Bytes"]>;
  data_lt?: InputMaybe<Scalars["Bytes"]>;
  data_gte?: InputMaybe<Scalars["Bytes"]>;
  data_lte?: InputMaybe<Scalars["Bytes"]>;
  data_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  data_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  data_contains?: InputMaybe<Scalars["Bytes"]>;
  data_not_contains?: InputMaybe<Scalars["Bytes"]>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  operatorData?: InputMaybe<Scalars["Bytes"]>;
  operatorData_not?: InputMaybe<Scalars["Bytes"]>;
  operatorData_gt?: InputMaybe<Scalars["Bytes"]>;
  operatorData_lt?: InputMaybe<Scalars["Bytes"]>;
  operatorData_gte?: InputMaybe<Scalars["Bytes"]>;
  operatorData_lte?: InputMaybe<Scalars["Bytes"]>;
  operatorData_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  operatorData_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  operatorData_contains?: InputMaybe<Scalars["Bytes"]>;
  operatorData_not_contains?: InputMaybe<Scalars["Bytes"]>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<MintedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<MintedEvent_filter>>>;
};

export type MintedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "operator"
  | "to"
  | "amount"
  | "data"
  | "token"
  | "operatorData";

export type NewPICEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `pic` (new Patrician In Charge)
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  /**
   * The address of the `token` (supertoken) the PIC is posting a bond for.
   *
   */
  token: Scalars["Bytes"];
  /**
   * The address of the new Patrician In Charge (PIC).
   *
   */
  pic: Scalars["Bytes"];
  /**
   * The bond the new PIC staked in order to claim the position.
   *
   */
  bond: Scalars["BigInt"];
  /**
   * The flowrate at which the bond is streamed back to the PIC.
   *
   */
  exitRate: Scalars["BigInt"];
};

export type NewPICEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  pic?: InputMaybe<Scalars["Bytes"]>;
  pic_not?: InputMaybe<Scalars["Bytes"]>;
  pic_gt?: InputMaybe<Scalars["Bytes"]>;
  pic_lt?: InputMaybe<Scalars["Bytes"]>;
  pic_gte?: InputMaybe<Scalars["Bytes"]>;
  pic_lte?: InputMaybe<Scalars["Bytes"]>;
  pic_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  pic_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  pic_contains?: InputMaybe<Scalars["Bytes"]>;
  pic_not_contains?: InputMaybe<Scalars["Bytes"]>;
  bond?: InputMaybe<Scalars["BigInt"]>;
  bond_not?: InputMaybe<Scalars["BigInt"]>;
  bond_gt?: InputMaybe<Scalars["BigInt"]>;
  bond_lt?: InputMaybe<Scalars["BigInt"]>;
  bond_gte?: InputMaybe<Scalars["BigInt"]>;
  bond_lte?: InputMaybe<Scalars["BigInt"]>;
  bond_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  bond_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  exitRate?: InputMaybe<Scalars["BigInt"]>;
  exitRate_not?: InputMaybe<Scalars["BigInt"]>;
  exitRate_gt?: InputMaybe<Scalars["BigInt"]>;
  exitRate_lt?: InputMaybe<Scalars["BigInt"]>;
  exitRate_gte?: InputMaybe<Scalars["BigInt"]>;
  exitRate_lte?: InputMaybe<Scalars["BigInt"]>;
  exitRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  exitRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<NewPICEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<NewPICEvent_filter>>>;
};

export type NewPICEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "pic"
  | "bond"
  | "exitRate";

/** Defines the order direction, either ascending or descending */
export type OrderDirection = "asc" | "desc";

export type PPPConfigurationChangedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * The address of the governance contract the event was emitted from.
   *
   */
  governanceAddress: Scalars["Bytes"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `governanceAddress`
   * addresses[1] = `host`
   * addresses[2] = `superToken`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  host: Scalars["Bytes"];
  superToken: Scalars["Bytes"];
  isKeySet: Scalars["Boolean"];
  liquidationPeriod: Scalars["BigInt"];
  patricianPeriod: Scalars["BigInt"];
};

export type PPPConfigurationChangedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  governanceAddress?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_not?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_gt?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_lt?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_gte?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_lte?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  governanceAddress_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  governanceAddress_contains?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_not_contains?: InputMaybe<Scalars["Bytes"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  host?: InputMaybe<Scalars["Bytes"]>;
  host_not?: InputMaybe<Scalars["Bytes"]>;
  host_gt?: InputMaybe<Scalars["Bytes"]>;
  host_lt?: InputMaybe<Scalars["Bytes"]>;
  host_gte?: InputMaybe<Scalars["Bytes"]>;
  host_lte?: InputMaybe<Scalars["Bytes"]>;
  host_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  host_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  host_contains?: InputMaybe<Scalars["Bytes"]>;
  host_not_contains?: InputMaybe<Scalars["Bytes"]>;
  superToken?: InputMaybe<Scalars["Bytes"]>;
  superToken_not?: InputMaybe<Scalars["Bytes"]>;
  superToken_gt?: InputMaybe<Scalars["Bytes"]>;
  superToken_lt?: InputMaybe<Scalars["Bytes"]>;
  superToken_gte?: InputMaybe<Scalars["Bytes"]>;
  superToken_lte?: InputMaybe<Scalars["Bytes"]>;
  superToken_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  superToken_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  superToken_contains?: InputMaybe<Scalars["Bytes"]>;
  superToken_not_contains?: InputMaybe<Scalars["Bytes"]>;
  isKeySet?: InputMaybe<Scalars["Boolean"]>;
  isKeySet_not?: InputMaybe<Scalars["Boolean"]>;
  isKeySet_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  isKeySet_not_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  liquidationPeriod?: InputMaybe<Scalars["BigInt"]>;
  liquidationPeriod_not?: InputMaybe<Scalars["BigInt"]>;
  liquidationPeriod_gt?: InputMaybe<Scalars["BigInt"]>;
  liquidationPeriod_lt?: InputMaybe<Scalars["BigInt"]>;
  liquidationPeriod_gte?: InputMaybe<Scalars["BigInt"]>;
  liquidationPeriod_lte?: InputMaybe<Scalars["BigInt"]>;
  liquidationPeriod_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  liquidationPeriod_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  patricianPeriod?: InputMaybe<Scalars["BigInt"]>;
  patricianPeriod_not?: InputMaybe<Scalars["BigInt"]>;
  patricianPeriod_gt?: InputMaybe<Scalars["BigInt"]>;
  patricianPeriod_lt?: InputMaybe<Scalars["BigInt"]>;
  patricianPeriod_gte?: InputMaybe<Scalars["BigInt"]>;
  patricianPeriod_lte?: InputMaybe<Scalars["BigInt"]>;
  patricianPeriod_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  patricianPeriod_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<PPPConfigurationChangedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<PPPConfigurationChangedEvent_filter>>>;
};

export type PPPConfigurationChangedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "governanceAddress"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "host"
  | "superToken"
  | "isKeySet"
  | "liquidationPeriod"
  | "patricianPeriod";

export type Pool = {
  /**
   * ID: poolAddress
   *
   */
  id: Scalars["ID"];
  createdAtTimestamp: Scalars["BigInt"];
  createdAtBlockNumber: Scalars["BigInt"];
  updatedAtTimestamp: Scalars["BigInt"];
  updatedAtBlockNumber: Scalars["BigInt"];
  totalUnits: Scalars["BigInt"];
  totalConnectedUnits: Scalars["BigInt"];
  totalDisconnectedUnits: Scalars["BigInt"];
  totalAmountInstantlyDistributedUntilUpdatedAt: Scalars["BigInt"];
  totalAmountFlowedDistributedUntilUpdatedAt: Scalars["BigInt"];
  totalAmountDistributedUntilUpdatedAt: Scalars["BigInt"];
  totalFlowAdjustmentAmountDistributedUntilUpdatedAt: Scalars["BigInt"];
  perUnitSettledValue: Scalars["BigInt"];
  perUnitFlowRate: Scalars["BigInt"];
  /**
   * A member is any account which has more than 0 units in the pool.
   *
   */
  totalMembers: Scalars["Int"];
  /**
   * A connected member is any account which has more than 0 units in the pool and is connected.
   *
   */
  totalConnectedMembers: Scalars["Int"];
  /**
   * A disconnected member is any account which has more than 0 units in the pool and is not connected.
   *
   */
  totalDisconnectedMembers: Scalars["Int"];
  adjustmentFlowRate: Scalars["BigInt"];
  flowRate: Scalars["BigInt"];
  totalBuffer: Scalars["BigInt"];
  token: Token;
  admin: Account;
  poolDistributors: Array<PoolDistributor>;
  poolMembers: Array<PoolMember>;
  poolCreatedEvent: PoolCreatedEvent;
  poolConnectionUpdatedEvents: Array<PoolConnectionUpdatedEvent>;
  bufferAdjustedEvents: Array<BufferAdjustedEvent>;
  instantDistributionUpdatedEvents: Array<InstantDistributionUpdatedEvent>;
  flowDistributionUpdatedEvents: Array<FlowDistributionUpdatedEvent>;
  memberUnitsUpdatedEvents: Array<MemberUnitsUpdatedEvent>;
  distributionClaimedEvents: Array<DistributionClaimedEvent>;
};

export type PoolpoolDistributorsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<PoolDistributor_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<PoolDistributor_filter>;
};

export type PoolpoolMembersArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<PoolMember_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<PoolMember_filter>;
};

export type PoolpoolConnectionUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<PoolConnectionUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<PoolConnectionUpdatedEvent_filter>;
};

export type PoolbufferAdjustedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<BufferAdjustedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<BufferAdjustedEvent_filter>;
};

export type PoolinstantDistributionUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<InstantDistributionUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<InstantDistributionUpdatedEvent_filter>;
};

export type PoolflowDistributionUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<FlowDistributionUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<FlowDistributionUpdatedEvent_filter>;
};

export type PoolmemberUnitsUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<MemberUnitsUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<MemberUnitsUpdatedEvent_filter>;
};

export type PooldistributionClaimedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<DistributionClaimedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<DistributionClaimedEvent_filter>;
};

export type PoolConnectionUpdatedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `pool`
   * addresses[2] = `poolMember`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
  connected: Scalars["Boolean"];
  userData: Scalars["Bytes"];
  pool: Pool;
  poolMember: PoolMember;
};

export type PoolConnectionUpdatedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  connected?: InputMaybe<Scalars["Boolean"]>;
  connected_not?: InputMaybe<Scalars["Boolean"]>;
  connected_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  connected_not_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  userData?: InputMaybe<Scalars["Bytes"]>;
  userData_not?: InputMaybe<Scalars["Bytes"]>;
  userData_gt?: InputMaybe<Scalars["Bytes"]>;
  userData_lt?: InputMaybe<Scalars["Bytes"]>;
  userData_gte?: InputMaybe<Scalars["Bytes"]>;
  userData_lte?: InputMaybe<Scalars["Bytes"]>;
  userData_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_contains?: InputMaybe<Scalars["Bytes"]>;
  userData_not_contains?: InputMaybe<Scalars["Bytes"]>;
  pool?: InputMaybe<Scalars["String"]>;
  pool_not?: InputMaybe<Scalars["String"]>;
  pool_gt?: InputMaybe<Scalars["String"]>;
  pool_lt?: InputMaybe<Scalars["String"]>;
  pool_gte?: InputMaybe<Scalars["String"]>;
  pool_lte?: InputMaybe<Scalars["String"]>;
  pool_in?: InputMaybe<Array<Scalars["String"]>>;
  pool_not_in?: InputMaybe<Array<Scalars["String"]>>;
  pool_contains?: InputMaybe<Scalars["String"]>;
  pool_contains_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_contains?: InputMaybe<Scalars["String"]>;
  pool_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  pool_starts_with?: InputMaybe<Scalars["String"]>;
  pool_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_starts_with?: InputMaybe<Scalars["String"]>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_ends_with?: InputMaybe<Scalars["String"]>;
  pool_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_ends_with?: InputMaybe<Scalars["String"]>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_?: InputMaybe<Pool_filter>;
  poolMember?: InputMaybe<Scalars["String"]>;
  poolMember_not?: InputMaybe<Scalars["String"]>;
  poolMember_gt?: InputMaybe<Scalars["String"]>;
  poolMember_lt?: InputMaybe<Scalars["String"]>;
  poolMember_gte?: InputMaybe<Scalars["String"]>;
  poolMember_lte?: InputMaybe<Scalars["String"]>;
  poolMember_in?: InputMaybe<Array<Scalars["String"]>>;
  poolMember_not_in?: InputMaybe<Array<Scalars["String"]>>;
  poolMember_contains?: InputMaybe<Scalars["String"]>;
  poolMember_contains_nocase?: InputMaybe<Scalars["String"]>;
  poolMember_not_contains?: InputMaybe<Scalars["String"]>;
  poolMember_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  poolMember_starts_with?: InputMaybe<Scalars["String"]>;
  poolMember_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  poolMember_not_starts_with?: InputMaybe<Scalars["String"]>;
  poolMember_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  poolMember_ends_with?: InputMaybe<Scalars["String"]>;
  poolMember_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  poolMember_not_ends_with?: InputMaybe<Scalars["String"]>;
  poolMember_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  poolMember_?: InputMaybe<PoolMember_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<PoolConnectionUpdatedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<PoolConnectionUpdatedEvent_filter>>>;
};

export type PoolConnectionUpdatedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "connected"
  | "userData"
  | "pool"
  | "pool__id"
  | "pool__createdAtTimestamp"
  | "pool__createdAtBlockNumber"
  | "pool__updatedAtTimestamp"
  | "pool__updatedAtBlockNumber"
  | "pool__totalUnits"
  | "pool__totalConnectedUnits"
  | "pool__totalDisconnectedUnits"
  | "pool__totalAmountInstantlyDistributedUntilUpdatedAt"
  | "pool__totalAmountFlowedDistributedUntilUpdatedAt"
  | "pool__totalAmountDistributedUntilUpdatedAt"
  | "pool__totalFlowAdjustmentAmountDistributedUntilUpdatedAt"
  | "pool__perUnitSettledValue"
  | "pool__perUnitFlowRate"
  | "pool__totalMembers"
  | "pool__totalConnectedMembers"
  | "pool__totalDisconnectedMembers"
  | "pool__adjustmentFlowRate"
  | "pool__flowRate"
  | "pool__totalBuffer"
  | "poolMember"
  | "poolMember__id"
  | "poolMember__createdAtTimestamp"
  | "poolMember__createdAtBlockNumber"
  | "poolMember__updatedAtTimestamp"
  | "poolMember__updatedAtBlockNumber"
  | "poolMember__units"
  | "poolMember__isConnected"
  | "poolMember__totalAmountClaimed"
  | "poolMember__poolTotalAmountDistributedUntilUpdatedAt"
  | "poolMember__totalAmountReceivedUntilUpdatedAt"
  | "poolMember__syncedPerUnitSettledValue"
  | "poolMember__syncedPerUnitFlowRate";

export type PoolCreatedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `pool`
   * addresses[2] = `caller`
   * addresses[3] = `admin`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
  caller: Scalars["Bytes"];
  admin: Scalars["Bytes"];
  pool: Pool;
};

export type PoolCreatedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  caller?: InputMaybe<Scalars["Bytes"]>;
  caller_not?: InputMaybe<Scalars["Bytes"]>;
  caller_gt?: InputMaybe<Scalars["Bytes"]>;
  caller_lt?: InputMaybe<Scalars["Bytes"]>;
  caller_gte?: InputMaybe<Scalars["Bytes"]>;
  caller_lte?: InputMaybe<Scalars["Bytes"]>;
  caller_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  caller_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  caller_contains?: InputMaybe<Scalars["Bytes"]>;
  caller_not_contains?: InputMaybe<Scalars["Bytes"]>;
  admin?: InputMaybe<Scalars["Bytes"]>;
  admin_not?: InputMaybe<Scalars["Bytes"]>;
  admin_gt?: InputMaybe<Scalars["Bytes"]>;
  admin_lt?: InputMaybe<Scalars["Bytes"]>;
  admin_gte?: InputMaybe<Scalars["Bytes"]>;
  admin_lte?: InputMaybe<Scalars["Bytes"]>;
  admin_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  admin_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  admin_contains?: InputMaybe<Scalars["Bytes"]>;
  admin_not_contains?: InputMaybe<Scalars["Bytes"]>;
  pool?: InputMaybe<Scalars["String"]>;
  pool_not?: InputMaybe<Scalars["String"]>;
  pool_gt?: InputMaybe<Scalars["String"]>;
  pool_lt?: InputMaybe<Scalars["String"]>;
  pool_gte?: InputMaybe<Scalars["String"]>;
  pool_lte?: InputMaybe<Scalars["String"]>;
  pool_in?: InputMaybe<Array<Scalars["String"]>>;
  pool_not_in?: InputMaybe<Array<Scalars["String"]>>;
  pool_contains?: InputMaybe<Scalars["String"]>;
  pool_contains_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_contains?: InputMaybe<Scalars["String"]>;
  pool_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  pool_starts_with?: InputMaybe<Scalars["String"]>;
  pool_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_starts_with?: InputMaybe<Scalars["String"]>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_ends_with?: InputMaybe<Scalars["String"]>;
  pool_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_ends_with?: InputMaybe<Scalars["String"]>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_?: InputMaybe<Pool_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<PoolCreatedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<PoolCreatedEvent_filter>>>;
};

export type PoolCreatedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "caller"
  | "admin"
  | "pool"
  | "pool__id"
  | "pool__createdAtTimestamp"
  | "pool__createdAtBlockNumber"
  | "pool__updatedAtTimestamp"
  | "pool__updatedAtBlockNumber"
  | "pool__totalUnits"
  | "pool__totalConnectedUnits"
  | "pool__totalDisconnectedUnits"
  | "pool__totalAmountInstantlyDistributedUntilUpdatedAt"
  | "pool__totalAmountFlowedDistributedUntilUpdatedAt"
  | "pool__totalAmountDistributedUntilUpdatedAt"
  | "pool__totalFlowAdjustmentAmountDistributedUntilUpdatedAt"
  | "pool__perUnitSettledValue"
  | "pool__perUnitFlowRate"
  | "pool__totalMembers"
  | "pool__totalConnectedMembers"
  | "pool__totalDisconnectedMembers"
  | "pool__adjustmentFlowRate"
  | "pool__flowRate"
  | "pool__totalBuffer";

export type PoolDistributor = {
  /**
   * ID composed of: "poolDistributor"-pool-poolDistributorAddress
   *
   */
  id: Scalars["ID"];
  createdAtTimestamp: Scalars["BigInt"];
  createdAtBlockNumber: Scalars["BigInt"];
  updatedAtTimestamp: Scalars["BigInt"];
  updatedAtBlockNumber: Scalars["BigInt"];
  totalAmountInstantlyDistributedUntilUpdatedAt: Scalars["BigInt"];
  totalAmountFlowedDistributedUntilUpdatedAt: Scalars["BigInt"];
  totalAmountDistributedUntilUpdatedAt: Scalars["BigInt"];
  totalBuffer: Scalars["BigInt"];
  flowRate: Scalars["BigInt"];
  account: Account;
  pool: Pool;
  bufferAdjustedEvents: Array<BufferAdjustedEvent>;
  instantDistributionUpdatedEvents: Array<InstantDistributionUpdatedEvent>;
  flowDistributionUpdatedEvents: Array<FlowDistributionUpdatedEvent>;
};

export type PoolDistributorbufferAdjustedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<BufferAdjustedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<BufferAdjustedEvent_filter>;
};

export type PoolDistributorinstantDistributionUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<InstantDistributionUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<InstantDistributionUpdatedEvent_filter>;
};

export type PoolDistributorflowDistributionUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<FlowDistributionUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<FlowDistributionUpdatedEvent_filter>;
};

export type PoolDistributor_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  createdAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountInstantlyDistributedUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountInstantlyDistributedUntilUpdatedAt_not?: InputMaybe<
    Scalars["BigInt"]
  >;
  totalAmountInstantlyDistributedUntilUpdatedAt_gt?: InputMaybe<
    Scalars["BigInt"]
  >;
  totalAmountInstantlyDistributedUntilUpdatedAt_lt?: InputMaybe<
    Scalars["BigInt"]
  >;
  totalAmountInstantlyDistributedUntilUpdatedAt_gte?: InputMaybe<
    Scalars["BigInt"]
  >;
  totalAmountInstantlyDistributedUntilUpdatedAt_lte?: InputMaybe<
    Scalars["BigInt"]
  >;
  totalAmountInstantlyDistributedUntilUpdatedAt_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalAmountInstantlyDistributedUntilUpdatedAt_not_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalAmountFlowedDistributedUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountFlowedDistributedUntilUpdatedAt_not?: InputMaybe<
    Scalars["BigInt"]
  >;
  totalAmountFlowedDistributedUntilUpdatedAt_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountFlowedDistributedUntilUpdatedAt_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountFlowedDistributedUntilUpdatedAt_gte?: InputMaybe<
    Scalars["BigInt"]
  >;
  totalAmountFlowedDistributedUntilUpdatedAt_lte?: InputMaybe<
    Scalars["BigInt"]
  >;
  totalAmountFlowedDistributedUntilUpdatedAt_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalAmountFlowedDistributedUntilUpdatedAt_not_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalAmountDistributedUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_not?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_gte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_lte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalAmountDistributedUntilUpdatedAt_not_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalBuffer?: InputMaybe<Scalars["BigInt"]>;
  totalBuffer_not?: InputMaybe<Scalars["BigInt"]>;
  totalBuffer_gt?: InputMaybe<Scalars["BigInt"]>;
  totalBuffer_lt?: InputMaybe<Scalars["BigInt"]>;
  totalBuffer_gte?: InputMaybe<Scalars["BigInt"]>;
  totalBuffer_lte?: InputMaybe<Scalars["BigInt"]>;
  totalBuffer_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalBuffer_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  flowRate?: InputMaybe<Scalars["BigInt"]>;
  flowRate_not?: InputMaybe<Scalars["BigInt"]>;
  flowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  flowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  flowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  flowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  flowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  flowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  account?: InputMaybe<Scalars["String"]>;
  account_not?: InputMaybe<Scalars["String"]>;
  account_gt?: InputMaybe<Scalars["String"]>;
  account_lt?: InputMaybe<Scalars["String"]>;
  account_gte?: InputMaybe<Scalars["String"]>;
  account_lte?: InputMaybe<Scalars["String"]>;
  account_in?: InputMaybe<Array<Scalars["String"]>>;
  account_not_in?: InputMaybe<Array<Scalars["String"]>>;
  account_contains?: InputMaybe<Scalars["String"]>;
  account_contains_nocase?: InputMaybe<Scalars["String"]>;
  account_not_contains?: InputMaybe<Scalars["String"]>;
  account_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  account_starts_with?: InputMaybe<Scalars["String"]>;
  account_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  account_not_starts_with?: InputMaybe<Scalars["String"]>;
  account_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  account_ends_with?: InputMaybe<Scalars["String"]>;
  account_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  account_not_ends_with?: InputMaybe<Scalars["String"]>;
  account_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  account_?: InputMaybe<Account_filter>;
  pool?: InputMaybe<Scalars["String"]>;
  pool_not?: InputMaybe<Scalars["String"]>;
  pool_gt?: InputMaybe<Scalars["String"]>;
  pool_lt?: InputMaybe<Scalars["String"]>;
  pool_gte?: InputMaybe<Scalars["String"]>;
  pool_lte?: InputMaybe<Scalars["String"]>;
  pool_in?: InputMaybe<Array<Scalars["String"]>>;
  pool_not_in?: InputMaybe<Array<Scalars["String"]>>;
  pool_contains?: InputMaybe<Scalars["String"]>;
  pool_contains_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_contains?: InputMaybe<Scalars["String"]>;
  pool_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  pool_starts_with?: InputMaybe<Scalars["String"]>;
  pool_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_starts_with?: InputMaybe<Scalars["String"]>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_ends_with?: InputMaybe<Scalars["String"]>;
  pool_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_ends_with?: InputMaybe<Scalars["String"]>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_?: InputMaybe<Pool_filter>;
  bufferAdjustedEvents_?: InputMaybe<BufferAdjustedEvent_filter>;
  instantDistributionUpdatedEvents_?: InputMaybe<InstantDistributionUpdatedEvent_filter>;
  flowDistributionUpdatedEvents_?: InputMaybe<FlowDistributionUpdatedEvent_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<PoolDistributor_filter>>>;
  or?: InputMaybe<Array<InputMaybe<PoolDistributor_filter>>>;
};

export type PoolDistributor_orderBy =
  | "id"
  | "createdAtTimestamp"
  | "createdAtBlockNumber"
  | "updatedAtTimestamp"
  | "updatedAtBlockNumber"
  | "totalAmountInstantlyDistributedUntilUpdatedAt"
  | "totalAmountFlowedDistributedUntilUpdatedAt"
  | "totalAmountDistributedUntilUpdatedAt"
  | "totalBuffer"
  | "flowRate"
  | "account"
  | "account__id"
  | "account__createdAtTimestamp"
  | "account__createdAtBlockNumber"
  | "account__updatedAtTimestamp"
  | "account__updatedAtBlockNumber"
  | "account__isSuperApp"
  | "pool"
  | "pool__id"
  | "pool__createdAtTimestamp"
  | "pool__createdAtBlockNumber"
  | "pool__updatedAtTimestamp"
  | "pool__updatedAtBlockNumber"
  | "pool__totalUnits"
  | "pool__totalConnectedUnits"
  | "pool__totalDisconnectedUnits"
  | "pool__totalAmountInstantlyDistributedUntilUpdatedAt"
  | "pool__totalAmountFlowedDistributedUntilUpdatedAt"
  | "pool__totalAmountDistributedUntilUpdatedAt"
  | "pool__totalFlowAdjustmentAmountDistributedUntilUpdatedAt"
  | "pool__perUnitSettledValue"
  | "pool__perUnitFlowRate"
  | "pool__totalMembers"
  | "pool__totalConnectedMembers"
  | "pool__totalDisconnectedMembers"
  | "pool__adjustmentFlowRate"
  | "pool__flowRate"
  | "pool__totalBuffer"
  | "bufferAdjustedEvents"
  | "instantDistributionUpdatedEvents"
  | "flowDistributionUpdatedEvents";

export type PoolMember = {
  /**
   * ID composed of: "poolMember"-poolAddress-poolMemberAddress
   *
   */
  id: Scalars["ID"];
  createdAtTimestamp: Scalars["BigInt"];
  createdAtBlockNumber: Scalars["BigInt"];
  updatedAtTimestamp: Scalars["BigInt"];
  updatedAtBlockNumber: Scalars["BigInt"];
  units: Scalars["BigInt"];
  isConnected: Scalars["Boolean"];
  totalAmountClaimed: Scalars["BigInt"];
  poolTotalAmountDistributedUntilUpdatedAt: Scalars["BigInt"];
  totalAmountReceivedUntilUpdatedAt: Scalars["BigInt"];
  syncedPerUnitSettledValue: Scalars["BigInt"];
  syncedPerUnitFlowRate: Scalars["BigInt"];
  account: Account;
  pool: Pool;
  poolConnectionUpdatedEvents: Array<PoolConnectionUpdatedEvent>;
  memberUnitsUpdatedEvents: Array<MemberUnitsUpdatedEvent>;
  distributionClaimedEvents: Array<DistributionClaimedEvent>;
};

export type PoolMemberpoolConnectionUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<PoolConnectionUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<PoolConnectionUpdatedEvent_filter>;
};

export type PoolMembermemberUnitsUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<MemberUnitsUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<MemberUnitsUpdatedEvent_filter>;
};

export type PoolMemberdistributionClaimedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<DistributionClaimedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<DistributionClaimedEvent_filter>;
};

export type PoolMember_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  createdAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  units?: InputMaybe<Scalars["BigInt"]>;
  units_not?: InputMaybe<Scalars["BigInt"]>;
  units_gt?: InputMaybe<Scalars["BigInt"]>;
  units_lt?: InputMaybe<Scalars["BigInt"]>;
  units_gte?: InputMaybe<Scalars["BigInt"]>;
  units_lte?: InputMaybe<Scalars["BigInt"]>;
  units_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  units_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  isConnected?: InputMaybe<Scalars["Boolean"]>;
  isConnected_not?: InputMaybe<Scalars["Boolean"]>;
  isConnected_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  isConnected_not_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  totalAmountClaimed?: InputMaybe<Scalars["BigInt"]>;
  totalAmountClaimed_not?: InputMaybe<Scalars["BigInt"]>;
  totalAmountClaimed_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountClaimed_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountClaimed_gte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountClaimed_lte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountClaimed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountClaimed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  poolTotalAmountDistributedUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  poolTotalAmountDistributedUntilUpdatedAt_not?: InputMaybe<Scalars["BigInt"]>;
  poolTotalAmountDistributedUntilUpdatedAt_gt?: InputMaybe<Scalars["BigInt"]>;
  poolTotalAmountDistributedUntilUpdatedAt_lt?: InputMaybe<Scalars["BigInt"]>;
  poolTotalAmountDistributedUntilUpdatedAt_gte?: InputMaybe<Scalars["BigInt"]>;
  poolTotalAmountDistributedUntilUpdatedAt_lte?: InputMaybe<Scalars["BigInt"]>;
  poolTotalAmountDistributedUntilUpdatedAt_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  poolTotalAmountDistributedUntilUpdatedAt_not_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalAmountReceivedUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountReceivedUntilUpdatedAt_not?: InputMaybe<Scalars["BigInt"]>;
  totalAmountReceivedUntilUpdatedAt_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountReceivedUntilUpdatedAt_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountReceivedUntilUpdatedAt_gte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountReceivedUntilUpdatedAt_lte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountReceivedUntilUpdatedAt_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountReceivedUntilUpdatedAt_not_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  syncedPerUnitSettledValue?: InputMaybe<Scalars["BigInt"]>;
  syncedPerUnitSettledValue_not?: InputMaybe<Scalars["BigInt"]>;
  syncedPerUnitSettledValue_gt?: InputMaybe<Scalars["BigInt"]>;
  syncedPerUnitSettledValue_lt?: InputMaybe<Scalars["BigInt"]>;
  syncedPerUnitSettledValue_gte?: InputMaybe<Scalars["BigInt"]>;
  syncedPerUnitSettledValue_lte?: InputMaybe<Scalars["BigInt"]>;
  syncedPerUnitSettledValue_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  syncedPerUnitSettledValue_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  syncedPerUnitFlowRate?: InputMaybe<Scalars["BigInt"]>;
  syncedPerUnitFlowRate_not?: InputMaybe<Scalars["BigInt"]>;
  syncedPerUnitFlowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  syncedPerUnitFlowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  syncedPerUnitFlowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  syncedPerUnitFlowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  syncedPerUnitFlowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  syncedPerUnitFlowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  account?: InputMaybe<Scalars["String"]>;
  account_not?: InputMaybe<Scalars["String"]>;
  account_gt?: InputMaybe<Scalars["String"]>;
  account_lt?: InputMaybe<Scalars["String"]>;
  account_gte?: InputMaybe<Scalars["String"]>;
  account_lte?: InputMaybe<Scalars["String"]>;
  account_in?: InputMaybe<Array<Scalars["String"]>>;
  account_not_in?: InputMaybe<Array<Scalars["String"]>>;
  account_contains?: InputMaybe<Scalars["String"]>;
  account_contains_nocase?: InputMaybe<Scalars["String"]>;
  account_not_contains?: InputMaybe<Scalars["String"]>;
  account_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  account_starts_with?: InputMaybe<Scalars["String"]>;
  account_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  account_not_starts_with?: InputMaybe<Scalars["String"]>;
  account_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  account_ends_with?: InputMaybe<Scalars["String"]>;
  account_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  account_not_ends_with?: InputMaybe<Scalars["String"]>;
  account_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  account_?: InputMaybe<Account_filter>;
  pool?: InputMaybe<Scalars["String"]>;
  pool_not?: InputMaybe<Scalars["String"]>;
  pool_gt?: InputMaybe<Scalars["String"]>;
  pool_lt?: InputMaybe<Scalars["String"]>;
  pool_gte?: InputMaybe<Scalars["String"]>;
  pool_lte?: InputMaybe<Scalars["String"]>;
  pool_in?: InputMaybe<Array<Scalars["String"]>>;
  pool_not_in?: InputMaybe<Array<Scalars["String"]>>;
  pool_contains?: InputMaybe<Scalars["String"]>;
  pool_contains_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_contains?: InputMaybe<Scalars["String"]>;
  pool_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  pool_starts_with?: InputMaybe<Scalars["String"]>;
  pool_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_starts_with?: InputMaybe<Scalars["String"]>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_ends_with?: InputMaybe<Scalars["String"]>;
  pool_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_not_ends_with?: InputMaybe<Scalars["String"]>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  pool_?: InputMaybe<Pool_filter>;
  poolConnectionUpdatedEvents_?: InputMaybe<PoolConnectionUpdatedEvent_filter>;
  memberUnitsUpdatedEvents_?: InputMaybe<MemberUnitsUpdatedEvent_filter>;
  distributionClaimedEvents_?: InputMaybe<DistributionClaimedEvent_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<PoolMember_filter>>>;
  or?: InputMaybe<Array<InputMaybe<PoolMember_filter>>>;
};

export type PoolMember_orderBy =
  | "id"
  | "createdAtTimestamp"
  | "createdAtBlockNumber"
  | "updatedAtTimestamp"
  | "updatedAtBlockNumber"
  | "units"
  | "isConnected"
  | "totalAmountClaimed"
  | "poolTotalAmountDistributedUntilUpdatedAt"
  | "totalAmountReceivedUntilUpdatedAt"
  | "syncedPerUnitSettledValue"
  | "syncedPerUnitFlowRate"
  | "account"
  | "account__id"
  | "account__createdAtTimestamp"
  | "account__createdAtBlockNumber"
  | "account__updatedAtTimestamp"
  | "account__updatedAtBlockNumber"
  | "account__isSuperApp"
  | "pool"
  | "pool__id"
  | "pool__createdAtTimestamp"
  | "pool__createdAtBlockNumber"
  | "pool__updatedAtTimestamp"
  | "pool__updatedAtBlockNumber"
  | "pool__totalUnits"
  | "pool__totalConnectedUnits"
  | "pool__totalDisconnectedUnits"
  | "pool__totalAmountInstantlyDistributedUntilUpdatedAt"
  | "pool__totalAmountFlowedDistributedUntilUpdatedAt"
  | "pool__totalAmountDistributedUntilUpdatedAt"
  | "pool__totalFlowAdjustmentAmountDistributedUntilUpdatedAt"
  | "pool__perUnitSettledValue"
  | "pool__perUnitFlowRate"
  | "pool__totalMembers"
  | "pool__totalConnectedMembers"
  | "pool__totalDisconnectedMembers"
  | "pool__adjustmentFlowRate"
  | "pool__flowRate"
  | "pool__totalBuffer"
  | "poolConnectionUpdatedEvents"
  | "memberUnitsUpdatedEvents"
  | "distributionClaimedEvents";

export type Pool_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  createdAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalUnits?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_not?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_gt?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_lt?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_gte?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_lte?: InputMaybe<Scalars["BigInt"]>;
  totalUnits_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalUnits_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalConnectedUnits?: InputMaybe<Scalars["BigInt"]>;
  totalConnectedUnits_not?: InputMaybe<Scalars["BigInt"]>;
  totalConnectedUnits_gt?: InputMaybe<Scalars["BigInt"]>;
  totalConnectedUnits_lt?: InputMaybe<Scalars["BigInt"]>;
  totalConnectedUnits_gte?: InputMaybe<Scalars["BigInt"]>;
  totalConnectedUnits_lte?: InputMaybe<Scalars["BigInt"]>;
  totalConnectedUnits_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalConnectedUnits_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalDisconnectedUnits?: InputMaybe<Scalars["BigInt"]>;
  totalDisconnectedUnits_not?: InputMaybe<Scalars["BigInt"]>;
  totalDisconnectedUnits_gt?: InputMaybe<Scalars["BigInt"]>;
  totalDisconnectedUnits_lt?: InputMaybe<Scalars["BigInt"]>;
  totalDisconnectedUnits_gte?: InputMaybe<Scalars["BigInt"]>;
  totalDisconnectedUnits_lte?: InputMaybe<Scalars["BigInt"]>;
  totalDisconnectedUnits_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalDisconnectedUnits_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountInstantlyDistributedUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountInstantlyDistributedUntilUpdatedAt_not?: InputMaybe<
    Scalars["BigInt"]
  >;
  totalAmountInstantlyDistributedUntilUpdatedAt_gt?: InputMaybe<
    Scalars["BigInt"]
  >;
  totalAmountInstantlyDistributedUntilUpdatedAt_lt?: InputMaybe<
    Scalars["BigInt"]
  >;
  totalAmountInstantlyDistributedUntilUpdatedAt_gte?: InputMaybe<
    Scalars["BigInt"]
  >;
  totalAmountInstantlyDistributedUntilUpdatedAt_lte?: InputMaybe<
    Scalars["BigInt"]
  >;
  totalAmountInstantlyDistributedUntilUpdatedAt_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalAmountInstantlyDistributedUntilUpdatedAt_not_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalAmountFlowedDistributedUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountFlowedDistributedUntilUpdatedAt_not?: InputMaybe<
    Scalars["BigInt"]
  >;
  totalAmountFlowedDistributedUntilUpdatedAt_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountFlowedDistributedUntilUpdatedAt_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountFlowedDistributedUntilUpdatedAt_gte?: InputMaybe<
    Scalars["BigInt"]
  >;
  totalAmountFlowedDistributedUntilUpdatedAt_lte?: InputMaybe<
    Scalars["BigInt"]
  >;
  totalAmountFlowedDistributedUntilUpdatedAt_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalAmountFlowedDistributedUntilUpdatedAt_not_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalAmountDistributedUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_not?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_gte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_lte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalAmountDistributedUntilUpdatedAt_not_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalFlowAdjustmentAmountDistributedUntilUpdatedAt?: InputMaybe<
    Scalars["BigInt"]
  >;
  totalFlowAdjustmentAmountDistributedUntilUpdatedAt_not?: InputMaybe<
    Scalars["BigInt"]
  >;
  totalFlowAdjustmentAmountDistributedUntilUpdatedAt_gt?: InputMaybe<
    Scalars["BigInt"]
  >;
  totalFlowAdjustmentAmountDistributedUntilUpdatedAt_lt?: InputMaybe<
    Scalars["BigInt"]
  >;
  totalFlowAdjustmentAmountDistributedUntilUpdatedAt_gte?: InputMaybe<
    Scalars["BigInt"]
  >;
  totalFlowAdjustmentAmountDistributedUntilUpdatedAt_lte?: InputMaybe<
    Scalars["BigInt"]
  >;
  totalFlowAdjustmentAmountDistributedUntilUpdatedAt_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalFlowAdjustmentAmountDistributedUntilUpdatedAt_not_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  perUnitSettledValue?: InputMaybe<Scalars["BigInt"]>;
  perUnitSettledValue_not?: InputMaybe<Scalars["BigInt"]>;
  perUnitSettledValue_gt?: InputMaybe<Scalars["BigInt"]>;
  perUnitSettledValue_lt?: InputMaybe<Scalars["BigInt"]>;
  perUnitSettledValue_gte?: InputMaybe<Scalars["BigInt"]>;
  perUnitSettledValue_lte?: InputMaybe<Scalars["BigInt"]>;
  perUnitSettledValue_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  perUnitSettledValue_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  perUnitFlowRate?: InputMaybe<Scalars["BigInt"]>;
  perUnitFlowRate_not?: InputMaybe<Scalars["BigInt"]>;
  perUnitFlowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  perUnitFlowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  perUnitFlowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  perUnitFlowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  perUnitFlowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  perUnitFlowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalMembers?: InputMaybe<Scalars["Int"]>;
  totalMembers_not?: InputMaybe<Scalars["Int"]>;
  totalMembers_gt?: InputMaybe<Scalars["Int"]>;
  totalMembers_lt?: InputMaybe<Scalars["Int"]>;
  totalMembers_gte?: InputMaybe<Scalars["Int"]>;
  totalMembers_lte?: InputMaybe<Scalars["Int"]>;
  totalMembers_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalMembers_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalConnectedMembers?: InputMaybe<Scalars["Int"]>;
  totalConnectedMembers_not?: InputMaybe<Scalars["Int"]>;
  totalConnectedMembers_gt?: InputMaybe<Scalars["Int"]>;
  totalConnectedMembers_lt?: InputMaybe<Scalars["Int"]>;
  totalConnectedMembers_gte?: InputMaybe<Scalars["Int"]>;
  totalConnectedMembers_lte?: InputMaybe<Scalars["Int"]>;
  totalConnectedMembers_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalConnectedMembers_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalDisconnectedMembers?: InputMaybe<Scalars["Int"]>;
  totalDisconnectedMembers_not?: InputMaybe<Scalars["Int"]>;
  totalDisconnectedMembers_gt?: InputMaybe<Scalars["Int"]>;
  totalDisconnectedMembers_lt?: InputMaybe<Scalars["Int"]>;
  totalDisconnectedMembers_gte?: InputMaybe<Scalars["Int"]>;
  totalDisconnectedMembers_lte?: InputMaybe<Scalars["Int"]>;
  totalDisconnectedMembers_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalDisconnectedMembers_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  adjustmentFlowRate?: InputMaybe<Scalars["BigInt"]>;
  adjustmentFlowRate_not?: InputMaybe<Scalars["BigInt"]>;
  adjustmentFlowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  adjustmentFlowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  adjustmentFlowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  adjustmentFlowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  adjustmentFlowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  adjustmentFlowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  flowRate?: InputMaybe<Scalars["BigInt"]>;
  flowRate_not?: InputMaybe<Scalars["BigInt"]>;
  flowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  flowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  flowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  flowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  flowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  flowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalBuffer?: InputMaybe<Scalars["BigInt"]>;
  totalBuffer_not?: InputMaybe<Scalars["BigInt"]>;
  totalBuffer_gt?: InputMaybe<Scalars["BigInt"]>;
  totalBuffer_lt?: InputMaybe<Scalars["BigInt"]>;
  totalBuffer_gte?: InputMaybe<Scalars["BigInt"]>;
  totalBuffer_lte?: InputMaybe<Scalars["BigInt"]>;
  totalBuffer_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalBuffer_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["String"]>;
  token_not?: InputMaybe<Scalars["String"]>;
  token_gt?: InputMaybe<Scalars["String"]>;
  token_lt?: InputMaybe<Scalars["String"]>;
  token_gte?: InputMaybe<Scalars["String"]>;
  token_lte?: InputMaybe<Scalars["String"]>;
  token_in?: InputMaybe<Array<Scalars["String"]>>;
  token_not_in?: InputMaybe<Array<Scalars["String"]>>;
  token_contains?: InputMaybe<Scalars["String"]>;
  token_contains_nocase?: InputMaybe<Scalars["String"]>;
  token_not_contains?: InputMaybe<Scalars["String"]>;
  token_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  token_starts_with?: InputMaybe<Scalars["String"]>;
  token_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  token_not_starts_with?: InputMaybe<Scalars["String"]>;
  token_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  token_ends_with?: InputMaybe<Scalars["String"]>;
  token_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  token_not_ends_with?: InputMaybe<Scalars["String"]>;
  token_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  token_?: InputMaybe<Token_filter>;
  admin?: InputMaybe<Scalars["String"]>;
  admin_not?: InputMaybe<Scalars["String"]>;
  admin_gt?: InputMaybe<Scalars["String"]>;
  admin_lt?: InputMaybe<Scalars["String"]>;
  admin_gte?: InputMaybe<Scalars["String"]>;
  admin_lte?: InputMaybe<Scalars["String"]>;
  admin_in?: InputMaybe<Array<Scalars["String"]>>;
  admin_not_in?: InputMaybe<Array<Scalars["String"]>>;
  admin_contains?: InputMaybe<Scalars["String"]>;
  admin_contains_nocase?: InputMaybe<Scalars["String"]>;
  admin_not_contains?: InputMaybe<Scalars["String"]>;
  admin_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  admin_starts_with?: InputMaybe<Scalars["String"]>;
  admin_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  admin_not_starts_with?: InputMaybe<Scalars["String"]>;
  admin_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  admin_ends_with?: InputMaybe<Scalars["String"]>;
  admin_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  admin_not_ends_with?: InputMaybe<Scalars["String"]>;
  admin_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  admin_?: InputMaybe<Account_filter>;
  poolDistributors_?: InputMaybe<PoolDistributor_filter>;
  poolMembers_?: InputMaybe<PoolMember_filter>;
  poolCreatedEvent_?: InputMaybe<PoolCreatedEvent_filter>;
  poolConnectionUpdatedEvents_?: InputMaybe<PoolConnectionUpdatedEvent_filter>;
  bufferAdjustedEvents_?: InputMaybe<BufferAdjustedEvent_filter>;
  instantDistributionUpdatedEvents_?: InputMaybe<InstantDistributionUpdatedEvent_filter>;
  flowDistributionUpdatedEvents_?: InputMaybe<FlowDistributionUpdatedEvent_filter>;
  memberUnitsUpdatedEvents_?: InputMaybe<MemberUnitsUpdatedEvent_filter>;
  distributionClaimedEvents_?: InputMaybe<DistributionClaimedEvent_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<Pool_filter>>>;
  or?: InputMaybe<Array<InputMaybe<Pool_filter>>>;
};

export type Pool_orderBy =
  | "id"
  | "createdAtTimestamp"
  | "createdAtBlockNumber"
  | "updatedAtTimestamp"
  | "updatedAtBlockNumber"
  | "totalUnits"
  | "totalConnectedUnits"
  | "totalDisconnectedUnits"
  | "totalAmountInstantlyDistributedUntilUpdatedAt"
  | "totalAmountFlowedDistributedUntilUpdatedAt"
  | "totalAmountDistributedUntilUpdatedAt"
  | "totalFlowAdjustmentAmountDistributedUntilUpdatedAt"
  | "perUnitSettledValue"
  | "perUnitFlowRate"
  | "totalMembers"
  | "totalConnectedMembers"
  | "totalDisconnectedMembers"
  | "adjustmentFlowRate"
  | "flowRate"
  | "totalBuffer"
  | "token"
  | "token__id"
  | "token__createdAtTimestamp"
  | "token__createdAtBlockNumber"
  | "token__decimals"
  | "token__name"
  | "token__symbol"
  | "token__isSuperToken"
  | "token__isNativeAssetSuperToken"
  | "token__isListed"
  | "token__underlyingAddress"
  | "admin"
  | "admin__id"
  | "admin__createdAtTimestamp"
  | "admin__createdAtBlockNumber"
  | "admin__updatedAtTimestamp"
  | "admin__updatedAtBlockNumber"
  | "admin__isSuperApp"
  | "poolDistributors"
  | "poolMembers"
  | "poolCreatedEvent"
  | "poolCreatedEvent__id"
  | "poolCreatedEvent__transactionHash"
  | "poolCreatedEvent__gasPrice"
  | "poolCreatedEvent__gasUsed"
  | "poolCreatedEvent__timestamp"
  | "poolCreatedEvent__name"
  | "poolCreatedEvent__blockNumber"
  | "poolCreatedEvent__logIndex"
  | "poolCreatedEvent__order"
  | "poolCreatedEvent__token"
  | "poolCreatedEvent__caller"
  | "poolCreatedEvent__admin"
  | "poolConnectionUpdatedEvents"
  | "bufferAdjustedEvents"
  | "instantDistributionUpdatedEvents"
  | "flowDistributionUpdatedEvents"
  | "memberUnitsUpdatedEvents"
  | "distributionClaimedEvents";

export type Query = {
  flowUpdatedEvent?: Maybe<FlowUpdatedEvent>;
  flowUpdatedEvents: Array<FlowUpdatedEvent>;
  flowOperatorUpdatedEvent?: Maybe<FlowOperatorUpdatedEvent>;
  flowOperatorUpdatedEvents: Array<FlowOperatorUpdatedEvent>;
  indexCreatedEvent?: Maybe<IndexCreatedEvent>;
  indexCreatedEvents: Array<IndexCreatedEvent>;
  indexDistributionClaimedEvent?: Maybe<IndexDistributionClaimedEvent>;
  indexDistributionClaimedEvents: Array<IndexDistributionClaimedEvent>;
  indexUpdatedEvent?: Maybe<IndexUpdatedEvent>;
  indexUpdatedEvents: Array<IndexUpdatedEvent>;
  indexSubscribedEvent?: Maybe<IndexSubscribedEvent>;
  indexSubscribedEvents: Array<IndexSubscribedEvent>;
  indexUnitsUpdatedEvent?: Maybe<IndexUnitsUpdatedEvent>;
  indexUnitsUpdatedEvents: Array<IndexUnitsUpdatedEvent>;
  indexUnsubscribedEvent?: Maybe<IndexUnsubscribedEvent>;
  indexUnsubscribedEvents: Array<IndexUnsubscribedEvent>;
  subscriptionApprovedEvent?: Maybe<SubscriptionApprovedEvent>;
  subscriptionApprovedEvents: Array<SubscriptionApprovedEvent>;
  subscriptionDistributionClaimedEvent?: Maybe<SubscriptionDistributionClaimedEvent>;
  subscriptionDistributionClaimedEvents: Array<SubscriptionDistributionClaimedEvent>;
  subscriptionRevokedEvent?: Maybe<SubscriptionRevokedEvent>;
  subscriptionRevokedEvents: Array<SubscriptionRevokedEvent>;
  subscriptionUnitsUpdatedEvent?: Maybe<SubscriptionUnitsUpdatedEvent>;
  subscriptionUnitsUpdatedEvents: Array<SubscriptionUnitsUpdatedEvent>;
  poolCreatedEvent?: Maybe<PoolCreatedEvent>;
  poolCreatedEvents: Array<PoolCreatedEvent>;
  poolConnectionUpdatedEvent?: Maybe<PoolConnectionUpdatedEvent>;
  poolConnectionUpdatedEvents: Array<PoolConnectionUpdatedEvent>;
  bufferAdjustedEvent?: Maybe<BufferAdjustedEvent>;
  bufferAdjustedEvents: Array<BufferAdjustedEvent>;
  instantDistributionUpdatedEvent?: Maybe<InstantDistributionUpdatedEvent>;
  instantDistributionUpdatedEvents: Array<InstantDistributionUpdatedEvent>;
  flowDistributionUpdatedEvent?: Maybe<FlowDistributionUpdatedEvent>;
  flowDistributionUpdatedEvents: Array<FlowDistributionUpdatedEvent>;
  distributionClaimedEvent?: Maybe<DistributionClaimedEvent>;
  distributionClaimedEvents: Array<DistributionClaimedEvent>;
  memberUnitsUpdatedEvent?: Maybe<MemberUnitsUpdatedEvent>;
  memberUnitsUpdatedEvents: Array<MemberUnitsUpdatedEvent>;
  agreementClassRegisteredEvent?: Maybe<AgreementClassRegisteredEvent>;
  agreementClassRegisteredEvents: Array<AgreementClassRegisteredEvent>;
  agreementClassUpdatedEvent?: Maybe<AgreementClassUpdatedEvent>;
  agreementClassUpdatedEvents: Array<AgreementClassUpdatedEvent>;
  appRegisteredEvent?: Maybe<AppRegisteredEvent>;
  appRegisteredEvents: Array<AppRegisteredEvent>;
  governanceReplacedEvent?: Maybe<GovernanceReplacedEvent>;
  governanceReplacedEvents: Array<GovernanceReplacedEvent>;
  jailEvent?: Maybe<JailEvent>;
  jailEvents: Array<JailEvent>;
  superTokenFactoryUpdatedEvent?: Maybe<SuperTokenFactoryUpdatedEvent>;
  superTokenFactoryUpdatedEvents: Array<SuperTokenFactoryUpdatedEvent>;
  superTokenLogicUpdatedEvent?: Maybe<SuperTokenLogicUpdatedEvent>;
  superTokenLogicUpdatedEvents: Array<SuperTokenLogicUpdatedEvent>;
  roleAdminChangedEvent?: Maybe<RoleAdminChangedEvent>;
  roleAdminChangedEvents: Array<RoleAdminChangedEvent>;
  roleGrantedEvent?: Maybe<RoleGrantedEvent>;
  roleGrantedEvents: Array<RoleGrantedEvent>;
  roleRevokedEvent?: Maybe<RoleRevokedEvent>;
  roleRevokedEvents: Array<RoleRevokedEvent>;
  setEvent?: Maybe<SetEvent>;
  setEvents: Array<SetEvent>;
  cfav1LiquidationPeriodChangedEvent?: Maybe<CFAv1LiquidationPeriodChangedEvent>;
  cfav1LiquidationPeriodChangedEvents: Array<CFAv1LiquidationPeriodChangedEvent>;
  configChangedEvent?: Maybe<ConfigChangedEvent>;
  configChangedEvents: Array<ConfigChangedEvent>;
  rewardAddressChangedEvent?: Maybe<RewardAddressChangedEvent>;
  rewardAddressChangedEvents: Array<RewardAddressChangedEvent>;
  pppconfigurationChangedEvent?: Maybe<PPPConfigurationChangedEvent>;
  pppconfigurationChangedEvents: Array<PPPConfigurationChangedEvent>;
  superTokenMinimumDepositChangedEvent?: Maybe<SuperTokenMinimumDepositChangedEvent>;
  superTokenMinimumDepositChangedEvents: Array<SuperTokenMinimumDepositChangedEvent>;
  trustedForwarderChangedEvent?: Maybe<TrustedForwarderChangedEvent>;
  trustedForwarderChangedEvents: Array<TrustedForwarderChangedEvent>;
  agreementLiquidatedByEvent?: Maybe<AgreementLiquidatedByEvent>;
  agreementLiquidatedByEvents: Array<AgreementLiquidatedByEvent>;
  agreementLiquidatedV2Event?: Maybe<AgreementLiquidatedV2Event>;
  agreementLiquidatedV2Events: Array<AgreementLiquidatedV2Event>;
  burnedEvent?: Maybe<BurnedEvent>;
  burnedEvents: Array<BurnedEvent>;
  mintedEvent?: Maybe<MintedEvent>;
  mintedEvents: Array<MintedEvent>;
  sentEvent?: Maybe<SentEvent>;
  sentEvents: Array<SentEvent>;
  transferEvent?: Maybe<TransferEvent>;
  transferEvents: Array<TransferEvent>;
  tokenDowngradedEvent?: Maybe<TokenDowngradedEvent>;
  tokenDowngradedEvents: Array<TokenDowngradedEvent>;
  tokenUpgradedEvent?: Maybe<TokenUpgradedEvent>;
  tokenUpgradedEvents: Array<TokenUpgradedEvent>;
  approvalEvent?: Maybe<ApprovalEvent>;
  approvalEvents: Array<ApprovalEvent>;
  approvalForAllEvent?: Maybe<ApprovalForAllEvent>;
  approvalForAllEvents: Array<ApprovalForAllEvent>;
  metadataUpdateEvent?: Maybe<MetadataUpdateEvent>;
  metadataUpdateEvents: Array<MetadataUpdateEvent>;
  customSuperTokenCreatedEvent?: Maybe<CustomSuperTokenCreatedEvent>;
  customSuperTokenCreatedEvents: Array<CustomSuperTokenCreatedEvent>;
  superTokenCreatedEvent?: Maybe<SuperTokenCreatedEvent>;
  superTokenCreatedEvents: Array<SuperTokenCreatedEvent>;
  superTokenLogicCreatedEvent?: Maybe<SuperTokenLogicCreatedEvent>;
  superTokenLogicCreatedEvents: Array<SuperTokenLogicCreatedEvent>;
  newPICEvent?: Maybe<NewPICEvent>;
  newPICEvents: Array<NewPICEvent>;
  exitRateChangedEvent?: Maybe<ExitRateChangedEvent>;
  exitRateChangedEvents: Array<ExitRateChangedEvent>;
  bondIncreasedEvent?: Maybe<BondIncreasedEvent>;
  bondIncreasedEvents: Array<BondIncreasedEvent>;
  account?: Maybe<Account>;
  accounts: Array<Account>;
  pool?: Maybe<Pool>;
  pools: Array<Pool>;
  poolMember?: Maybe<PoolMember>;
  poolMembers: Array<PoolMember>;
  poolDistributor?: Maybe<PoolDistributor>;
  poolDistributors: Array<PoolDistributor>;
  index?: Maybe<Index>;
  indexes: Array<Index>;
  indexSubscription?: Maybe<IndexSubscription>;
  indexSubscriptions: Array<IndexSubscription>;
  stream?: Maybe<Stream>;
  streams: Array<Stream>;
  flowOperator?: Maybe<FlowOperator>;
  flowOperators: Array<FlowOperator>;
  streamPeriod?: Maybe<StreamPeriod>;
  streamPeriods: Array<StreamPeriod>;
  tokenGovernanceConfig?: Maybe<TokenGovernanceConfig>;
  tokenGovernanceConfigs: Array<TokenGovernanceConfig>;
  streamRevision?: Maybe<StreamRevision>;
  streamRevisions: Array<StreamRevision>;
  token?: Maybe<Token>;
  tokens: Array<Token>;
  resolverEntry?: Maybe<ResolverEntry>;
  resolverEntries: Array<ResolverEntry>;
  accountTokenSnapshot?: Maybe<AccountTokenSnapshot>;
  accountTokenSnapshots: Array<AccountTokenSnapshot>;
  accountTokenSnapshotLog?: Maybe<AccountTokenSnapshotLog>;
  accountTokenSnapshotLogs: Array<AccountTokenSnapshotLog>;
  tokenStatistic?: Maybe<TokenStatistic>;
  tokenStatistics: Array<TokenStatistic>;
  tokenStatisticLog?: Maybe<TokenStatisticLog>;
  tokenStatisticLogs: Array<TokenStatisticLog>;
  sfmeta?: Maybe<SFMeta>;
  sfmetas: Array<SFMeta>;
  event?: Maybe<Event>;
  events: Array<Event>;
  /** Access to subgraph metadata */
  _meta?: Maybe<_Meta_>;
};

export type QueryflowUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryflowUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<FlowUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<FlowUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryflowOperatorUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryflowOperatorUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<FlowOperatorUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<FlowOperatorUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryindexCreatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryindexCreatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<IndexCreatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<IndexCreatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryindexDistributionClaimedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryindexDistributionClaimedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<IndexDistributionClaimedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<IndexDistributionClaimedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryindexUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryindexUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<IndexUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<IndexUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryindexSubscribedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryindexSubscribedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<IndexSubscribedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<IndexSubscribedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryindexUnitsUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryindexUnitsUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<IndexUnitsUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<IndexUnitsUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryindexUnsubscribedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryindexUnsubscribedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<IndexUnsubscribedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<IndexUnsubscribedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysubscriptionApprovedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysubscriptionApprovedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SubscriptionApprovedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SubscriptionApprovedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysubscriptionDistributionClaimedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysubscriptionDistributionClaimedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SubscriptionDistributionClaimedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SubscriptionDistributionClaimedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysubscriptionRevokedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysubscriptionRevokedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SubscriptionRevokedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SubscriptionRevokedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysubscriptionUnitsUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysubscriptionUnitsUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SubscriptionUnitsUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SubscriptionUnitsUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerypoolCreatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerypoolCreatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<PoolCreatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<PoolCreatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerypoolConnectionUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerypoolConnectionUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<PoolConnectionUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<PoolConnectionUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerybufferAdjustedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerybufferAdjustedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<BufferAdjustedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<BufferAdjustedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryinstantDistributionUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryinstantDistributionUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<InstantDistributionUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<InstantDistributionUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryflowDistributionUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryflowDistributionUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<FlowDistributionUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<FlowDistributionUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerydistributionClaimedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerydistributionClaimedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<DistributionClaimedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<DistributionClaimedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerymemberUnitsUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerymemberUnitsUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<MemberUnitsUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<MemberUnitsUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryagreementClassRegisteredEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryagreementClassRegisteredEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<AgreementClassRegisteredEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<AgreementClassRegisteredEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryagreementClassUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryagreementClassUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<AgreementClassUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<AgreementClassUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryappRegisteredEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryappRegisteredEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<AppRegisteredEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<AppRegisteredEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerygovernanceReplacedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerygovernanceReplacedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<GovernanceReplacedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<GovernanceReplacedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryjailEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryjailEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<JailEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<JailEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysuperTokenFactoryUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysuperTokenFactoryUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SuperTokenFactoryUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SuperTokenFactoryUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysuperTokenLogicUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysuperTokenLogicUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SuperTokenLogicUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SuperTokenLogicUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryroleAdminChangedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryroleAdminChangedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<RoleAdminChangedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<RoleAdminChangedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryroleGrantedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryroleGrantedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<RoleGrantedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<RoleGrantedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryroleRevokedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryroleRevokedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<RoleRevokedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<RoleRevokedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysetEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysetEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SetEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SetEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type Querycfav1LiquidationPeriodChangedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type Querycfav1LiquidationPeriodChangedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<CFAv1LiquidationPeriodChangedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<CFAv1LiquidationPeriodChangedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryconfigChangedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryconfigChangedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<ConfigChangedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<ConfigChangedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryrewardAddressChangedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryrewardAddressChangedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<RewardAddressChangedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<RewardAddressChangedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerypppconfigurationChangedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerypppconfigurationChangedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<PPPConfigurationChangedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<PPPConfigurationChangedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysuperTokenMinimumDepositChangedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysuperTokenMinimumDepositChangedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SuperTokenMinimumDepositChangedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SuperTokenMinimumDepositChangedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerytrustedForwarderChangedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerytrustedForwarderChangedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<TrustedForwarderChangedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<TrustedForwarderChangedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryagreementLiquidatedByEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryagreementLiquidatedByEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<AgreementLiquidatedByEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<AgreementLiquidatedByEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryagreementLiquidatedV2EventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryagreementLiquidatedV2EventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<AgreementLiquidatedV2Event_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<AgreementLiquidatedV2Event_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryburnedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryburnedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<BurnedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<BurnedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerymintedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerymintedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<MintedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<MintedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysentEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysentEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SentEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SentEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerytransferEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerytransferEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<TransferEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<TransferEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerytokenDowngradedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerytokenDowngradedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<TokenDowngradedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<TokenDowngradedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerytokenUpgradedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerytokenUpgradedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<TokenUpgradedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<TokenUpgradedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryapprovalEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryapprovalEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<ApprovalEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<ApprovalEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryapprovalForAllEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryapprovalForAllEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<ApprovalForAllEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<ApprovalForAllEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerymetadataUpdateEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerymetadataUpdateEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<MetadataUpdateEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<MetadataUpdateEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerycustomSuperTokenCreatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerycustomSuperTokenCreatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<CustomSuperTokenCreatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<CustomSuperTokenCreatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysuperTokenCreatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysuperTokenCreatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SuperTokenCreatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SuperTokenCreatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysuperTokenLogicCreatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysuperTokenLogicCreatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SuperTokenLogicCreatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SuperTokenLogicCreatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerynewPICEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerynewPICEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<NewPICEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<NewPICEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryexitRateChangedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryexitRateChangedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<ExitRateChangedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<ExitRateChangedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerybondIncreasedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerybondIncreasedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<BondIncreasedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<BondIncreasedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryaccountArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryaccountsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<Account_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<Account_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerypoolArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerypoolsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<Pool_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<Pool_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerypoolMemberArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerypoolMembersArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<PoolMember_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<PoolMember_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerypoolDistributorArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerypoolDistributorsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<PoolDistributor_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<PoolDistributor_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryindexArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryindexesArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<Index_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<Index_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryindexSubscriptionArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryindexSubscriptionsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<IndexSubscription_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<IndexSubscription_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerystreamArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerystreamsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<Stream_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<Stream_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryflowOperatorArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryflowOperatorsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<FlowOperator_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<FlowOperator_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerystreamPeriodArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerystreamPeriodsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<StreamPeriod_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<StreamPeriod_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerytokenGovernanceConfigArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerytokenGovernanceConfigsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<TokenGovernanceConfig_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<TokenGovernanceConfig_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerystreamRevisionArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerystreamRevisionsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<StreamRevision_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<StreamRevision_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerytokenArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerytokensArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<Token_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<Token_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryresolverEntryArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryresolverEntriesArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<ResolverEntry_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<ResolverEntry_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryaccountTokenSnapshotArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryaccountTokenSnapshotsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<AccountTokenSnapshot_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<AccountTokenSnapshot_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryaccountTokenSnapshotLogArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryaccountTokenSnapshotLogsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<AccountTokenSnapshotLog_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<AccountTokenSnapshotLog_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerytokenStatisticArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerytokenStatisticsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<TokenStatistic_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<TokenStatistic_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerytokenStatisticLogArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerytokenStatisticLogsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<TokenStatisticLog_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<TokenStatisticLog_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysfmetaArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerysfmetasArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SFMeta_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SFMeta_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryeventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryeventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<Event_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<Event_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type Query_metaArgs = {
  block?: InputMaybe<Block_height>;
};

export type ResolverEntry = {
  /**
   * ID: the keccak256 hash of the set name
   *
   */
  id: Scalars["ID"];
  createdAtTimestamp: Scalars["BigInt"];
  createdAtBlockNumber: Scalars["BigInt"];
  updatedAtTimestamp: Scalars["BigInt"];
  updatedAtBlockNumber: Scalars["BigInt"];
  targetAddress: Scalars["Bytes"];
  isToken: Scalars["Boolean"];
  isListed: Scalars["Boolean"];
  setEvents: Array<SetEvent>;
};

export type ResolverEntrysetEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SetEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SetEvent_filter>;
};

export type ResolverEntry_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  createdAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  targetAddress?: InputMaybe<Scalars["Bytes"]>;
  targetAddress_not?: InputMaybe<Scalars["Bytes"]>;
  targetAddress_gt?: InputMaybe<Scalars["Bytes"]>;
  targetAddress_lt?: InputMaybe<Scalars["Bytes"]>;
  targetAddress_gte?: InputMaybe<Scalars["Bytes"]>;
  targetAddress_lte?: InputMaybe<Scalars["Bytes"]>;
  targetAddress_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  targetAddress_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  targetAddress_contains?: InputMaybe<Scalars["Bytes"]>;
  targetAddress_not_contains?: InputMaybe<Scalars["Bytes"]>;
  isToken?: InputMaybe<Scalars["Boolean"]>;
  isToken_not?: InputMaybe<Scalars["Boolean"]>;
  isToken_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  isToken_not_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  isListed?: InputMaybe<Scalars["Boolean"]>;
  isListed_not?: InputMaybe<Scalars["Boolean"]>;
  isListed_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  isListed_not_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  setEvents_?: InputMaybe<SetEvent_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<ResolverEntry_filter>>>;
  or?: InputMaybe<Array<InputMaybe<ResolverEntry_filter>>>;
};

export type ResolverEntry_orderBy =
  | "id"
  | "createdAtTimestamp"
  | "createdAtBlockNumber"
  | "updatedAtTimestamp"
  | "updatedAtBlockNumber"
  | "targetAddress"
  | "isToken"
  | "isListed"
  | "setEvents";

export type RewardAddressChangedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * The address of the governance contract the event was emitted from.
   *
   */
  governanceAddress: Scalars["Bytes"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `governanceAddress`
   * addresses[1] = `host`
   * addresses[2] = `superToken`
   * addresses[3] = `rewardAddress`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  host: Scalars["Bytes"];
  superToken: Scalars["Bytes"];
  isKeySet: Scalars["Boolean"];
  rewardAddress: Scalars["Bytes"];
};

export type RewardAddressChangedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  governanceAddress?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_not?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_gt?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_lt?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_gte?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_lte?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  governanceAddress_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  governanceAddress_contains?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_not_contains?: InputMaybe<Scalars["Bytes"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  host?: InputMaybe<Scalars["Bytes"]>;
  host_not?: InputMaybe<Scalars["Bytes"]>;
  host_gt?: InputMaybe<Scalars["Bytes"]>;
  host_lt?: InputMaybe<Scalars["Bytes"]>;
  host_gte?: InputMaybe<Scalars["Bytes"]>;
  host_lte?: InputMaybe<Scalars["Bytes"]>;
  host_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  host_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  host_contains?: InputMaybe<Scalars["Bytes"]>;
  host_not_contains?: InputMaybe<Scalars["Bytes"]>;
  superToken?: InputMaybe<Scalars["Bytes"]>;
  superToken_not?: InputMaybe<Scalars["Bytes"]>;
  superToken_gt?: InputMaybe<Scalars["Bytes"]>;
  superToken_lt?: InputMaybe<Scalars["Bytes"]>;
  superToken_gte?: InputMaybe<Scalars["Bytes"]>;
  superToken_lte?: InputMaybe<Scalars["Bytes"]>;
  superToken_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  superToken_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  superToken_contains?: InputMaybe<Scalars["Bytes"]>;
  superToken_not_contains?: InputMaybe<Scalars["Bytes"]>;
  isKeySet?: InputMaybe<Scalars["Boolean"]>;
  isKeySet_not?: InputMaybe<Scalars["Boolean"]>;
  isKeySet_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  isKeySet_not_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  rewardAddress?: InputMaybe<Scalars["Bytes"]>;
  rewardAddress_not?: InputMaybe<Scalars["Bytes"]>;
  rewardAddress_gt?: InputMaybe<Scalars["Bytes"]>;
  rewardAddress_lt?: InputMaybe<Scalars["Bytes"]>;
  rewardAddress_gte?: InputMaybe<Scalars["Bytes"]>;
  rewardAddress_lte?: InputMaybe<Scalars["Bytes"]>;
  rewardAddress_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  rewardAddress_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  rewardAddress_contains?: InputMaybe<Scalars["Bytes"]>;
  rewardAddress_not_contains?: InputMaybe<Scalars["Bytes"]>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<RewardAddressChangedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<RewardAddressChangedEvent_filter>>>;
};

export type RewardAddressChangedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "governanceAddress"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "host"
  | "superToken"
  | "isKeySet"
  | "rewardAddress";

export type RoleAdminChangedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `previousAdminRole`
   * addresses[1] = `newAdminRole`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  role: Scalars["Bytes"];
  previousAdminRole: Scalars["Bytes"];
  newAdminRole: Scalars["Bytes"];
};

export type RoleAdminChangedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  role?: InputMaybe<Scalars["Bytes"]>;
  role_not?: InputMaybe<Scalars["Bytes"]>;
  role_gt?: InputMaybe<Scalars["Bytes"]>;
  role_lt?: InputMaybe<Scalars["Bytes"]>;
  role_gte?: InputMaybe<Scalars["Bytes"]>;
  role_lte?: InputMaybe<Scalars["Bytes"]>;
  role_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  role_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  role_contains?: InputMaybe<Scalars["Bytes"]>;
  role_not_contains?: InputMaybe<Scalars["Bytes"]>;
  previousAdminRole?: InputMaybe<Scalars["Bytes"]>;
  previousAdminRole_not?: InputMaybe<Scalars["Bytes"]>;
  previousAdminRole_gt?: InputMaybe<Scalars["Bytes"]>;
  previousAdminRole_lt?: InputMaybe<Scalars["Bytes"]>;
  previousAdminRole_gte?: InputMaybe<Scalars["Bytes"]>;
  previousAdminRole_lte?: InputMaybe<Scalars["Bytes"]>;
  previousAdminRole_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  previousAdminRole_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  previousAdminRole_contains?: InputMaybe<Scalars["Bytes"]>;
  previousAdminRole_not_contains?: InputMaybe<Scalars["Bytes"]>;
  newAdminRole?: InputMaybe<Scalars["Bytes"]>;
  newAdminRole_not?: InputMaybe<Scalars["Bytes"]>;
  newAdminRole_gt?: InputMaybe<Scalars["Bytes"]>;
  newAdminRole_lt?: InputMaybe<Scalars["Bytes"]>;
  newAdminRole_gte?: InputMaybe<Scalars["Bytes"]>;
  newAdminRole_lte?: InputMaybe<Scalars["Bytes"]>;
  newAdminRole_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  newAdminRole_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  newAdminRole_contains?: InputMaybe<Scalars["Bytes"]>;
  newAdminRole_not_contains?: InputMaybe<Scalars["Bytes"]>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<RoleAdminChangedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<RoleAdminChangedEvent_filter>>>;
};

export type RoleAdminChangedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "role"
  | "previousAdminRole"
  | "newAdminRole";

export type RoleGrantedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `account`
   * addresses[1] = `sender`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  role: Scalars["Bytes"];
  account: Scalars["Bytes"];
  sender: Scalars["Bytes"];
};

export type RoleGrantedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  role?: InputMaybe<Scalars["Bytes"]>;
  role_not?: InputMaybe<Scalars["Bytes"]>;
  role_gt?: InputMaybe<Scalars["Bytes"]>;
  role_lt?: InputMaybe<Scalars["Bytes"]>;
  role_gte?: InputMaybe<Scalars["Bytes"]>;
  role_lte?: InputMaybe<Scalars["Bytes"]>;
  role_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  role_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  role_contains?: InputMaybe<Scalars["Bytes"]>;
  role_not_contains?: InputMaybe<Scalars["Bytes"]>;
  account?: InputMaybe<Scalars["Bytes"]>;
  account_not?: InputMaybe<Scalars["Bytes"]>;
  account_gt?: InputMaybe<Scalars["Bytes"]>;
  account_lt?: InputMaybe<Scalars["Bytes"]>;
  account_gte?: InputMaybe<Scalars["Bytes"]>;
  account_lte?: InputMaybe<Scalars["Bytes"]>;
  account_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  account_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  account_contains?: InputMaybe<Scalars["Bytes"]>;
  account_not_contains?: InputMaybe<Scalars["Bytes"]>;
  sender?: InputMaybe<Scalars["Bytes"]>;
  sender_not?: InputMaybe<Scalars["Bytes"]>;
  sender_gt?: InputMaybe<Scalars["Bytes"]>;
  sender_lt?: InputMaybe<Scalars["Bytes"]>;
  sender_gte?: InputMaybe<Scalars["Bytes"]>;
  sender_lte?: InputMaybe<Scalars["Bytes"]>;
  sender_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  sender_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  sender_contains?: InputMaybe<Scalars["Bytes"]>;
  sender_not_contains?: InputMaybe<Scalars["Bytes"]>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<RoleGrantedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<RoleGrantedEvent_filter>>>;
};

export type RoleGrantedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "role"
  | "account"
  | "sender";

export type RoleRevokedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `account`
   * addresses[1] = `sender`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  role: Scalars["Bytes"];
  account: Scalars["Bytes"];
  sender: Scalars["Bytes"];
};

export type RoleRevokedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  role?: InputMaybe<Scalars["Bytes"]>;
  role_not?: InputMaybe<Scalars["Bytes"]>;
  role_gt?: InputMaybe<Scalars["Bytes"]>;
  role_lt?: InputMaybe<Scalars["Bytes"]>;
  role_gte?: InputMaybe<Scalars["Bytes"]>;
  role_lte?: InputMaybe<Scalars["Bytes"]>;
  role_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  role_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  role_contains?: InputMaybe<Scalars["Bytes"]>;
  role_not_contains?: InputMaybe<Scalars["Bytes"]>;
  account?: InputMaybe<Scalars["Bytes"]>;
  account_not?: InputMaybe<Scalars["Bytes"]>;
  account_gt?: InputMaybe<Scalars["Bytes"]>;
  account_lt?: InputMaybe<Scalars["Bytes"]>;
  account_gte?: InputMaybe<Scalars["Bytes"]>;
  account_lte?: InputMaybe<Scalars["Bytes"]>;
  account_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  account_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  account_contains?: InputMaybe<Scalars["Bytes"]>;
  account_not_contains?: InputMaybe<Scalars["Bytes"]>;
  sender?: InputMaybe<Scalars["Bytes"]>;
  sender_not?: InputMaybe<Scalars["Bytes"]>;
  sender_gt?: InputMaybe<Scalars["Bytes"]>;
  sender_lt?: InputMaybe<Scalars["Bytes"]>;
  sender_gte?: InputMaybe<Scalars["Bytes"]>;
  sender_lte?: InputMaybe<Scalars["Bytes"]>;
  sender_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  sender_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  sender_contains?: InputMaybe<Scalars["Bytes"]>;
  sender_not_contains?: InputMaybe<Scalars["Bytes"]>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<RoleRevokedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<RoleRevokedEvent_filter>>>;
};

export type RoleRevokedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "role"
  | "account"
  | "sender";

export type SFMeta = {
  /**
   * The id is the commit hash.
   *
   */
  id: Scalars["ID"];
  timestamp: Scalars["BigInt"];
  blockNumber: Scalars["BigInt"];
  /**
   * Whether the branch is feature/dev/v1.
   *
   */
  configuration: Scalars["String"];
  /**
   * The branch the current deployment is coming from.
   *
   */
  branch: Scalars["String"];
  /**
   * The subgraph package.json semver version of the current deployment.
   *
   */
  packageVersion: Scalars["String"];
};

export type SFMeta_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  configuration?: InputMaybe<Scalars["String"]>;
  configuration_not?: InputMaybe<Scalars["String"]>;
  configuration_gt?: InputMaybe<Scalars["String"]>;
  configuration_lt?: InputMaybe<Scalars["String"]>;
  configuration_gte?: InputMaybe<Scalars["String"]>;
  configuration_lte?: InputMaybe<Scalars["String"]>;
  configuration_in?: InputMaybe<Array<Scalars["String"]>>;
  configuration_not_in?: InputMaybe<Array<Scalars["String"]>>;
  configuration_contains?: InputMaybe<Scalars["String"]>;
  configuration_contains_nocase?: InputMaybe<Scalars["String"]>;
  configuration_not_contains?: InputMaybe<Scalars["String"]>;
  configuration_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  configuration_starts_with?: InputMaybe<Scalars["String"]>;
  configuration_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  configuration_not_starts_with?: InputMaybe<Scalars["String"]>;
  configuration_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  configuration_ends_with?: InputMaybe<Scalars["String"]>;
  configuration_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  configuration_not_ends_with?: InputMaybe<Scalars["String"]>;
  configuration_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  branch?: InputMaybe<Scalars["String"]>;
  branch_not?: InputMaybe<Scalars["String"]>;
  branch_gt?: InputMaybe<Scalars["String"]>;
  branch_lt?: InputMaybe<Scalars["String"]>;
  branch_gte?: InputMaybe<Scalars["String"]>;
  branch_lte?: InputMaybe<Scalars["String"]>;
  branch_in?: InputMaybe<Array<Scalars["String"]>>;
  branch_not_in?: InputMaybe<Array<Scalars["String"]>>;
  branch_contains?: InputMaybe<Scalars["String"]>;
  branch_contains_nocase?: InputMaybe<Scalars["String"]>;
  branch_not_contains?: InputMaybe<Scalars["String"]>;
  branch_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  branch_starts_with?: InputMaybe<Scalars["String"]>;
  branch_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  branch_not_starts_with?: InputMaybe<Scalars["String"]>;
  branch_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  branch_ends_with?: InputMaybe<Scalars["String"]>;
  branch_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  branch_not_ends_with?: InputMaybe<Scalars["String"]>;
  branch_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  packageVersion?: InputMaybe<Scalars["String"]>;
  packageVersion_not?: InputMaybe<Scalars["String"]>;
  packageVersion_gt?: InputMaybe<Scalars["String"]>;
  packageVersion_lt?: InputMaybe<Scalars["String"]>;
  packageVersion_gte?: InputMaybe<Scalars["String"]>;
  packageVersion_lte?: InputMaybe<Scalars["String"]>;
  packageVersion_in?: InputMaybe<Array<Scalars["String"]>>;
  packageVersion_not_in?: InputMaybe<Array<Scalars["String"]>>;
  packageVersion_contains?: InputMaybe<Scalars["String"]>;
  packageVersion_contains_nocase?: InputMaybe<Scalars["String"]>;
  packageVersion_not_contains?: InputMaybe<Scalars["String"]>;
  packageVersion_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  packageVersion_starts_with?: InputMaybe<Scalars["String"]>;
  packageVersion_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  packageVersion_not_starts_with?: InputMaybe<Scalars["String"]>;
  packageVersion_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  packageVersion_ends_with?: InputMaybe<Scalars["String"]>;
  packageVersion_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  packageVersion_not_ends_with?: InputMaybe<Scalars["String"]>;
  packageVersion_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<SFMeta_filter>>>;
  or?: InputMaybe<Array<InputMaybe<SFMeta_filter>>>;
};

export type SFMeta_orderBy =
  | "id"
  | "timestamp"
  | "blockNumber"
  | "configuration"
  | "branch"
  | "packageVersion";

export type SentEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `operator`
   * addresses[2] = `from`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  operator: Scalars["Bytes"];
  from: Scalars["Bytes"];
  to: Scalars["Bytes"];
  token: Scalars["Bytes"];
  amount: Scalars["BigInt"];
  data: Scalars["Bytes"];
  operatorData: Scalars["Bytes"];
};

export type SentEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  operator?: InputMaybe<Scalars["Bytes"]>;
  operator_not?: InputMaybe<Scalars["Bytes"]>;
  operator_gt?: InputMaybe<Scalars["Bytes"]>;
  operator_lt?: InputMaybe<Scalars["Bytes"]>;
  operator_gte?: InputMaybe<Scalars["Bytes"]>;
  operator_lte?: InputMaybe<Scalars["Bytes"]>;
  operator_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  operator_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  operator_contains?: InputMaybe<Scalars["Bytes"]>;
  operator_not_contains?: InputMaybe<Scalars["Bytes"]>;
  from?: InputMaybe<Scalars["Bytes"]>;
  from_not?: InputMaybe<Scalars["Bytes"]>;
  from_gt?: InputMaybe<Scalars["Bytes"]>;
  from_lt?: InputMaybe<Scalars["Bytes"]>;
  from_gte?: InputMaybe<Scalars["Bytes"]>;
  from_lte?: InputMaybe<Scalars["Bytes"]>;
  from_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  from_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  from_contains?: InputMaybe<Scalars["Bytes"]>;
  from_not_contains?: InputMaybe<Scalars["Bytes"]>;
  to?: InputMaybe<Scalars["Bytes"]>;
  to_not?: InputMaybe<Scalars["Bytes"]>;
  to_gt?: InputMaybe<Scalars["Bytes"]>;
  to_lt?: InputMaybe<Scalars["Bytes"]>;
  to_gte?: InputMaybe<Scalars["Bytes"]>;
  to_lte?: InputMaybe<Scalars["Bytes"]>;
  to_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  to_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  to_contains?: InputMaybe<Scalars["Bytes"]>;
  to_not_contains?: InputMaybe<Scalars["Bytes"]>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  amount?: InputMaybe<Scalars["BigInt"]>;
  amount_not?: InputMaybe<Scalars["BigInt"]>;
  amount_gt?: InputMaybe<Scalars["BigInt"]>;
  amount_lt?: InputMaybe<Scalars["BigInt"]>;
  amount_gte?: InputMaybe<Scalars["BigInt"]>;
  amount_lte?: InputMaybe<Scalars["BigInt"]>;
  amount_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  amount_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  data?: InputMaybe<Scalars["Bytes"]>;
  data_not?: InputMaybe<Scalars["Bytes"]>;
  data_gt?: InputMaybe<Scalars["Bytes"]>;
  data_lt?: InputMaybe<Scalars["Bytes"]>;
  data_gte?: InputMaybe<Scalars["Bytes"]>;
  data_lte?: InputMaybe<Scalars["Bytes"]>;
  data_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  data_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  data_contains?: InputMaybe<Scalars["Bytes"]>;
  data_not_contains?: InputMaybe<Scalars["Bytes"]>;
  operatorData?: InputMaybe<Scalars["Bytes"]>;
  operatorData_not?: InputMaybe<Scalars["Bytes"]>;
  operatorData_gt?: InputMaybe<Scalars["Bytes"]>;
  operatorData_lt?: InputMaybe<Scalars["Bytes"]>;
  operatorData_gte?: InputMaybe<Scalars["Bytes"]>;
  operatorData_lte?: InputMaybe<Scalars["Bytes"]>;
  operatorData_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  operatorData_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  operatorData_contains?: InputMaybe<Scalars["Bytes"]>;
  operatorData_not_contains?: InputMaybe<Scalars["Bytes"]>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<SentEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<SentEvent_filter>>>;
};

export type SentEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "operator"
  | "from"
  | "to"
  | "token"
  | "amount"
  | "data"
  | "operatorData";

export type SetEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Empty addresses array.
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  /**
   * Because the name property is indexed, the
   * returned value will be a keccak256 hash
   * of the string.
   *
   */
  hashedName: Scalars["Bytes"];
  target: Scalars["Bytes"];
  resolverEntry: ResolverEntry;
};

export type SetEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  hashedName?: InputMaybe<Scalars["Bytes"]>;
  hashedName_not?: InputMaybe<Scalars["Bytes"]>;
  hashedName_gt?: InputMaybe<Scalars["Bytes"]>;
  hashedName_lt?: InputMaybe<Scalars["Bytes"]>;
  hashedName_gte?: InputMaybe<Scalars["Bytes"]>;
  hashedName_lte?: InputMaybe<Scalars["Bytes"]>;
  hashedName_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  hashedName_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  hashedName_contains?: InputMaybe<Scalars["Bytes"]>;
  hashedName_not_contains?: InputMaybe<Scalars["Bytes"]>;
  target?: InputMaybe<Scalars["Bytes"]>;
  target_not?: InputMaybe<Scalars["Bytes"]>;
  target_gt?: InputMaybe<Scalars["Bytes"]>;
  target_lt?: InputMaybe<Scalars["Bytes"]>;
  target_gte?: InputMaybe<Scalars["Bytes"]>;
  target_lte?: InputMaybe<Scalars["Bytes"]>;
  target_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  target_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  target_contains?: InputMaybe<Scalars["Bytes"]>;
  target_not_contains?: InputMaybe<Scalars["Bytes"]>;
  resolverEntry?: InputMaybe<Scalars["String"]>;
  resolverEntry_not?: InputMaybe<Scalars["String"]>;
  resolverEntry_gt?: InputMaybe<Scalars["String"]>;
  resolverEntry_lt?: InputMaybe<Scalars["String"]>;
  resolverEntry_gte?: InputMaybe<Scalars["String"]>;
  resolverEntry_lte?: InputMaybe<Scalars["String"]>;
  resolverEntry_in?: InputMaybe<Array<Scalars["String"]>>;
  resolverEntry_not_in?: InputMaybe<Array<Scalars["String"]>>;
  resolverEntry_contains?: InputMaybe<Scalars["String"]>;
  resolverEntry_contains_nocase?: InputMaybe<Scalars["String"]>;
  resolverEntry_not_contains?: InputMaybe<Scalars["String"]>;
  resolverEntry_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  resolverEntry_starts_with?: InputMaybe<Scalars["String"]>;
  resolverEntry_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  resolverEntry_not_starts_with?: InputMaybe<Scalars["String"]>;
  resolverEntry_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  resolverEntry_ends_with?: InputMaybe<Scalars["String"]>;
  resolverEntry_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  resolverEntry_not_ends_with?: InputMaybe<Scalars["String"]>;
  resolverEntry_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  resolverEntry_?: InputMaybe<ResolverEntry_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<SetEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<SetEvent_filter>>>;
};

export type SetEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "hashedName"
  | "target"
  | "resolverEntry"
  | "resolverEntry__id"
  | "resolverEntry__createdAtTimestamp"
  | "resolverEntry__createdAtBlockNumber"
  | "resolverEntry__updatedAtTimestamp"
  | "resolverEntry__updatedAtBlockNumber"
  | "resolverEntry__targetAddress"
  | "resolverEntry__isToken"
  | "resolverEntry__isListed";

/**
 * Stream: A higher order entity that represents the lifetime of a stream between a `sender` and a `receiver`.
 * A account can start a stream, update the flow rate, but when they close it, it is considered "dead".
 * The next stream you create with the same `sender` and `receiver` will create a new stream entity.
 * Therefore, multiple stream entities can be created between the same `sender` and `receiver`.
 *
 */
export type Stream = {
  /**
   * ID composed of: senderAddress-receiverAddress-tokenAddress-revisionIndex
   *
   */
  id: Scalars["ID"];
  createdAtTimestamp: Scalars["BigInt"];
  createdAtBlockNumber: Scalars["BigInt"];
  updatedAtTimestamp: Scalars["BigInt"];
  updatedAtBlockNumber: Scalars["BigInt"];
  currentFlowRate: Scalars["BigInt"];
  deposit: Scalars["BigInt"];
  /**
   * The amount streamed until `updatedAtTimestamp`/`updatedAtBlock`.
   * The formula to get the current streamed amount is:
   * `streamedUntilUpdatedAt + ((currentTime in seconds) - updatedAtTimestamp) * currentFlowRate`.
   *
   */
  streamedUntilUpdatedAt: Scalars["BigInt"];
  token: Token;
  sender: Account;
  receiver: Account;
  /**
   * The `userData` stored on the Stream is the last `userData` that was set in a `FlowUpdatedEvent`,
   * for this particular stream. To see the historical `userData` for this stream, you can query the `flowUpdatedEvents` field.
   *
   */
  userData: Scalars["Bytes"];
  flowUpdatedEvents: Array<FlowUpdatedEvent>;
  streamPeriods: Array<StreamPeriod>;
};

/**
 * Stream: A higher order entity that represents the lifetime of a stream between a `sender` and a `receiver`.
 * A account can start a stream, update the flow rate, but when they close it, it is considered "dead".
 * The next stream you create with the same `sender` and `receiver` will create a new stream entity.
 * Therefore, multiple stream entities can be created between the same `sender` and `receiver`.
 *
 */
export type StreamflowUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<FlowUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<FlowUpdatedEvent_filter>;
};

/**
 * Stream: A higher order entity that represents the lifetime of a stream between a `sender` and a `receiver`.
 * A account can start a stream, update the flow rate, but when they close it, it is considered "dead".
 * The next stream you create with the same `sender` and `receiver` will create a new stream entity.
 * Therefore, multiple stream entities can be created between the same `sender` and `receiver`.
 *
 */
export type StreamstreamPeriodsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<StreamPeriod_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<StreamPeriod_filter>;
};

/**
 * StreamPeriod: A higher order entity that represents a period of time in a Stream with a constant flowRate.
 *
 */
export type StreamPeriod = {
  /**
   * ID composed of: streamId - periodRevisionIndex
   *
   */
  id: Scalars["ID"];
  stream: Stream;
  sender: Account;
  receiver: Account;
  token: Token;
  flowRate: Scalars["BigInt"];
  deposit: Scalars["BigInt"];
  startedAtTimestamp: Scalars["BigInt"];
  startedAtBlockNumber: Scalars["BigInt"];
  startedAtEvent: FlowUpdatedEvent;
  /**
   * Following values are null until the StreamPeriod is terminated
   *
   */
  stoppedAtTimestamp?: Maybe<Scalars["BigInt"]>;
  stoppedAtBlockNumber?: Maybe<Scalars["BigInt"]>;
  stoppedAtEvent?: Maybe<FlowUpdatedEvent>;
  totalAmountStreamed?: Maybe<Scalars["BigInt"]>;
};

export type StreamPeriod_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  stream?: InputMaybe<Scalars["String"]>;
  stream_not?: InputMaybe<Scalars["String"]>;
  stream_gt?: InputMaybe<Scalars["String"]>;
  stream_lt?: InputMaybe<Scalars["String"]>;
  stream_gte?: InputMaybe<Scalars["String"]>;
  stream_lte?: InputMaybe<Scalars["String"]>;
  stream_in?: InputMaybe<Array<Scalars["String"]>>;
  stream_not_in?: InputMaybe<Array<Scalars["String"]>>;
  stream_contains?: InputMaybe<Scalars["String"]>;
  stream_contains_nocase?: InputMaybe<Scalars["String"]>;
  stream_not_contains?: InputMaybe<Scalars["String"]>;
  stream_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  stream_starts_with?: InputMaybe<Scalars["String"]>;
  stream_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  stream_not_starts_with?: InputMaybe<Scalars["String"]>;
  stream_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  stream_ends_with?: InputMaybe<Scalars["String"]>;
  stream_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  stream_not_ends_with?: InputMaybe<Scalars["String"]>;
  stream_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  stream_?: InputMaybe<Stream_filter>;
  sender?: InputMaybe<Scalars["String"]>;
  sender_not?: InputMaybe<Scalars["String"]>;
  sender_gt?: InputMaybe<Scalars["String"]>;
  sender_lt?: InputMaybe<Scalars["String"]>;
  sender_gte?: InputMaybe<Scalars["String"]>;
  sender_lte?: InputMaybe<Scalars["String"]>;
  sender_in?: InputMaybe<Array<Scalars["String"]>>;
  sender_not_in?: InputMaybe<Array<Scalars["String"]>>;
  sender_contains?: InputMaybe<Scalars["String"]>;
  sender_contains_nocase?: InputMaybe<Scalars["String"]>;
  sender_not_contains?: InputMaybe<Scalars["String"]>;
  sender_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  sender_starts_with?: InputMaybe<Scalars["String"]>;
  sender_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  sender_not_starts_with?: InputMaybe<Scalars["String"]>;
  sender_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  sender_ends_with?: InputMaybe<Scalars["String"]>;
  sender_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  sender_not_ends_with?: InputMaybe<Scalars["String"]>;
  sender_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  sender_?: InputMaybe<Account_filter>;
  receiver?: InputMaybe<Scalars["String"]>;
  receiver_not?: InputMaybe<Scalars["String"]>;
  receiver_gt?: InputMaybe<Scalars["String"]>;
  receiver_lt?: InputMaybe<Scalars["String"]>;
  receiver_gte?: InputMaybe<Scalars["String"]>;
  receiver_lte?: InputMaybe<Scalars["String"]>;
  receiver_in?: InputMaybe<Array<Scalars["String"]>>;
  receiver_not_in?: InputMaybe<Array<Scalars["String"]>>;
  receiver_contains?: InputMaybe<Scalars["String"]>;
  receiver_contains_nocase?: InputMaybe<Scalars["String"]>;
  receiver_not_contains?: InputMaybe<Scalars["String"]>;
  receiver_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  receiver_starts_with?: InputMaybe<Scalars["String"]>;
  receiver_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  receiver_not_starts_with?: InputMaybe<Scalars["String"]>;
  receiver_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  receiver_ends_with?: InputMaybe<Scalars["String"]>;
  receiver_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  receiver_not_ends_with?: InputMaybe<Scalars["String"]>;
  receiver_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  receiver_?: InputMaybe<Account_filter>;
  token?: InputMaybe<Scalars["String"]>;
  token_not?: InputMaybe<Scalars["String"]>;
  token_gt?: InputMaybe<Scalars["String"]>;
  token_lt?: InputMaybe<Scalars["String"]>;
  token_gte?: InputMaybe<Scalars["String"]>;
  token_lte?: InputMaybe<Scalars["String"]>;
  token_in?: InputMaybe<Array<Scalars["String"]>>;
  token_not_in?: InputMaybe<Array<Scalars["String"]>>;
  token_contains?: InputMaybe<Scalars["String"]>;
  token_contains_nocase?: InputMaybe<Scalars["String"]>;
  token_not_contains?: InputMaybe<Scalars["String"]>;
  token_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  token_starts_with?: InputMaybe<Scalars["String"]>;
  token_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  token_not_starts_with?: InputMaybe<Scalars["String"]>;
  token_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  token_ends_with?: InputMaybe<Scalars["String"]>;
  token_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  token_not_ends_with?: InputMaybe<Scalars["String"]>;
  token_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  token_?: InputMaybe<Token_filter>;
  flowRate?: InputMaybe<Scalars["BigInt"]>;
  flowRate_not?: InputMaybe<Scalars["BigInt"]>;
  flowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  flowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  flowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  flowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  flowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  flowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  deposit?: InputMaybe<Scalars["BigInt"]>;
  deposit_not?: InputMaybe<Scalars["BigInt"]>;
  deposit_gt?: InputMaybe<Scalars["BigInt"]>;
  deposit_lt?: InputMaybe<Scalars["BigInt"]>;
  deposit_gte?: InputMaybe<Scalars["BigInt"]>;
  deposit_lte?: InputMaybe<Scalars["BigInt"]>;
  deposit_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  deposit_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  startedAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  startedAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  startedAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  startedAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  startedAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  startedAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  startedAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  startedAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  startedAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  startedAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  startedAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  startedAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  startedAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  startedAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  startedAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  startedAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  startedAtEvent?: InputMaybe<Scalars["String"]>;
  startedAtEvent_not?: InputMaybe<Scalars["String"]>;
  startedAtEvent_gt?: InputMaybe<Scalars["String"]>;
  startedAtEvent_lt?: InputMaybe<Scalars["String"]>;
  startedAtEvent_gte?: InputMaybe<Scalars["String"]>;
  startedAtEvent_lte?: InputMaybe<Scalars["String"]>;
  startedAtEvent_in?: InputMaybe<Array<Scalars["String"]>>;
  startedAtEvent_not_in?: InputMaybe<Array<Scalars["String"]>>;
  startedAtEvent_contains?: InputMaybe<Scalars["String"]>;
  startedAtEvent_contains_nocase?: InputMaybe<Scalars["String"]>;
  startedAtEvent_not_contains?: InputMaybe<Scalars["String"]>;
  startedAtEvent_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  startedAtEvent_starts_with?: InputMaybe<Scalars["String"]>;
  startedAtEvent_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  startedAtEvent_not_starts_with?: InputMaybe<Scalars["String"]>;
  startedAtEvent_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  startedAtEvent_ends_with?: InputMaybe<Scalars["String"]>;
  startedAtEvent_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  startedAtEvent_not_ends_with?: InputMaybe<Scalars["String"]>;
  startedAtEvent_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  startedAtEvent_?: InputMaybe<FlowUpdatedEvent_filter>;
  stoppedAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  stoppedAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  stoppedAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  stoppedAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  stoppedAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  stoppedAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  stoppedAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  stoppedAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  stoppedAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  stoppedAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  stoppedAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  stoppedAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  stoppedAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  stoppedAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  stoppedAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  stoppedAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  stoppedAtEvent?: InputMaybe<Scalars["String"]>;
  stoppedAtEvent_not?: InputMaybe<Scalars["String"]>;
  stoppedAtEvent_gt?: InputMaybe<Scalars["String"]>;
  stoppedAtEvent_lt?: InputMaybe<Scalars["String"]>;
  stoppedAtEvent_gte?: InputMaybe<Scalars["String"]>;
  stoppedAtEvent_lte?: InputMaybe<Scalars["String"]>;
  stoppedAtEvent_in?: InputMaybe<Array<Scalars["String"]>>;
  stoppedAtEvent_not_in?: InputMaybe<Array<Scalars["String"]>>;
  stoppedAtEvent_contains?: InputMaybe<Scalars["String"]>;
  stoppedAtEvent_contains_nocase?: InputMaybe<Scalars["String"]>;
  stoppedAtEvent_not_contains?: InputMaybe<Scalars["String"]>;
  stoppedAtEvent_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  stoppedAtEvent_starts_with?: InputMaybe<Scalars["String"]>;
  stoppedAtEvent_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  stoppedAtEvent_not_starts_with?: InputMaybe<Scalars["String"]>;
  stoppedAtEvent_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  stoppedAtEvent_ends_with?: InputMaybe<Scalars["String"]>;
  stoppedAtEvent_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  stoppedAtEvent_not_ends_with?: InputMaybe<Scalars["String"]>;
  stoppedAtEvent_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  stoppedAtEvent_?: InputMaybe<FlowUpdatedEvent_filter>;
  totalAmountStreamed?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamed_not?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamed_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamed_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamed_gte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamed_lte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountStreamed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<StreamPeriod_filter>>>;
  or?: InputMaybe<Array<InputMaybe<StreamPeriod_filter>>>;
};

export type StreamPeriod_orderBy =
  | "id"
  | "stream"
  | "stream__id"
  | "stream__createdAtTimestamp"
  | "stream__createdAtBlockNumber"
  | "stream__updatedAtTimestamp"
  | "stream__updatedAtBlockNumber"
  | "stream__currentFlowRate"
  | "stream__deposit"
  | "stream__streamedUntilUpdatedAt"
  | "stream__userData"
  | "sender"
  | "sender__id"
  | "sender__createdAtTimestamp"
  | "sender__createdAtBlockNumber"
  | "sender__updatedAtTimestamp"
  | "sender__updatedAtBlockNumber"
  | "sender__isSuperApp"
  | "receiver"
  | "receiver__id"
  | "receiver__createdAtTimestamp"
  | "receiver__createdAtBlockNumber"
  | "receiver__updatedAtTimestamp"
  | "receiver__updatedAtBlockNumber"
  | "receiver__isSuperApp"
  | "token"
  | "token__id"
  | "token__createdAtTimestamp"
  | "token__createdAtBlockNumber"
  | "token__decimals"
  | "token__name"
  | "token__symbol"
  | "token__isSuperToken"
  | "token__isNativeAssetSuperToken"
  | "token__isListed"
  | "token__underlyingAddress"
  | "flowRate"
  | "deposit"
  | "startedAtTimestamp"
  | "startedAtBlockNumber"
  | "startedAtEvent"
  | "startedAtEvent__id"
  | "startedAtEvent__transactionHash"
  | "startedAtEvent__gasPrice"
  | "startedAtEvent__gasUsed"
  | "startedAtEvent__timestamp"
  | "startedAtEvent__name"
  | "startedAtEvent__blockNumber"
  | "startedAtEvent__logIndex"
  | "startedAtEvent__order"
  | "startedAtEvent__token"
  | "startedAtEvent__sender"
  | "startedAtEvent__receiver"
  | "startedAtEvent__flowOperator"
  | "startedAtEvent__flowRate"
  | "startedAtEvent__totalSenderFlowRate"
  | "startedAtEvent__totalReceiverFlowRate"
  | "startedAtEvent__deposit"
  | "startedAtEvent__userData"
  | "startedAtEvent__oldFlowRate"
  | "startedAtEvent__type"
  | "startedAtEvent__totalAmountStreamedUntilTimestamp"
  | "stoppedAtTimestamp"
  | "stoppedAtBlockNumber"
  | "stoppedAtEvent"
  | "stoppedAtEvent__id"
  | "stoppedAtEvent__transactionHash"
  | "stoppedAtEvent__gasPrice"
  | "stoppedAtEvent__gasUsed"
  | "stoppedAtEvent__timestamp"
  | "stoppedAtEvent__name"
  | "stoppedAtEvent__blockNumber"
  | "stoppedAtEvent__logIndex"
  | "stoppedAtEvent__order"
  | "stoppedAtEvent__token"
  | "stoppedAtEvent__sender"
  | "stoppedAtEvent__receiver"
  | "stoppedAtEvent__flowOperator"
  | "stoppedAtEvent__flowRate"
  | "stoppedAtEvent__totalSenderFlowRate"
  | "stoppedAtEvent__totalReceiverFlowRate"
  | "stoppedAtEvent__deposit"
  | "stoppedAtEvent__userData"
  | "stoppedAtEvent__oldFlowRate"
  | "stoppedAtEvent__type"
  | "stoppedAtEvent__totalAmountStreamedUntilTimestamp"
  | "totalAmountStreamed";

export type StreamRevision = {
  /**
   * ID composed of: keccak256(abi.encode(sender,receiver))-tokenAddress
   *
   */
  id: Scalars["ID"];
  revisionIndex: Scalars["Int"];
  periodRevisionIndex: Scalars["Int"];
  /**
   * The "most recently alive" stream between a sender and receiver.
   * Note: The `revisionIndex` property may not be the same as the `revisionIndex` of `mostRecentStream`. Which means `mostRecentStream` has been closed and no new stream has been opened.
   *
   */
  mostRecentStream: Stream;
};

export type StreamRevision_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  revisionIndex?: InputMaybe<Scalars["Int"]>;
  revisionIndex_not?: InputMaybe<Scalars["Int"]>;
  revisionIndex_gt?: InputMaybe<Scalars["Int"]>;
  revisionIndex_lt?: InputMaybe<Scalars["Int"]>;
  revisionIndex_gte?: InputMaybe<Scalars["Int"]>;
  revisionIndex_lte?: InputMaybe<Scalars["Int"]>;
  revisionIndex_in?: InputMaybe<Array<Scalars["Int"]>>;
  revisionIndex_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  periodRevisionIndex?: InputMaybe<Scalars["Int"]>;
  periodRevisionIndex_not?: InputMaybe<Scalars["Int"]>;
  periodRevisionIndex_gt?: InputMaybe<Scalars["Int"]>;
  periodRevisionIndex_lt?: InputMaybe<Scalars["Int"]>;
  periodRevisionIndex_gte?: InputMaybe<Scalars["Int"]>;
  periodRevisionIndex_lte?: InputMaybe<Scalars["Int"]>;
  periodRevisionIndex_in?: InputMaybe<Array<Scalars["Int"]>>;
  periodRevisionIndex_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  mostRecentStream?: InputMaybe<Scalars["String"]>;
  mostRecentStream_not?: InputMaybe<Scalars["String"]>;
  mostRecentStream_gt?: InputMaybe<Scalars["String"]>;
  mostRecentStream_lt?: InputMaybe<Scalars["String"]>;
  mostRecentStream_gte?: InputMaybe<Scalars["String"]>;
  mostRecentStream_lte?: InputMaybe<Scalars["String"]>;
  mostRecentStream_in?: InputMaybe<Array<Scalars["String"]>>;
  mostRecentStream_not_in?: InputMaybe<Array<Scalars["String"]>>;
  mostRecentStream_contains?: InputMaybe<Scalars["String"]>;
  mostRecentStream_contains_nocase?: InputMaybe<Scalars["String"]>;
  mostRecentStream_not_contains?: InputMaybe<Scalars["String"]>;
  mostRecentStream_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  mostRecentStream_starts_with?: InputMaybe<Scalars["String"]>;
  mostRecentStream_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  mostRecentStream_not_starts_with?: InputMaybe<Scalars["String"]>;
  mostRecentStream_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  mostRecentStream_ends_with?: InputMaybe<Scalars["String"]>;
  mostRecentStream_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  mostRecentStream_not_ends_with?: InputMaybe<Scalars["String"]>;
  mostRecentStream_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  mostRecentStream_?: InputMaybe<Stream_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<StreamRevision_filter>>>;
  or?: InputMaybe<Array<InputMaybe<StreamRevision_filter>>>;
};

export type StreamRevision_orderBy =
  | "id"
  | "revisionIndex"
  | "periodRevisionIndex"
  | "mostRecentStream"
  | "mostRecentStream__id"
  | "mostRecentStream__createdAtTimestamp"
  | "mostRecentStream__createdAtBlockNumber"
  | "mostRecentStream__updatedAtTimestamp"
  | "mostRecentStream__updatedAtBlockNumber"
  | "mostRecentStream__currentFlowRate"
  | "mostRecentStream__deposit"
  | "mostRecentStream__streamedUntilUpdatedAt"
  | "mostRecentStream__userData";

export type Stream_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  createdAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  currentFlowRate?: InputMaybe<Scalars["BigInt"]>;
  currentFlowRate_not?: InputMaybe<Scalars["BigInt"]>;
  currentFlowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  currentFlowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  currentFlowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  currentFlowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  currentFlowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  currentFlowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  deposit?: InputMaybe<Scalars["BigInt"]>;
  deposit_not?: InputMaybe<Scalars["BigInt"]>;
  deposit_gt?: InputMaybe<Scalars["BigInt"]>;
  deposit_lt?: InputMaybe<Scalars["BigInt"]>;
  deposit_gte?: InputMaybe<Scalars["BigInt"]>;
  deposit_lte?: InputMaybe<Scalars["BigInt"]>;
  deposit_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  deposit_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  streamedUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  streamedUntilUpdatedAt_not?: InputMaybe<Scalars["BigInt"]>;
  streamedUntilUpdatedAt_gt?: InputMaybe<Scalars["BigInt"]>;
  streamedUntilUpdatedAt_lt?: InputMaybe<Scalars["BigInt"]>;
  streamedUntilUpdatedAt_gte?: InputMaybe<Scalars["BigInt"]>;
  streamedUntilUpdatedAt_lte?: InputMaybe<Scalars["BigInt"]>;
  streamedUntilUpdatedAt_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  streamedUntilUpdatedAt_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["String"]>;
  token_not?: InputMaybe<Scalars["String"]>;
  token_gt?: InputMaybe<Scalars["String"]>;
  token_lt?: InputMaybe<Scalars["String"]>;
  token_gte?: InputMaybe<Scalars["String"]>;
  token_lte?: InputMaybe<Scalars["String"]>;
  token_in?: InputMaybe<Array<Scalars["String"]>>;
  token_not_in?: InputMaybe<Array<Scalars["String"]>>;
  token_contains?: InputMaybe<Scalars["String"]>;
  token_contains_nocase?: InputMaybe<Scalars["String"]>;
  token_not_contains?: InputMaybe<Scalars["String"]>;
  token_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  token_starts_with?: InputMaybe<Scalars["String"]>;
  token_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  token_not_starts_with?: InputMaybe<Scalars["String"]>;
  token_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  token_ends_with?: InputMaybe<Scalars["String"]>;
  token_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  token_not_ends_with?: InputMaybe<Scalars["String"]>;
  token_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  token_?: InputMaybe<Token_filter>;
  sender?: InputMaybe<Scalars["String"]>;
  sender_not?: InputMaybe<Scalars["String"]>;
  sender_gt?: InputMaybe<Scalars["String"]>;
  sender_lt?: InputMaybe<Scalars["String"]>;
  sender_gte?: InputMaybe<Scalars["String"]>;
  sender_lte?: InputMaybe<Scalars["String"]>;
  sender_in?: InputMaybe<Array<Scalars["String"]>>;
  sender_not_in?: InputMaybe<Array<Scalars["String"]>>;
  sender_contains?: InputMaybe<Scalars["String"]>;
  sender_contains_nocase?: InputMaybe<Scalars["String"]>;
  sender_not_contains?: InputMaybe<Scalars["String"]>;
  sender_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  sender_starts_with?: InputMaybe<Scalars["String"]>;
  sender_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  sender_not_starts_with?: InputMaybe<Scalars["String"]>;
  sender_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  sender_ends_with?: InputMaybe<Scalars["String"]>;
  sender_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  sender_not_ends_with?: InputMaybe<Scalars["String"]>;
  sender_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  sender_?: InputMaybe<Account_filter>;
  receiver?: InputMaybe<Scalars["String"]>;
  receiver_not?: InputMaybe<Scalars["String"]>;
  receiver_gt?: InputMaybe<Scalars["String"]>;
  receiver_lt?: InputMaybe<Scalars["String"]>;
  receiver_gte?: InputMaybe<Scalars["String"]>;
  receiver_lte?: InputMaybe<Scalars["String"]>;
  receiver_in?: InputMaybe<Array<Scalars["String"]>>;
  receiver_not_in?: InputMaybe<Array<Scalars["String"]>>;
  receiver_contains?: InputMaybe<Scalars["String"]>;
  receiver_contains_nocase?: InputMaybe<Scalars["String"]>;
  receiver_not_contains?: InputMaybe<Scalars["String"]>;
  receiver_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  receiver_starts_with?: InputMaybe<Scalars["String"]>;
  receiver_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  receiver_not_starts_with?: InputMaybe<Scalars["String"]>;
  receiver_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  receiver_ends_with?: InputMaybe<Scalars["String"]>;
  receiver_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  receiver_not_ends_with?: InputMaybe<Scalars["String"]>;
  receiver_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  receiver_?: InputMaybe<Account_filter>;
  userData?: InputMaybe<Scalars["Bytes"]>;
  userData_not?: InputMaybe<Scalars["Bytes"]>;
  userData_gt?: InputMaybe<Scalars["Bytes"]>;
  userData_lt?: InputMaybe<Scalars["Bytes"]>;
  userData_gte?: InputMaybe<Scalars["Bytes"]>;
  userData_lte?: InputMaybe<Scalars["Bytes"]>;
  userData_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_contains?: InputMaybe<Scalars["Bytes"]>;
  userData_not_contains?: InputMaybe<Scalars["Bytes"]>;
  flowUpdatedEvents_?: InputMaybe<FlowUpdatedEvent_filter>;
  streamPeriods_?: InputMaybe<StreamPeriod_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<Stream_filter>>>;
  or?: InputMaybe<Array<InputMaybe<Stream_filter>>>;
};

export type Stream_orderBy =
  | "id"
  | "createdAtTimestamp"
  | "createdAtBlockNumber"
  | "updatedAtTimestamp"
  | "updatedAtBlockNumber"
  | "currentFlowRate"
  | "deposit"
  | "streamedUntilUpdatedAt"
  | "token"
  | "token__id"
  | "token__createdAtTimestamp"
  | "token__createdAtBlockNumber"
  | "token__decimals"
  | "token__name"
  | "token__symbol"
  | "token__isSuperToken"
  | "token__isNativeAssetSuperToken"
  | "token__isListed"
  | "token__underlyingAddress"
  | "sender"
  | "sender__id"
  | "sender__createdAtTimestamp"
  | "sender__createdAtBlockNumber"
  | "sender__updatedAtTimestamp"
  | "sender__updatedAtBlockNumber"
  | "sender__isSuperApp"
  | "receiver"
  | "receiver__id"
  | "receiver__createdAtTimestamp"
  | "receiver__createdAtBlockNumber"
  | "receiver__updatedAtTimestamp"
  | "receiver__updatedAtBlockNumber"
  | "receiver__isSuperApp"
  | "userData"
  | "flowUpdatedEvents"
  | "streamPeriods";

export type Subscription = {
  flowUpdatedEvent?: Maybe<FlowUpdatedEvent>;
  flowUpdatedEvents: Array<FlowUpdatedEvent>;
  flowOperatorUpdatedEvent?: Maybe<FlowOperatorUpdatedEvent>;
  flowOperatorUpdatedEvents: Array<FlowOperatorUpdatedEvent>;
  indexCreatedEvent?: Maybe<IndexCreatedEvent>;
  indexCreatedEvents: Array<IndexCreatedEvent>;
  indexDistributionClaimedEvent?: Maybe<IndexDistributionClaimedEvent>;
  indexDistributionClaimedEvents: Array<IndexDistributionClaimedEvent>;
  indexUpdatedEvent?: Maybe<IndexUpdatedEvent>;
  indexUpdatedEvents: Array<IndexUpdatedEvent>;
  indexSubscribedEvent?: Maybe<IndexSubscribedEvent>;
  indexSubscribedEvents: Array<IndexSubscribedEvent>;
  indexUnitsUpdatedEvent?: Maybe<IndexUnitsUpdatedEvent>;
  indexUnitsUpdatedEvents: Array<IndexUnitsUpdatedEvent>;
  indexUnsubscribedEvent?: Maybe<IndexUnsubscribedEvent>;
  indexUnsubscribedEvents: Array<IndexUnsubscribedEvent>;
  subscriptionApprovedEvent?: Maybe<SubscriptionApprovedEvent>;
  subscriptionApprovedEvents: Array<SubscriptionApprovedEvent>;
  subscriptionDistributionClaimedEvent?: Maybe<SubscriptionDistributionClaimedEvent>;
  subscriptionDistributionClaimedEvents: Array<SubscriptionDistributionClaimedEvent>;
  subscriptionRevokedEvent?: Maybe<SubscriptionRevokedEvent>;
  subscriptionRevokedEvents: Array<SubscriptionRevokedEvent>;
  subscriptionUnitsUpdatedEvent?: Maybe<SubscriptionUnitsUpdatedEvent>;
  subscriptionUnitsUpdatedEvents: Array<SubscriptionUnitsUpdatedEvent>;
  poolCreatedEvent?: Maybe<PoolCreatedEvent>;
  poolCreatedEvents: Array<PoolCreatedEvent>;
  poolConnectionUpdatedEvent?: Maybe<PoolConnectionUpdatedEvent>;
  poolConnectionUpdatedEvents: Array<PoolConnectionUpdatedEvent>;
  bufferAdjustedEvent?: Maybe<BufferAdjustedEvent>;
  bufferAdjustedEvents: Array<BufferAdjustedEvent>;
  instantDistributionUpdatedEvent?: Maybe<InstantDistributionUpdatedEvent>;
  instantDistributionUpdatedEvents: Array<InstantDistributionUpdatedEvent>;
  flowDistributionUpdatedEvent?: Maybe<FlowDistributionUpdatedEvent>;
  flowDistributionUpdatedEvents: Array<FlowDistributionUpdatedEvent>;
  distributionClaimedEvent?: Maybe<DistributionClaimedEvent>;
  distributionClaimedEvents: Array<DistributionClaimedEvent>;
  memberUnitsUpdatedEvent?: Maybe<MemberUnitsUpdatedEvent>;
  memberUnitsUpdatedEvents: Array<MemberUnitsUpdatedEvent>;
  agreementClassRegisteredEvent?: Maybe<AgreementClassRegisteredEvent>;
  agreementClassRegisteredEvents: Array<AgreementClassRegisteredEvent>;
  agreementClassUpdatedEvent?: Maybe<AgreementClassUpdatedEvent>;
  agreementClassUpdatedEvents: Array<AgreementClassUpdatedEvent>;
  appRegisteredEvent?: Maybe<AppRegisteredEvent>;
  appRegisteredEvents: Array<AppRegisteredEvent>;
  governanceReplacedEvent?: Maybe<GovernanceReplacedEvent>;
  governanceReplacedEvents: Array<GovernanceReplacedEvent>;
  jailEvent?: Maybe<JailEvent>;
  jailEvents: Array<JailEvent>;
  superTokenFactoryUpdatedEvent?: Maybe<SuperTokenFactoryUpdatedEvent>;
  superTokenFactoryUpdatedEvents: Array<SuperTokenFactoryUpdatedEvent>;
  superTokenLogicUpdatedEvent?: Maybe<SuperTokenLogicUpdatedEvent>;
  superTokenLogicUpdatedEvents: Array<SuperTokenLogicUpdatedEvent>;
  roleAdminChangedEvent?: Maybe<RoleAdminChangedEvent>;
  roleAdminChangedEvents: Array<RoleAdminChangedEvent>;
  roleGrantedEvent?: Maybe<RoleGrantedEvent>;
  roleGrantedEvents: Array<RoleGrantedEvent>;
  roleRevokedEvent?: Maybe<RoleRevokedEvent>;
  roleRevokedEvents: Array<RoleRevokedEvent>;
  setEvent?: Maybe<SetEvent>;
  setEvents: Array<SetEvent>;
  cfav1LiquidationPeriodChangedEvent?: Maybe<CFAv1LiquidationPeriodChangedEvent>;
  cfav1LiquidationPeriodChangedEvents: Array<CFAv1LiquidationPeriodChangedEvent>;
  configChangedEvent?: Maybe<ConfigChangedEvent>;
  configChangedEvents: Array<ConfigChangedEvent>;
  rewardAddressChangedEvent?: Maybe<RewardAddressChangedEvent>;
  rewardAddressChangedEvents: Array<RewardAddressChangedEvent>;
  pppconfigurationChangedEvent?: Maybe<PPPConfigurationChangedEvent>;
  pppconfigurationChangedEvents: Array<PPPConfigurationChangedEvent>;
  superTokenMinimumDepositChangedEvent?: Maybe<SuperTokenMinimumDepositChangedEvent>;
  superTokenMinimumDepositChangedEvents: Array<SuperTokenMinimumDepositChangedEvent>;
  trustedForwarderChangedEvent?: Maybe<TrustedForwarderChangedEvent>;
  trustedForwarderChangedEvents: Array<TrustedForwarderChangedEvent>;
  agreementLiquidatedByEvent?: Maybe<AgreementLiquidatedByEvent>;
  agreementLiquidatedByEvents: Array<AgreementLiquidatedByEvent>;
  agreementLiquidatedV2Event?: Maybe<AgreementLiquidatedV2Event>;
  agreementLiquidatedV2Events: Array<AgreementLiquidatedV2Event>;
  burnedEvent?: Maybe<BurnedEvent>;
  burnedEvents: Array<BurnedEvent>;
  mintedEvent?: Maybe<MintedEvent>;
  mintedEvents: Array<MintedEvent>;
  sentEvent?: Maybe<SentEvent>;
  sentEvents: Array<SentEvent>;
  transferEvent?: Maybe<TransferEvent>;
  transferEvents: Array<TransferEvent>;
  tokenDowngradedEvent?: Maybe<TokenDowngradedEvent>;
  tokenDowngradedEvents: Array<TokenDowngradedEvent>;
  tokenUpgradedEvent?: Maybe<TokenUpgradedEvent>;
  tokenUpgradedEvents: Array<TokenUpgradedEvent>;
  approvalEvent?: Maybe<ApprovalEvent>;
  approvalEvents: Array<ApprovalEvent>;
  approvalForAllEvent?: Maybe<ApprovalForAllEvent>;
  approvalForAllEvents: Array<ApprovalForAllEvent>;
  metadataUpdateEvent?: Maybe<MetadataUpdateEvent>;
  metadataUpdateEvents: Array<MetadataUpdateEvent>;
  customSuperTokenCreatedEvent?: Maybe<CustomSuperTokenCreatedEvent>;
  customSuperTokenCreatedEvents: Array<CustomSuperTokenCreatedEvent>;
  superTokenCreatedEvent?: Maybe<SuperTokenCreatedEvent>;
  superTokenCreatedEvents: Array<SuperTokenCreatedEvent>;
  superTokenLogicCreatedEvent?: Maybe<SuperTokenLogicCreatedEvent>;
  superTokenLogicCreatedEvents: Array<SuperTokenLogicCreatedEvent>;
  newPICEvent?: Maybe<NewPICEvent>;
  newPICEvents: Array<NewPICEvent>;
  exitRateChangedEvent?: Maybe<ExitRateChangedEvent>;
  exitRateChangedEvents: Array<ExitRateChangedEvent>;
  bondIncreasedEvent?: Maybe<BondIncreasedEvent>;
  bondIncreasedEvents: Array<BondIncreasedEvent>;
  account?: Maybe<Account>;
  accounts: Array<Account>;
  pool?: Maybe<Pool>;
  pools: Array<Pool>;
  poolMember?: Maybe<PoolMember>;
  poolMembers: Array<PoolMember>;
  poolDistributor?: Maybe<PoolDistributor>;
  poolDistributors: Array<PoolDistributor>;
  index?: Maybe<Index>;
  indexes: Array<Index>;
  indexSubscription?: Maybe<IndexSubscription>;
  indexSubscriptions: Array<IndexSubscription>;
  stream?: Maybe<Stream>;
  streams: Array<Stream>;
  flowOperator?: Maybe<FlowOperator>;
  flowOperators: Array<FlowOperator>;
  streamPeriod?: Maybe<StreamPeriod>;
  streamPeriods: Array<StreamPeriod>;
  tokenGovernanceConfig?: Maybe<TokenGovernanceConfig>;
  tokenGovernanceConfigs: Array<TokenGovernanceConfig>;
  streamRevision?: Maybe<StreamRevision>;
  streamRevisions: Array<StreamRevision>;
  token?: Maybe<Token>;
  tokens: Array<Token>;
  resolverEntry?: Maybe<ResolverEntry>;
  resolverEntries: Array<ResolverEntry>;
  accountTokenSnapshot?: Maybe<AccountTokenSnapshot>;
  accountTokenSnapshots: Array<AccountTokenSnapshot>;
  accountTokenSnapshotLog?: Maybe<AccountTokenSnapshotLog>;
  accountTokenSnapshotLogs: Array<AccountTokenSnapshotLog>;
  tokenStatistic?: Maybe<TokenStatistic>;
  tokenStatistics: Array<TokenStatistic>;
  tokenStatisticLog?: Maybe<TokenStatisticLog>;
  tokenStatisticLogs: Array<TokenStatisticLog>;
  sfmeta?: Maybe<SFMeta>;
  sfmetas: Array<SFMeta>;
  event?: Maybe<Event>;
  events: Array<Event>;
  /** Access to subgraph metadata */
  _meta?: Maybe<_Meta_>;
};

export type SubscriptionflowUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionflowUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<FlowUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<FlowUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionflowOperatorUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionflowOperatorUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<FlowOperatorUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<FlowOperatorUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionindexCreatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionindexCreatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<IndexCreatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<IndexCreatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionindexDistributionClaimedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionindexDistributionClaimedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<IndexDistributionClaimedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<IndexDistributionClaimedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionindexUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionindexUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<IndexUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<IndexUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionindexSubscribedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionindexSubscribedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<IndexSubscribedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<IndexSubscribedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionindexUnitsUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionindexUnitsUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<IndexUnitsUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<IndexUnitsUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionindexUnsubscribedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionindexUnsubscribedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<IndexUnsubscribedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<IndexUnsubscribedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsubscriptionApprovedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsubscriptionApprovedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SubscriptionApprovedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SubscriptionApprovedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsubscriptionDistributionClaimedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsubscriptionDistributionClaimedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SubscriptionDistributionClaimedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SubscriptionDistributionClaimedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsubscriptionRevokedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsubscriptionRevokedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SubscriptionRevokedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SubscriptionRevokedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsubscriptionUnitsUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsubscriptionUnitsUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SubscriptionUnitsUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SubscriptionUnitsUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionpoolCreatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionpoolCreatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<PoolCreatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<PoolCreatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionpoolConnectionUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionpoolConnectionUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<PoolConnectionUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<PoolConnectionUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionbufferAdjustedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionbufferAdjustedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<BufferAdjustedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<BufferAdjustedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptioninstantDistributionUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptioninstantDistributionUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<InstantDistributionUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<InstantDistributionUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionflowDistributionUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionflowDistributionUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<FlowDistributionUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<FlowDistributionUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptiondistributionClaimedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptiondistributionClaimedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<DistributionClaimedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<DistributionClaimedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionmemberUnitsUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionmemberUnitsUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<MemberUnitsUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<MemberUnitsUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionagreementClassRegisteredEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionagreementClassRegisteredEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<AgreementClassRegisteredEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<AgreementClassRegisteredEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionagreementClassUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionagreementClassUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<AgreementClassUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<AgreementClassUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionappRegisteredEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionappRegisteredEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<AppRegisteredEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<AppRegisteredEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptiongovernanceReplacedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptiongovernanceReplacedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<GovernanceReplacedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<GovernanceReplacedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionjailEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionjailEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<JailEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<JailEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsuperTokenFactoryUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsuperTokenFactoryUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SuperTokenFactoryUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SuperTokenFactoryUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsuperTokenLogicUpdatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsuperTokenLogicUpdatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SuperTokenLogicUpdatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SuperTokenLogicUpdatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionroleAdminChangedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionroleAdminChangedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<RoleAdminChangedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<RoleAdminChangedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionroleGrantedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionroleGrantedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<RoleGrantedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<RoleGrantedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionroleRevokedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionroleRevokedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<RoleRevokedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<RoleRevokedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsetEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsetEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SetEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SetEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type Subscriptioncfav1LiquidationPeriodChangedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type Subscriptioncfav1LiquidationPeriodChangedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<CFAv1LiquidationPeriodChangedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<CFAv1LiquidationPeriodChangedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionconfigChangedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionconfigChangedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<ConfigChangedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<ConfigChangedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionrewardAddressChangedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionrewardAddressChangedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<RewardAddressChangedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<RewardAddressChangedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionpppconfigurationChangedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionpppconfigurationChangedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<PPPConfigurationChangedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<PPPConfigurationChangedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsuperTokenMinimumDepositChangedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsuperTokenMinimumDepositChangedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SuperTokenMinimumDepositChangedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SuperTokenMinimumDepositChangedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptiontrustedForwarderChangedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptiontrustedForwarderChangedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<TrustedForwarderChangedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<TrustedForwarderChangedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionagreementLiquidatedByEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionagreementLiquidatedByEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<AgreementLiquidatedByEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<AgreementLiquidatedByEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionagreementLiquidatedV2EventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionagreementLiquidatedV2EventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<AgreementLiquidatedV2Event_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<AgreementLiquidatedV2Event_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionburnedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionburnedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<BurnedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<BurnedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionmintedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionmintedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<MintedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<MintedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsentEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsentEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SentEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SentEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptiontransferEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptiontransferEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<TransferEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<TransferEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptiontokenDowngradedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptiontokenDowngradedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<TokenDowngradedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<TokenDowngradedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptiontokenUpgradedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptiontokenUpgradedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<TokenUpgradedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<TokenUpgradedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionapprovalEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionapprovalEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<ApprovalEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<ApprovalEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionapprovalForAllEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionapprovalForAllEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<ApprovalForAllEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<ApprovalForAllEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionmetadataUpdateEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionmetadataUpdateEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<MetadataUpdateEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<MetadataUpdateEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptioncustomSuperTokenCreatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptioncustomSuperTokenCreatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<CustomSuperTokenCreatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<CustomSuperTokenCreatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsuperTokenCreatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsuperTokenCreatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SuperTokenCreatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SuperTokenCreatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsuperTokenLogicCreatedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsuperTokenLogicCreatedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SuperTokenLogicCreatedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SuperTokenLogicCreatedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionnewPICEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionnewPICEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<NewPICEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<NewPICEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionexitRateChangedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionexitRateChangedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<ExitRateChangedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<ExitRateChangedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionbondIncreasedEventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionbondIncreasedEventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<BondIncreasedEvent_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<BondIncreasedEvent_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionaccountArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionaccountsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<Account_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<Account_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionpoolArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionpoolsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<Pool_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<Pool_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionpoolMemberArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionpoolMembersArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<PoolMember_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<PoolMember_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionpoolDistributorArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionpoolDistributorsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<PoolDistributor_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<PoolDistributor_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionindexArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionindexesArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<Index_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<Index_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionindexSubscriptionArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionindexSubscriptionsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<IndexSubscription_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<IndexSubscription_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionstreamArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionstreamsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<Stream_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<Stream_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionflowOperatorArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionflowOperatorsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<FlowOperator_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<FlowOperator_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionstreamPeriodArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionstreamPeriodsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<StreamPeriod_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<StreamPeriod_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptiontokenGovernanceConfigArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptiontokenGovernanceConfigsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<TokenGovernanceConfig_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<TokenGovernanceConfig_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionstreamRevisionArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionstreamRevisionsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<StreamRevision_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<StreamRevision_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptiontokenArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptiontokensArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<Token_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<Token_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionresolverEntryArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionresolverEntriesArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<ResolverEntry_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<ResolverEntry_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionaccountTokenSnapshotArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionaccountTokenSnapshotsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<AccountTokenSnapshot_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<AccountTokenSnapshot_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionaccountTokenSnapshotLogArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionaccountTokenSnapshotLogsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<AccountTokenSnapshotLog_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<AccountTokenSnapshotLog_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptiontokenStatisticArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptiontokenStatisticsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<TokenStatistic_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<TokenStatistic_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptiontokenStatisticLogArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptiontokenStatisticLogsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<TokenStatisticLog_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<TokenStatisticLog_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsfmetaArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionsfmetasArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<SFMeta_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<SFMeta_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptioneventArgs = {
  id: Scalars["ID"];
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptioneventsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<Event_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<Event_filter>;
  block?: InputMaybe<Block_height>;
  subgraphError?: _SubgraphErrorPolicy_;
};

export type Subscription_metaArgs = {
  block?: InputMaybe<Block_height>;
};

export type SubscriptionApprovedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `publisher`
   * addresses[2] = `subscriber`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
  /**
   * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
   * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
   *
   */
  subscriber: Scalars["Bytes"];
  /**
   * The creator of the `index`.
   *
   */
  publisher: Scalars["Bytes"];
  /**
   * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
   *
   */
  indexId: Scalars["BigInt"];
  userData: Scalars["Bytes"];
  subscription: IndexSubscription;
};

export type SubscriptionApprovedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  subscriber?: InputMaybe<Scalars["Bytes"]>;
  subscriber_not?: InputMaybe<Scalars["Bytes"]>;
  subscriber_gt?: InputMaybe<Scalars["Bytes"]>;
  subscriber_lt?: InputMaybe<Scalars["Bytes"]>;
  subscriber_gte?: InputMaybe<Scalars["Bytes"]>;
  subscriber_lte?: InputMaybe<Scalars["Bytes"]>;
  subscriber_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  subscriber_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  subscriber_contains?: InputMaybe<Scalars["Bytes"]>;
  subscriber_not_contains?: InputMaybe<Scalars["Bytes"]>;
  publisher?: InputMaybe<Scalars["Bytes"]>;
  publisher_not?: InputMaybe<Scalars["Bytes"]>;
  publisher_gt?: InputMaybe<Scalars["Bytes"]>;
  publisher_lt?: InputMaybe<Scalars["Bytes"]>;
  publisher_gte?: InputMaybe<Scalars["Bytes"]>;
  publisher_lte?: InputMaybe<Scalars["Bytes"]>;
  publisher_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  publisher_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  publisher_contains?: InputMaybe<Scalars["Bytes"]>;
  publisher_not_contains?: InputMaybe<Scalars["Bytes"]>;
  indexId?: InputMaybe<Scalars["BigInt"]>;
  indexId_not?: InputMaybe<Scalars["BigInt"]>;
  indexId_gt?: InputMaybe<Scalars["BigInt"]>;
  indexId_lt?: InputMaybe<Scalars["BigInt"]>;
  indexId_gte?: InputMaybe<Scalars["BigInt"]>;
  indexId_lte?: InputMaybe<Scalars["BigInt"]>;
  indexId_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  indexId_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  userData?: InputMaybe<Scalars["Bytes"]>;
  userData_not?: InputMaybe<Scalars["Bytes"]>;
  userData_gt?: InputMaybe<Scalars["Bytes"]>;
  userData_lt?: InputMaybe<Scalars["Bytes"]>;
  userData_gte?: InputMaybe<Scalars["Bytes"]>;
  userData_lte?: InputMaybe<Scalars["Bytes"]>;
  userData_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_contains?: InputMaybe<Scalars["Bytes"]>;
  userData_not_contains?: InputMaybe<Scalars["Bytes"]>;
  subscription?: InputMaybe<Scalars["String"]>;
  subscription_not?: InputMaybe<Scalars["String"]>;
  subscription_gt?: InputMaybe<Scalars["String"]>;
  subscription_lt?: InputMaybe<Scalars["String"]>;
  subscription_gte?: InputMaybe<Scalars["String"]>;
  subscription_lte?: InputMaybe<Scalars["String"]>;
  subscription_in?: InputMaybe<Array<Scalars["String"]>>;
  subscription_not_in?: InputMaybe<Array<Scalars["String"]>>;
  subscription_contains?: InputMaybe<Scalars["String"]>;
  subscription_contains_nocase?: InputMaybe<Scalars["String"]>;
  subscription_not_contains?: InputMaybe<Scalars["String"]>;
  subscription_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  subscription_starts_with?: InputMaybe<Scalars["String"]>;
  subscription_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  subscription_not_starts_with?: InputMaybe<Scalars["String"]>;
  subscription_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  subscription_ends_with?: InputMaybe<Scalars["String"]>;
  subscription_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  subscription_not_ends_with?: InputMaybe<Scalars["String"]>;
  subscription_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  subscription_?: InputMaybe<IndexSubscription_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<SubscriptionApprovedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<SubscriptionApprovedEvent_filter>>>;
};

export type SubscriptionApprovedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "subscriber"
  | "publisher"
  | "indexId"
  | "userData"
  | "subscription"
  | "subscription__id"
  | "subscription__createdAtTimestamp"
  | "subscription__createdAtBlockNumber"
  | "subscription__updatedAtTimestamp"
  | "subscription__updatedAtBlockNumber"
  | "subscription__approved"
  | "subscription__units"
  | "subscription__totalAmountReceivedUntilUpdatedAt"
  | "subscription__indexValueUntilUpdatedAt";

export type SubscriptionDistributionClaimedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `publisher`
   * addresses[2] = `subscriber`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
  /**
   * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
   * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
   *
   */
  subscriber: Scalars["Bytes"];
  /**
   * The creator of the `index`.
   *
   */
  publisher: Scalars["Bytes"];
  /**
   * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
   *
   */
  indexId: Scalars["BigInt"];
  amount: Scalars["BigInt"];
  subscription: IndexSubscription;
};

export type SubscriptionDistributionClaimedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  subscriber?: InputMaybe<Scalars["Bytes"]>;
  subscriber_not?: InputMaybe<Scalars["Bytes"]>;
  subscriber_gt?: InputMaybe<Scalars["Bytes"]>;
  subscriber_lt?: InputMaybe<Scalars["Bytes"]>;
  subscriber_gte?: InputMaybe<Scalars["Bytes"]>;
  subscriber_lte?: InputMaybe<Scalars["Bytes"]>;
  subscriber_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  subscriber_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  subscriber_contains?: InputMaybe<Scalars["Bytes"]>;
  subscriber_not_contains?: InputMaybe<Scalars["Bytes"]>;
  publisher?: InputMaybe<Scalars["Bytes"]>;
  publisher_not?: InputMaybe<Scalars["Bytes"]>;
  publisher_gt?: InputMaybe<Scalars["Bytes"]>;
  publisher_lt?: InputMaybe<Scalars["Bytes"]>;
  publisher_gte?: InputMaybe<Scalars["Bytes"]>;
  publisher_lte?: InputMaybe<Scalars["Bytes"]>;
  publisher_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  publisher_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  publisher_contains?: InputMaybe<Scalars["Bytes"]>;
  publisher_not_contains?: InputMaybe<Scalars["Bytes"]>;
  indexId?: InputMaybe<Scalars["BigInt"]>;
  indexId_not?: InputMaybe<Scalars["BigInt"]>;
  indexId_gt?: InputMaybe<Scalars["BigInt"]>;
  indexId_lt?: InputMaybe<Scalars["BigInt"]>;
  indexId_gte?: InputMaybe<Scalars["BigInt"]>;
  indexId_lte?: InputMaybe<Scalars["BigInt"]>;
  indexId_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  indexId_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  amount?: InputMaybe<Scalars["BigInt"]>;
  amount_not?: InputMaybe<Scalars["BigInt"]>;
  amount_gt?: InputMaybe<Scalars["BigInt"]>;
  amount_lt?: InputMaybe<Scalars["BigInt"]>;
  amount_gte?: InputMaybe<Scalars["BigInt"]>;
  amount_lte?: InputMaybe<Scalars["BigInt"]>;
  amount_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  amount_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  subscription?: InputMaybe<Scalars["String"]>;
  subscription_not?: InputMaybe<Scalars["String"]>;
  subscription_gt?: InputMaybe<Scalars["String"]>;
  subscription_lt?: InputMaybe<Scalars["String"]>;
  subscription_gte?: InputMaybe<Scalars["String"]>;
  subscription_lte?: InputMaybe<Scalars["String"]>;
  subscription_in?: InputMaybe<Array<Scalars["String"]>>;
  subscription_not_in?: InputMaybe<Array<Scalars["String"]>>;
  subscription_contains?: InputMaybe<Scalars["String"]>;
  subscription_contains_nocase?: InputMaybe<Scalars["String"]>;
  subscription_not_contains?: InputMaybe<Scalars["String"]>;
  subscription_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  subscription_starts_with?: InputMaybe<Scalars["String"]>;
  subscription_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  subscription_not_starts_with?: InputMaybe<Scalars["String"]>;
  subscription_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  subscription_ends_with?: InputMaybe<Scalars["String"]>;
  subscription_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  subscription_not_ends_with?: InputMaybe<Scalars["String"]>;
  subscription_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  subscription_?: InputMaybe<IndexSubscription_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<
    Array<InputMaybe<SubscriptionDistributionClaimedEvent_filter>>
  >;
  or?: InputMaybe<
    Array<InputMaybe<SubscriptionDistributionClaimedEvent_filter>>
  >;
};

export type SubscriptionDistributionClaimedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "subscriber"
  | "publisher"
  | "indexId"
  | "amount"
  | "subscription"
  | "subscription__id"
  | "subscription__createdAtTimestamp"
  | "subscription__createdAtBlockNumber"
  | "subscription__updatedAtTimestamp"
  | "subscription__updatedAtBlockNumber"
  | "subscription__approved"
  | "subscription__units"
  | "subscription__totalAmountReceivedUntilUpdatedAt"
  | "subscription__indexValueUntilUpdatedAt";

export type SubscriptionRevokedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `publisher`
   * addresses[2] = `subscriber`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
  /**
   * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
   * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
   *
   */
  subscriber: Scalars["Bytes"];
  /**
   * The creator of the `index`.
   *
   */
  publisher: Scalars["Bytes"];
  /**
   * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
   *
   */
  indexId: Scalars["BigInt"];
  userData: Scalars["Bytes"];
  subscription: IndexSubscription;
};

export type SubscriptionRevokedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  subscriber?: InputMaybe<Scalars["Bytes"]>;
  subscriber_not?: InputMaybe<Scalars["Bytes"]>;
  subscriber_gt?: InputMaybe<Scalars["Bytes"]>;
  subscriber_lt?: InputMaybe<Scalars["Bytes"]>;
  subscriber_gte?: InputMaybe<Scalars["Bytes"]>;
  subscriber_lte?: InputMaybe<Scalars["Bytes"]>;
  subscriber_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  subscriber_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  subscriber_contains?: InputMaybe<Scalars["Bytes"]>;
  subscriber_not_contains?: InputMaybe<Scalars["Bytes"]>;
  publisher?: InputMaybe<Scalars["Bytes"]>;
  publisher_not?: InputMaybe<Scalars["Bytes"]>;
  publisher_gt?: InputMaybe<Scalars["Bytes"]>;
  publisher_lt?: InputMaybe<Scalars["Bytes"]>;
  publisher_gte?: InputMaybe<Scalars["Bytes"]>;
  publisher_lte?: InputMaybe<Scalars["Bytes"]>;
  publisher_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  publisher_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  publisher_contains?: InputMaybe<Scalars["Bytes"]>;
  publisher_not_contains?: InputMaybe<Scalars["Bytes"]>;
  indexId?: InputMaybe<Scalars["BigInt"]>;
  indexId_not?: InputMaybe<Scalars["BigInt"]>;
  indexId_gt?: InputMaybe<Scalars["BigInt"]>;
  indexId_lt?: InputMaybe<Scalars["BigInt"]>;
  indexId_gte?: InputMaybe<Scalars["BigInt"]>;
  indexId_lte?: InputMaybe<Scalars["BigInt"]>;
  indexId_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  indexId_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  userData?: InputMaybe<Scalars["Bytes"]>;
  userData_not?: InputMaybe<Scalars["Bytes"]>;
  userData_gt?: InputMaybe<Scalars["Bytes"]>;
  userData_lt?: InputMaybe<Scalars["Bytes"]>;
  userData_gte?: InputMaybe<Scalars["Bytes"]>;
  userData_lte?: InputMaybe<Scalars["Bytes"]>;
  userData_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_contains?: InputMaybe<Scalars["Bytes"]>;
  userData_not_contains?: InputMaybe<Scalars["Bytes"]>;
  subscription?: InputMaybe<Scalars["String"]>;
  subscription_not?: InputMaybe<Scalars["String"]>;
  subscription_gt?: InputMaybe<Scalars["String"]>;
  subscription_lt?: InputMaybe<Scalars["String"]>;
  subscription_gte?: InputMaybe<Scalars["String"]>;
  subscription_lte?: InputMaybe<Scalars["String"]>;
  subscription_in?: InputMaybe<Array<Scalars["String"]>>;
  subscription_not_in?: InputMaybe<Array<Scalars["String"]>>;
  subscription_contains?: InputMaybe<Scalars["String"]>;
  subscription_contains_nocase?: InputMaybe<Scalars["String"]>;
  subscription_not_contains?: InputMaybe<Scalars["String"]>;
  subscription_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  subscription_starts_with?: InputMaybe<Scalars["String"]>;
  subscription_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  subscription_not_starts_with?: InputMaybe<Scalars["String"]>;
  subscription_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  subscription_ends_with?: InputMaybe<Scalars["String"]>;
  subscription_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  subscription_not_ends_with?: InputMaybe<Scalars["String"]>;
  subscription_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  subscription_?: InputMaybe<IndexSubscription_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<SubscriptionRevokedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<SubscriptionRevokedEvent_filter>>>;
};

export type SubscriptionRevokedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "subscriber"
  | "publisher"
  | "indexId"
  | "userData"
  | "subscription"
  | "subscription__id"
  | "subscription__createdAtTimestamp"
  | "subscription__createdAtBlockNumber"
  | "subscription__updatedAtTimestamp"
  | "subscription__updatedAtBlockNumber"
  | "subscription__approved"
  | "subscription__units"
  | "subscription__totalAmountReceivedUntilUpdatedAt"
  | "subscription__indexValueUntilUpdatedAt";

export type SubscriptionUnitsUpdatedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `publisher`
   * addresses[2] = `subscriber`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
  /**
   * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
   * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
   *
   */
  subscriber: Scalars["Bytes"];
  /**
   * The creator of the `index`.
   *
   */
  publisher: Scalars["Bytes"];
  /**
   * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
   *
   */
  indexId: Scalars["BigInt"];
  units: Scalars["BigInt"];
  userData: Scalars["Bytes"];
  oldUnits: Scalars["BigInt"];
  subscription: IndexSubscription;
};

export type SubscriptionUnitsUpdatedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  subscriber?: InputMaybe<Scalars["Bytes"]>;
  subscriber_not?: InputMaybe<Scalars["Bytes"]>;
  subscriber_gt?: InputMaybe<Scalars["Bytes"]>;
  subscriber_lt?: InputMaybe<Scalars["Bytes"]>;
  subscriber_gte?: InputMaybe<Scalars["Bytes"]>;
  subscriber_lte?: InputMaybe<Scalars["Bytes"]>;
  subscriber_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  subscriber_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  subscriber_contains?: InputMaybe<Scalars["Bytes"]>;
  subscriber_not_contains?: InputMaybe<Scalars["Bytes"]>;
  publisher?: InputMaybe<Scalars["Bytes"]>;
  publisher_not?: InputMaybe<Scalars["Bytes"]>;
  publisher_gt?: InputMaybe<Scalars["Bytes"]>;
  publisher_lt?: InputMaybe<Scalars["Bytes"]>;
  publisher_gte?: InputMaybe<Scalars["Bytes"]>;
  publisher_lte?: InputMaybe<Scalars["Bytes"]>;
  publisher_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  publisher_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  publisher_contains?: InputMaybe<Scalars["Bytes"]>;
  publisher_not_contains?: InputMaybe<Scalars["Bytes"]>;
  indexId?: InputMaybe<Scalars["BigInt"]>;
  indexId_not?: InputMaybe<Scalars["BigInt"]>;
  indexId_gt?: InputMaybe<Scalars["BigInt"]>;
  indexId_lt?: InputMaybe<Scalars["BigInt"]>;
  indexId_gte?: InputMaybe<Scalars["BigInt"]>;
  indexId_lte?: InputMaybe<Scalars["BigInt"]>;
  indexId_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  indexId_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  units?: InputMaybe<Scalars["BigInt"]>;
  units_not?: InputMaybe<Scalars["BigInt"]>;
  units_gt?: InputMaybe<Scalars["BigInt"]>;
  units_lt?: InputMaybe<Scalars["BigInt"]>;
  units_gte?: InputMaybe<Scalars["BigInt"]>;
  units_lte?: InputMaybe<Scalars["BigInt"]>;
  units_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  units_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  userData?: InputMaybe<Scalars["Bytes"]>;
  userData_not?: InputMaybe<Scalars["Bytes"]>;
  userData_gt?: InputMaybe<Scalars["Bytes"]>;
  userData_lt?: InputMaybe<Scalars["Bytes"]>;
  userData_gte?: InputMaybe<Scalars["Bytes"]>;
  userData_lte?: InputMaybe<Scalars["Bytes"]>;
  userData_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  userData_contains?: InputMaybe<Scalars["Bytes"]>;
  userData_not_contains?: InputMaybe<Scalars["Bytes"]>;
  oldUnits?: InputMaybe<Scalars["BigInt"]>;
  oldUnits_not?: InputMaybe<Scalars["BigInt"]>;
  oldUnits_gt?: InputMaybe<Scalars["BigInt"]>;
  oldUnits_lt?: InputMaybe<Scalars["BigInt"]>;
  oldUnits_gte?: InputMaybe<Scalars["BigInt"]>;
  oldUnits_lte?: InputMaybe<Scalars["BigInt"]>;
  oldUnits_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  oldUnits_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  subscription?: InputMaybe<Scalars["String"]>;
  subscription_not?: InputMaybe<Scalars["String"]>;
  subscription_gt?: InputMaybe<Scalars["String"]>;
  subscription_lt?: InputMaybe<Scalars["String"]>;
  subscription_gte?: InputMaybe<Scalars["String"]>;
  subscription_lte?: InputMaybe<Scalars["String"]>;
  subscription_in?: InputMaybe<Array<Scalars["String"]>>;
  subscription_not_in?: InputMaybe<Array<Scalars["String"]>>;
  subscription_contains?: InputMaybe<Scalars["String"]>;
  subscription_contains_nocase?: InputMaybe<Scalars["String"]>;
  subscription_not_contains?: InputMaybe<Scalars["String"]>;
  subscription_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  subscription_starts_with?: InputMaybe<Scalars["String"]>;
  subscription_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  subscription_not_starts_with?: InputMaybe<Scalars["String"]>;
  subscription_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  subscription_ends_with?: InputMaybe<Scalars["String"]>;
  subscription_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  subscription_not_ends_with?: InputMaybe<Scalars["String"]>;
  subscription_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  subscription_?: InputMaybe<IndexSubscription_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<SubscriptionUnitsUpdatedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<SubscriptionUnitsUpdatedEvent_filter>>>;
};

export type SubscriptionUnitsUpdatedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "subscriber"
  | "publisher"
  | "indexId"
  | "units"
  | "userData"
  | "oldUnits"
  | "subscription"
  | "subscription__id"
  | "subscription__createdAtTimestamp"
  | "subscription__createdAtBlockNumber"
  | "subscription__updatedAtTimestamp"
  | "subscription__updatedAtBlockNumber"
  | "subscription__approved"
  | "subscription__units"
  | "subscription__totalAmountReceivedUntilUpdatedAt"
  | "subscription__indexValueUntilUpdatedAt";

export type SuperTokenCreatedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
};

export type SuperTokenCreatedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<SuperTokenCreatedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<SuperTokenCreatedEvent_filter>>>;
};

export type SuperTokenCreatedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token";

export type SuperTokenFactoryUpdatedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `newFactory`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  newFactory: Scalars["Bytes"];
};

export type SuperTokenFactoryUpdatedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  newFactory?: InputMaybe<Scalars["Bytes"]>;
  newFactory_not?: InputMaybe<Scalars["Bytes"]>;
  newFactory_gt?: InputMaybe<Scalars["Bytes"]>;
  newFactory_lt?: InputMaybe<Scalars["Bytes"]>;
  newFactory_gte?: InputMaybe<Scalars["Bytes"]>;
  newFactory_lte?: InputMaybe<Scalars["Bytes"]>;
  newFactory_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  newFactory_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  newFactory_contains?: InputMaybe<Scalars["Bytes"]>;
  newFactory_not_contains?: InputMaybe<Scalars["Bytes"]>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<SuperTokenFactoryUpdatedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<SuperTokenFactoryUpdatedEvent_filter>>>;
};

export type SuperTokenFactoryUpdatedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "newFactory";

export type SuperTokenLogicCreatedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `tokenLogic`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  tokenLogic: Scalars["Bytes"];
};

export type SuperTokenLogicCreatedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  tokenLogic?: InputMaybe<Scalars["Bytes"]>;
  tokenLogic_not?: InputMaybe<Scalars["Bytes"]>;
  tokenLogic_gt?: InputMaybe<Scalars["Bytes"]>;
  tokenLogic_lt?: InputMaybe<Scalars["Bytes"]>;
  tokenLogic_gte?: InputMaybe<Scalars["Bytes"]>;
  tokenLogic_lte?: InputMaybe<Scalars["Bytes"]>;
  tokenLogic_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  tokenLogic_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  tokenLogic_contains?: InputMaybe<Scalars["Bytes"]>;
  tokenLogic_not_contains?: InputMaybe<Scalars["Bytes"]>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<SuperTokenLogicCreatedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<SuperTokenLogicCreatedEvent_filter>>>;
};

export type SuperTokenLogicCreatedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "tokenLogic";

export type SuperTokenLogicUpdatedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token`
   * addresses[1] = `code`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
  code: Scalars["Bytes"];
};

export type SuperTokenLogicUpdatedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  code?: InputMaybe<Scalars["Bytes"]>;
  code_not?: InputMaybe<Scalars["Bytes"]>;
  code_gt?: InputMaybe<Scalars["Bytes"]>;
  code_lt?: InputMaybe<Scalars["Bytes"]>;
  code_gte?: InputMaybe<Scalars["Bytes"]>;
  code_lte?: InputMaybe<Scalars["Bytes"]>;
  code_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  code_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  code_contains?: InputMaybe<Scalars["Bytes"]>;
  code_not_contains?: InputMaybe<Scalars["Bytes"]>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<SuperTokenLogicUpdatedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<SuperTokenLogicUpdatedEvent_filter>>>;
};

export type SuperTokenLogicUpdatedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "code";

export type SuperTokenMinimumDepositChangedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * The address of the governance contract the event was emitted from.
   *
   */
  governanceAddress: Scalars["Bytes"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `governanceAddress`
   * addresses[1] = `host`
   * addresses[2] = `superToken`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  host: Scalars["Bytes"];
  superToken: Scalars["Bytes"];
  isKeySet: Scalars["Boolean"];
  minimumDeposit: Scalars["BigInt"];
};

export type SuperTokenMinimumDepositChangedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  governanceAddress?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_not?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_gt?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_lt?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_gte?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_lte?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  governanceAddress_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  governanceAddress_contains?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_not_contains?: InputMaybe<Scalars["Bytes"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  host?: InputMaybe<Scalars["Bytes"]>;
  host_not?: InputMaybe<Scalars["Bytes"]>;
  host_gt?: InputMaybe<Scalars["Bytes"]>;
  host_lt?: InputMaybe<Scalars["Bytes"]>;
  host_gte?: InputMaybe<Scalars["Bytes"]>;
  host_lte?: InputMaybe<Scalars["Bytes"]>;
  host_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  host_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  host_contains?: InputMaybe<Scalars["Bytes"]>;
  host_not_contains?: InputMaybe<Scalars["Bytes"]>;
  superToken?: InputMaybe<Scalars["Bytes"]>;
  superToken_not?: InputMaybe<Scalars["Bytes"]>;
  superToken_gt?: InputMaybe<Scalars["Bytes"]>;
  superToken_lt?: InputMaybe<Scalars["Bytes"]>;
  superToken_gte?: InputMaybe<Scalars["Bytes"]>;
  superToken_lte?: InputMaybe<Scalars["Bytes"]>;
  superToken_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  superToken_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  superToken_contains?: InputMaybe<Scalars["Bytes"]>;
  superToken_not_contains?: InputMaybe<Scalars["Bytes"]>;
  isKeySet?: InputMaybe<Scalars["Boolean"]>;
  isKeySet_not?: InputMaybe<Scalars["Boolean"]>;
  isKeySet_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  isKeySet_not_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  minimumDeposit?: InputMaybe<Scalars["BigInt"]>;
  minimumDeposit_not?: InputMaybe<Scalars["BigInt"]>;
  minimumDeposit_gt?: InputMaybe<Scalars["BigInt"]>;
  minimumDeposit_lt?: InputMaybe<Scalars["BigInt"]>;
  minimumDeposit_gte?: InputMaybe<Scalars["BigInt"]>;
  minimumDeposit_lte?: InputMaybe<Scalars["BigInt"]>;
  minimumDeposit_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  minimumDeposit_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<
    Array<InputMaybe<SuperTokenMinimumDepositChangedEvent_filter>>
  >;
  or?: InputMaybe<
    Array<InputMaybe<SuperTokenMinimumDepositChangedEvent_filter>>
  >;
};

export type SuperTokenMinimumDepositChangedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "governanceAddress"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "host"
  | "superToken"
  | "isKeySet"
  | "minimumDeposit";

/**
 * Token: A higher order entity created for super tokens (and underlying tokens) that are "valid" (tokens that have Superfluid's host contract address set as the host).
 *
 */
export type Token = {
  /**
   * ID: the token address
   *
   */
  id: Scalars["ID"];
  createdAtTimestamp: Scalars["BigInt"];
  createdAtBlockNumber: Scalars["BigInt"];
  decimals: Scalars["Int"];
  name: Scalars["String"];
  symbol: Scalars["String"];
  isSuperToken: Scalars["Boolean"];
  /**
   * A boolean indicating whether the token is a NativeAssetSuperToken.
   *
   */
  isNativeAssetSuperToken: Scalars["Boolean"];
  /**
   * A boolean indicating whether the token is a part of our resolver list.
   *
   */
  isListed: Scalars["Boolean"];
  /**
   * The address of the underlying ERC20 token (zero address for non-ERC20WrapperSuperToken's)
   *
   */
  underlyingAddress: Scalars["Bytes"];
  /**
   * The underlying ERC20 token for a ERC20WrapperSuperToken otherwise null.
   *
   */
  underlyingToken?: Maybe<Token>;
  /**
   * If `governanceConfig.id` is the zero address, the token uses the default governance config.
   *
   */
  governanceConfig?: Maybe<TokenGovernanceConfig>;
};

export type TokenDowngradedEvent = Event & {
  id: Scalars["ID"];
  account: Account;
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `account`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
  amount: Scalars["BigInt"];
};

export type TokenDowngradedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  account?: InputMaybe<Scalars["String"]>;
  account_not?: InputMaybe<Scalars["String"]>;
  account_gt?: InputMaybe<Scalars["String"]>;
  account_lt?: InputMaybe<Scalars["String"]>;
  account_gte?: InputMaybe<Scalars["String"]>;
  account_lte?: InputMaybe<Scalars["String"]>;
  account_in?: InputMaybe<Array<Scalars["String"]>>;
  account_not_in?: InputMaybe<Array<Scalars["String"]>>;
  account_contains?: InputMaybe<Scalars["String"]>;
  account_contains_nocase?: InputMaybe<Scalars["String"]>;
  account_not_contains?: InputMaybe<Scalars["String"]>;
  account_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  account_starts_with?: InputMaybe<Scalars["String"]>;
  account_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  account_not_starts_with?: InputMaybe<Scalars["String"]>;
  account_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  account_ends_with?: InputMaybe<Scalars["String"]>;
  account_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  account_not_ends_with?: InputMaybe<Scalars["String"]>;
  account_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  account_?: InputMaybe<Account_filter>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  amount?: InputMaybe<Scalars["BigInt"]>;
  amount_not?: InputMaybe<Scalars["BigInt"]>;
  amount_gt?: InputMaybe<Scalars["BigInt"]>;
  amount_lt?: InputMaybe<Scalars["BigInt"]>;
  amount_gte?: InputMaybe<Scalars["BigInt"]>;
  amount_lte?: InputMaybe<Scalars["BigInt"]>;
  amount_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  amount_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<TokenDowngradedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<TokenDowngradedEvent_filter>>>;
};

export type TokenDowngradedEvent_orderBy =
  | "id"
  | "account"
  | "account__id"
  | "account__createdAtTimestamp"
  | "account__createdAtBlockNumber"
  | "account__updatedAtTimestamp"
  | "account__updatedAtBlockNumber"
  | "account__isSuperApp"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "amount";

/**
 * TokenGovernanceConfig: A higher order entity that represents the governance configs for a token.
 * If `id` is `address(0)`, it will be used as the default config.
 *
 */
export type TokenGovernanceConfig = {
  /**
   * id is the address of the SuperToken
   * NOTE: the zero address is reserved for the default config for all tokens with unset configs.
   *
   */
  id: Scalars["ID"];
  createdAtTimestamp: Scalars["BigInt"];
  createdAtBlockNumber: Scalars["BigInt"];
  updatedAtTimestamp: Scalars["BigInt"];
  updatedAtBlockNumber: Scalars["BigInt"];
  /**
   * If true, `id` is `address(0)` and this is the default config for all tokens with unset configs.
   *
   */
  isDefault: Scalars["Boolean"];
  /**
   * The (default or token-specific) address that receives liquidation rewards for a token prior to 3Ps and the TOGA address after 3Ps.
   *
   */
  rewardAddress?: Maybe<Scalars["Bytes"]>;
  /**
   * The (default or token-specific) liquidation period (buffer amount required for a token).
   * This field can be used to calculate the liquidation buffer (or deposit) amount for a token: `liquidationBufferAmount = liquidationPeriod * flowRate`.
   * Note that if `minimumDeposit` is set, the liquidation buffer amount will be the greater of the two values.
   *
   */
  liquidationPeriod?: Maybe<Scalars["BigInt"]>;
  /**
   * The (default or token-specific) patrician period, the patrician period is the window in which a patrician receives all rewards for a liquidation, no matter the liquidating account.
   *
   */
  patricianPeriod?: Maybe<Scalars["BigInt"]>;
  /**
   * The (default or token-specific) minimum deposit amount.
   *
   */
  minimumDeposit?: Maybe<Scalars["BigInt"]>;
  /**
   * A reverse lookup to the token it is associated with and null if it is the default config.
   *
   */
  token?: Maybe<Token>;
};

export type TokenGovernanceConfig_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  createdAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  isDefault?: InputMaybe<Scalars["Boolean"]>;
  isDefault_not?: InputMaybe<Scalars["Boolean"]>;
  isDefault_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  isDefault_not_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  rewardAddress?: InputMaybe<Scalars["Bytes"]>;
  rewardAddress_not?: InputMaybe<Scalars["Bytes"]>;
  rewardAddress_gt?: InputMaybe<Scalars["Bytes"]>;
  rewardAddress_lt?: InputMaybe<Scalars["Bytes"]>;
  rewardAddress_gte?: InputMaybe<Scalars["Bytes"]>;
  rewardAddress_lte?: InputMaybe<Scalars["Bytes"]>;
  rewardAddress_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  rewardAddress_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  rewardAddress_contains?: InputMaybe<Scalars["Bytes"]>;
  rewardAddress_not_contains?: InputMaybe<Scalars["Bytes"]>;
  liquidationPeriod?: InputMaybe<Scalars["BigInt"]>;
  liquidationPeriod_not?: InputMaybe<Scalars["BigInt"]>;
  liquidationPeriod_gt?: InputMaybe<Scalars["BigInt"]>;
  liquidationPeriod_lt?: InputMaybe<Scalars["BigInt"]>;
  liquidationPeriod_gte?: InputMaybe<Scalars["BigInt"]>;
  liquidationPeriod_lte?: InputMaybe<Scalars["BigInt"]>;
  liquidationPeriod_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  liquidationPeriod_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  patricianPeriod?: InputMaybe<Scalars["BigInt"]>;
  patricianPeriod_not?: InputMaybe<Scalars["BigInt"]>;
  patricianPeriod_gt?: InputMaybe<Scalars["BigInt"]>;
  patricianPeriod_lt?: InputMaybe<Scalars["BigInt"]>;
  patricianPeriod_gte?: InputMaybe<Scalars["BigInt"]>;
  patricianPeriod_lte?: InputMaybe<Scalars["BigInt"]>;
  patricianPeriod_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  patricianPeriod_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  minimumDeposit?: InputMaybe<Scalars["BigInt"]>;
  minimumDeposit_not?: InputMaybe<Scalars["BigInt"]>;
  minimumDeposit_gt?: InputMaybe<Scalars["BigInt"]>;
  minimumDeposit_lt?: InputMaybe<Scalars["BigInt"]>;
  minimumDeposit_gte?: InputMaybe<Scalars["BigInt"]>;
  minimumDeposit_lte?: InputMaybe<Scalars["BigInt"]>;
  minimumDeposit_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  minimumDeposit_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["String"]>;
  token_not?: InputMaybe<Scalars["String"]>;
  token_gt?: InputMaybe<Scalars["String"]>;
  token_lt?: InputMaybe<Scalars["String"]>;
  token_gte?: InputMaybe<Scalars["String"]>;
  token_lte?: InputMaybe<Scalars["String"]>;
  token_in?: InputMaybe<Array<Scalars["String"]>>;
  token_not_in?: InputMaybe<Array<Scalars["String"]>>;
  token_contains?: InputMaybe<Scalars["String"]>;
  token_contains_nocase?: InputMaybe<Scalars["String"]>;
  token_not_contains?: InputMaybe<Scalars["String"]>;
  token_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  token_starts_with?: InputMaybe<Scalars["String"]>;
  token_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  token_not_starts_with?: InputMaybe<Scalars["String"]>;
  token_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  token_ends_with?: InputMaybe<Scalars["String"]>;
  token_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  token_not_ends_with?: InputMaybe<Scalars["String"]>;
  token_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  token_?: InputMaybe<Token_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<TokenGovernanceConfig_filter>>>;
  or?: InputMaybe<Array<InputMaybe<TokenGovernanceConfig_filter>>>;
};

export type TokenGovernanceConfig_orderBy =
  | "id"
  | "createdAtTimestamp"
  | "createdAtBlockNumber"
  | "updatedAtTimestamp"
  | "updatedAtBlockNumber"
  | "isDefault"
  | "rewardAddress"
  | "liquidationPeriod"
  | "patricianPeriod"
  | "minimumDeposit"
  | "token"
  | "token__id"
  | "token__createdAtTimestamp"
  | "token__createdAtBlockNumber"
  | "token__decimals"
  | "token__name"
  | "token__symbol"
  | "token__isSuperToken"
  | "token__isNativeAssetSuperToken"
  | "token__isListed"
  | "token__underlyingAddress";

/**
 * TokenStatistic: An aggregate entity which contains aggregate data for `token`.
 *
 */
export type TokenStatistic = {
  /**
   * id: `token` (superToken) address
   *
   */
  id: Scalars["ID"];
  updatedAtTimestamp: Scalars["BigInt"];
  updatedAtBlockNumber: Scalars["BigInt"];
  /**
   * The total number of currently active `token` streams.
   *
   */
  totalNumberOfActiveStreams: Scalars["Int"];
  /**
   * The total number of currently active `token` streams for the CFA.
   *
   */
  totalCFANumberOfActiveStreams: Scalars["Int"];
  /**
   * The total number of currently active `token` streams for the GDA.
   *
   */
  totalGDANumberOfActiveStreams: Scalars["Int"];
  /**
   * The count of closed streams for `token`.
   *
   */
  totalNumberOfClosedStreams: Scalars["Int"];
  /**
   * The count of closed streams for `token` for the CFA.
   *
   */
  totalCFANumberOfClosedStreams: Scalars["Int"];
  /**
   * The count of closed streams for `token` for the GDA.
   *
   */
  totalGDANumberOfClosedStreams: Scalars["Int"];
  /**
   * The total number of Indexes created with `token`.
   *
   */
  totalNumberOfIndexes: Scalars["Int"];
  /**
   * The total number of "active" (has greater than 0 units and has distributed it at least once) Indexes created with `token`.
   *
   */
  totalNumberOfActiveIndexes: Scalars["Int"];
  /**
   * The number of subscriptions which have units allocated to them created with Indexes that distribute `token`.
   *
   */
  totalSubscriptionsWithUnits: Scalars["Int"];
  /**
   * Counts all approved subscriptions whether or not they have units.
   *
   */
  totalApprovedSubscriptions: Scalars["Int"];
  /**
   * The total number of Pools created with `token`.
   *
   */
  totalNumberOfPools: Scalars["Int"];
  /**
   * The total number of "active" (has greater than 0 units and has distributed it at least once) Pools created with `token`.
   *
   */
  totalNumberOfActivePools: Scalars["Int"];
  /**
   * The number of memberships which have units allocated to them created with Pools that distribute `token`.
   *
   */
  totalMembershipsWithUnits: Scalars["Int"];
  /**
   * Counts all approved memberships whether or not they have units.
   *
   */
  totalConnectedMemberships: Scalars["Int"];
  /**
   * The total deposit held by all flow agreements for this particular `token`.
   *
   */
  totalDeposit: Scalars["BigInt"];
  /**
   * The total deposit held by the CFA for this particular `token`.
   *
   */
  totalCFADeposit: Scalars["BigInt"];
  /**
   * The total deposit held by the GDA agreement for this particular `token`.
   *
   */
  totalGDADeposit: Scalars["BigInt"];
  /**
   * The total outflow rate of the `token` (how much value is being moved) for all flow agreements.
   *
   */
  totalOutflowRate: Scalars["BigInt"];
  /**
   * The total outflow rate of the `token` (how much value is being moved) for the CFA.
   *
   */
  totalCFAOutflowRate: Scalars["BigInt"];
  /**
   * The total outflow rate of the `token` (how much value is being moved) for the GDA.
   *
   */
  totalGDAOutflowRate: Scalars["BigInt"];
  /**
   * The all-time total amount streamed (outflows) until the `updatedAtTimestamp`/`updatedAtBlock` for all flow agreements.
   *
   */
  totalAmountStreamedUntilUpdatedAt: Scalars["BigInt"];
  /**
   * The all-time total amount streamed (outflows) until the `updatedAtTimestamp`/`updatedAtBlock` for the CFA.
   *
   */
  totalCFAAmountStreamedUntilUpdatedAt: Scalars["BigInt"];
  /**
   * The all-time total amount transferred until the `updatedAtTimestamp`/`updatedAtBlock`.
   *
   */
  totalAmountTransferredUntilUpdatedAt: Scalars["BigInt"];
  /**
   * The all-time total amount distributed until the `updatedAtTimestamp`/`updatedAtBlock`.
   *
   */
  totalAmountDistributedUntilUpdatedAt: Scalars["BigInt"];
  /**
   * The total supply of the token - this is impacted by users upgrading/downgrading their tokens.
   *
   */
  totalSupply: Scalars["BigInt"];
  /**
   * The total number of accounts that have interacted with the token (but might not hold a balance anymore).
   *
   */
  totalNumberOfAccounts: Scalars["Int"];
  /**
   * The total number of accounts holding a non-zero balance of the token.
   *
   */
  totalNumberOfHolders: Scalars["Int"];
  token: Token;
  tokenStatisticLogs: Array<TokenStatisticLog>;
};

/**
 * TokenStatistic: An aggregate entity which contains aggregate data for `token`.
 *
 */
export type TokenStatistictokenStatisticLogsArgs = {
  skip?: InputMaybe<Scalars["Int"]>;
  first?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<TokenStatisticLog_orderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<TokenStatisticLog_filter>;
};

/**
 * TokenStatisticLog: Historical entries of `TokenStatistic` updates.
 *
 */
export type TokenStatisticLog = {
  id: Scalars["ID"];
  timestamp: Scalars["BigInt"];
  blockNumber: Scalars["BigInt"];
  transactionHash: Scalars["Bytes"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  triggeredByEventName: Scalars["String"];
  /**
   * The total number of currently active `token` streams for all flow agreements.
   *
   */
  totalNumberOfActiveStreams: Scalars["Int"];
  /**
   * The total number of currently active `token` streams for the CFA.
   *
   */
  totalCFANumberOfActiveStreams: Scalars["Int"];
  /**
   * The total number of currently active `token` streams for the GDA.
   *
   */
  totalGDANumberOfActiveStreams: Scalars["Int"];
  /**
   * The count of closed streams for `token` for all flow agreements.
   *
   */
  totalNumberOfClosedStreams: Scalars["Int"];
  /**
   * The count of closed streams for `token` for the CFA.
   *
   */
  totalCFANumberOfClosedStreams: Scalars["Int"];
  /**
   * The count of closed streams for `token` for the GDA.
   *
   */
  totalGDANumberOfClosedStreams: Scalars["Int"];
  /**
   * The total number of Indexes created with `token`.
   *
   */
  totalNumberOfIndexes: Scalars["Int"];
  /**
   * The total number of "active" (has greater than 0 units and has distributed it at least once) Indexes created with `token`.
   *
   */
  totalNumberOfActiveIndexes: Scalars["Int"];
  /**
   * The number of subscriptions which have units allocated to them created with Indexes that distribute `token`.
   *
   */
  totalSubscriptionsWithUnits: Scalars["Int"];
  /**
   * Counts all approved subscriptions whether or not they have units.
   *
   */
  totalApprovedSubscriptions: Scalars["Int"];
  /**
   * The total number of Pools created with `token`.
   *
   */
  totalNumberOfPools: Scalars["Int"];
  /**
   * The total number of "active" (has greater than 0 units and has distributed it at least once) Pools created with `token`.
   *
   */
  totalNumberOfActivePools: Scalars["Int"];
  /**
   * The number of memberships which have units allocated to them created with Pools that distribute `token`.
   *
   */
  totalMembershipsWithUnits: Scalars["Int"];
  /**
   * Counts all connected memberships whether or not they have units.
   *
   */
  totalConnectedMemberships: Scalars["Int"];
  /**
   * The total deposit held by the CFA agreement for this particular `token` for all flow agreements.
   *
   */
  totalDeposit: Scalars["BigInt"];
  /**
   * The total deposit held by the CFA agreement for this particular `token` for the CFA.
   *
   */
  totalCFADeposit: Scalars["BigInt"];
  /**
   * The total deposit held by the CFA agreement for this particular `token` for the GDA.
   *
   */
  totalGDADeposit: Scalars["BigInt"];
  /**
   * The total outflow rate of the `token` (how much value is being moved) for all flow agreements.
   *
   */
  totalOutflowRate: Scalars["BigInt"];
  /**
   * The total outflow rate of the `token` (how much value is being moved) for the CFA.
   *
   */
  totalCFAOutflowRate: Scalars["BigInt"];
  /**
   * The total outflow rate of the `token` (how much value is being moved) for the GDA.
   *
   */
  totalGDAOutflowRate: Scalars["BigInt"];
  /**
   * The all-time total amount of `token` streamed (outflows) until the `timestamp`/`block` for all flow agreements.
   *
   */
  totalAmountStreamed: Scalars["BigInt"];
  /**
   * The all-time total amount of `token` streamed (outflows) until the `timestamp`/`block` for the CFA.
   *
   */
  totalCFAAmountStreamed: Scalars["BigInt"];
  /**
   * The all-time total amount of `token` transferred until the `timestamp`/`block`.
   *
   */
  totalAmountTransferred: Scalars["BigInt"];
  /**
   * The all-time total amount of `token` distributed until the `timestamp`/`block`.
   *
   */
  totalAmountDistributed: Scalars["BigInt"];
  /**
   * The total supply of the token - this is impacted by users upgrading/downgrading their tokens.
   *
   */
  totalSupply: Scalars["BigInt"];
  /**
   * The total number of accounts that have interacted with the token (but might not hold a balance anymore).
   *
   */
  totalNumberOfAccounts: Scalars["Int"];
  /**
   * The total number of accounts holding a non-zero balance of the token.
   *
   */
  totalNumberOfHolders: Scalars["Int"];
  token: Token;
  tokenStatistic: TokenStatistic;
};

export type TokenStatisticLog_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  triggeredByEventName?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_not?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_gt?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_lt?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_gte?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_lte?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_in?: InputMaybe<Array<Scalars["String"]>>;
  triggeredByEventName_not_in?: InputMaybe<Array<Scalars["String"]>>;
  triggeredByEventName_contains?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_contains_nocase?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_not_contains?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_starts_with?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_not_starts_with?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_ends_with?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_not_ends_with?: InputMaybe<Scalars["String"]>;
  triggeredByEventName_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  totalNumberOfActiveStreams?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_not?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfActiveStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalCFANumberOfActiveStreams?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_not?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalCFANumberOfActiveStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalGDANumberOfActiveStreams?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_not?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalGDANumberOfActiveStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfClosedStreams?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_not?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfClosedStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalCFANumberOfClosedStreams?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_not?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalCFANumberOfClosedStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalGDANumberOfClosedStreams?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_not?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalGDANumberOfClosedStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfIndexes?: InputMaybe<Scalars["Int"]>;
  totalNumberOfIndexes_not?: InputMaybe<Scalars["Int"]>;
  totalNumberOfIndexes_gt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfIndexes_lt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfIndexes_gte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfIndexes_lte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfIndexes_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfIndexes_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfActiveIndexes?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveIndexes_not?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveIndexes_gt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveIndexes_lt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveIndexes_gte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveIndexes_lte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveIndexes_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfActiveIndexes_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalSubscriptionsWithUnits?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_not?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_gt?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_lt?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_gte?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_lte?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalSubscriptionsWithUnits_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalApprovedSubscriptions?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_not?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_gt?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_lt?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_gte?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_lte?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalApprovedSubscriptions_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfPools?: InputMaybe<Scalars["Int"]>;
  totalNumberOfPools_not?: InputMaybe<Scalars["Int"]>;
  totalNumberOfPools_gt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfPools_lt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfPools_gte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfPools_lte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfPools_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfPools_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfActivePools?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActivePools_not?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActivePools_gt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActivePools_lt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActivePools_gte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActivePools_lte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActivePools_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfActivePools_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalMembershipsWithUnits?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_not?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_gt?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_lt?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_gte?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_lte?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalMembershipsWithUnits_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalConnectedMemberships?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_not?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_gt?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_lt?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_gte?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_lte?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalConnectedMemberships_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalDeposit?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_not?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_gt?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_lt?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_gte?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_lte?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalDeposit_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFADeposit?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_not?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_gt?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_lt?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_gte?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_lte?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFADeposit_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalGDADeposit?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_not?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_gt?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_lt?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_gte?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_lte?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalGDADeposit_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalOutflowRate?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_not?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalOutflowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFAOutflowRate?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_not?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFAOutflowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalGDAOutflowRate?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_not?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalGDAOutflowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountStreamed?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamed_not?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamed_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamed_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamed_gte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamed_lte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountStreamed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFAAmountStreamed?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamed_not?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamed_gt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamed_lt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamed_gte?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamed_lte?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFAAmountStreamed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountTransferred?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferred_not?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferred_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferred_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferred_gte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferred_lte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferred_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountTransferred_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountDistributed?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributed_not?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributed_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributed_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributed_gte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributed_lte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountDistributed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalSupply?: InputMaybe<Scalars["BigInt"]>;
  totalSupply_not?: InputMaybe<Scalars["BigInt"]>;
  totalSupply_gt?: InputMaybe<Scalars["BigInt"]>;
  totalSupply_lt?: InputMaybe<Scalars["BigInt"]>;
  totalSupply_gte?: InputMaybe<Scalars["BigInt"]>;
  totalSupply_lte?: InputMaybe<Scalars["BigInt"]>;
  totalSupply_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalSupply_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalNumberOfAccounts?: InputMaybe<Scalars["Int"]>;
  totalNumberOfAccounts_not?: InputMaybe<Scalars["Int"]>;
  totalNumberOfAccounts_gt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfAccounts_lt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfAccounts_gte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfAccounts_lte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfAccounts_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfAccounts_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfHolders?: InputMaybe<Scalars["Int"]>;
  totalNumberOfHolders_not?: InputMaybe<Scalars["Int"]>;
  totalNumberOfHolders_gt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfHolders_lt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfHolders_gte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfHolders_lte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfHolders_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfHolders_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  token?: InputMaybe<Scalars["String"]>;
  token_not?: InputMaybe<Scalars["String"]>;
  token_gt?: InputMaybe<Scalars["String"]>;
  token_lt?: InputMaybe<Scalars["String"]>;
  token_gte?: InputMaybe<Scalars["String"]>;
  token_lte?: InputMaybe<Scalars["String"]>;
  token_in?: InputMaybe<Array<Scalars["String"]>>;
  token_not_in?: InputMaybe<Array<Scalars["String"]>>;
  token_contains?: InputMaybe<Scalars["String"]>;
  token_contains_nocase?: InputMaybe<Scalars["String"]>;
  token_not_contains?: InputMaybe<Scalars["String"]>;
  token_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  token_starts_with?: InputMaybe<Scalars["String"]>;
  token_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  token_not_starts_with?: InputMaybe<Scalars["String"]>;
  token_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  token_ends_with?: InputMaybe<Scalars["String"]>;
  token_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  token_not_ends_with?: InputMaybe<Scalars["String"]>;
  token_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  token_?: InputMaybe<Token_filter>;
  tokenStatistic?: InputMaybe<Scalars["String"]>;
  tokenStatistic_not?: InputMaybe<Scalars["String"]>;
  tokenStatistic_gt?: InputMaybe<Scalars["String"]>;
  tokenStatistic_lt?: InputMaybe<Scalars["String"]>;
  tokenStatistic_gte?: InputMaybe<Scalars["String"]>;
  tokenStatistic_lte?: InputMaybe<Scalars["String"]>;
  tokenStatistic_in?: InputMaybe<Array<Scalars["String"]>>;
  tokenStatistic_not_in?: InputMaybe<Array<Scalars["String"]>>;
  tokenStatistic_contains?: InputMaybe<Scalars["String"]>;
  tokenStatistic_contains_nocase?: InputMaybe<Scalars["String"]>;
  tokenStatistic_not_contains?: InputMaybe<Scalars["String"]>;
  tokenStatistic_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  tokenStatistic_starts_with?: InputMaybe<Scalars["String"]>;
  tokenStatistic_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  tokenStatistic_not_starts_with?: InputMaybe<Scalars["String"]>;
  tokenStatistic_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  tokenStatistic_ends_with?: InputMaybe<Scalars["String"]>;
  tokenStatistic_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  tokenStatistic_not_ends_with?: InputMaybe<Scalars["String"]>;
  tokenStatistic_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  tokenStatistic_?: InputMaybe<TokenStatistic_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<TokenStatisticLog_filter>>>;
  or?: InputMaybe<Array<InputMaybe<TokenStatisticLog_filter>>>;
};

export type TokenStatisticLog_orderBy =
  | "id"
  | "timestamp"
  | "blockNumber"
  | "transactionHash"
  | "logIndex"
  | "order"
  | "triggeredByEventName"
  | "totalNumberOfActiveStreams"
  | "totalCFANumberOfActiveStreams"
  | "totalGDANumberOfActiveStreams"
  | "totalNumberOfClosedStreams"
  | "totalCFANumberOfClosedStreams"
  | "totalGDANumberOfClosedStreams"
  | "totalNumberOfIndexes"
  | "totalNumberOfActiveIndexes"
  | "totalSubscriptionsWithUnits"
  | "totalApprovedSubscriptions"
  | "totalNumberOfPools"
  | "totalNumberOfActivePools"
  | "totalMembershipsWithUnits"
  | "totalConnectedMemberships"
  | "totalDeposit"
  | "totalCFADeposit"
  | "totalGDADeposit"
  | "totalOutflowRate"
  | "totalCFAOutflowRate"
  | "totalGDAOutflowRate"
  | "totalAmountStreamed"
  | "totalCFAAmountStreamed"
  | "totalAmountTransferred"
  | "totalAmountDistributed"
  | "totalSupply"
  | "totalNumberOfAccounts"
  | "totalNumberOfHolders"
  | "token"
  | "token__id"
  | "token__createdAtTimestamp"
  | "token__createdAtBlockNumber"
  | "token__decimals"
  | "token__name"
  | "token__symbol"
  | "token__isSuperToken"
  | "token__isNativeAssetSuperToken"
  | "token__isListed"
  | "token__underlyingAddress"
  | "tokenStatistic"
  | "tokenStatistic__id"
  | "tokenStatistic__updatedAtTimestamp"
  | "tokenStatistic__updatedAtBlockNumber"
  | "tokenStatistic__totalNumberOfActiveStreams"
  | "tokenStatistic__totalCFANumberOfActiveStreams"
  | "tokenStatistic__totalGDANumberOfActiveStreams"
  | "tokenStatistic__totalNumberOfClosedStreams"
  | "tokenStatistic__totalCFANumberOfClosedStreams"
  | "tokenStatistic__totalGDANumberOfClosedStreams"
  | "tokenStatistic__totalNumberOfIndexes"
  | "tokenStatistic__totalNumberOfActiveIndexes"
  | "tokenStatistic__totalSubscriptionsWithUnits"
  | "tokenStatistic__totalApprovedSubscriptions"
  | "tokenStatistic__totalNumberOfPools"
  | "tokenStatistic__totalNumberOfActivePools"
  | "tokenStatistic__totalMembershipsWithUnits"
  | "tokenStatistic__totalConnectedMemberships"
  | "tokenStatistic__totalDeposit"
  | "tokenStatistic__totalCFADeposit"
  | "tokenStatistic__totalGDADeposit"
  | "tokenStatistic__totalOutflowRate"
  | "tokenStatistic__totalCFAOutflowRate"
  | "tokenStatistic__totalGDAOutflowRate"
  | "tokenStatistic__totalAmountStreamedUntilUpdatedAt"
  | "tokenStatistic__totalCFAAmountStreamedUntilUpdatedAt"
  | "tokenStatistic__totalAmountTransferredUntilUpdatedAt"
  | "tokenStatistic__totalAmountDistributedUntilUpdatedAt"
  | "tokenStatistic__totalSupply"
  | "tokenStatistic__totalNumberOfAccounts"
  | "tokenStatistic__totalNumberOfHolders";

export type TokenStatistic_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  updatedAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  updatedAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  updatedAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalNumberOfActiveStreams?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_not?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfActiveStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalCFANumberOfActiveStreams?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_not?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfActiveStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalCFANumberOfActiveStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalGDANumberOfActiveStreams?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_not?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfActiveStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalGDANumberOfActiveStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfClosedStreams?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_not?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfClosedStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfClosedStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalCFANumberOfClosedStreams?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_not?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalCFANumberOfClosedStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalCFANumberOfClosedStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalGDANumberOfClosedStreams?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_not?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_gt?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_lt?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_gte?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_lte?: InputMaybe<Scalars["Int"]>;
  totalGDANumberOfClosedStreams_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalGDANumberOfClosedStreams_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfIndexes?: InputMaybe<Scalars["Int"]>;
  totalNumberOfIndexes_not?: InputMaybe<Scalars["Int"]>;
  totalNumberOfIndexes_gt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfIndexes_lt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfIndexes_gte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfIndexes_lte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfIndexes_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfIndexes_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfActiveIndexes?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveIndexes_not?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveIndexes_gt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveIndexes_lt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveIndexes_gte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveIndexes_lte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActiveIndexes_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfActiveIndexes_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalSubscriptionsWithUnits?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_not?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_gt?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_lt?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_gte?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_lte?: InputMaybe<Scalars["Int"]>;
  totalSubscriptionsWithUnits_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalSubscriptionsWithUnits_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalApprovedSubscriptions?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_not?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_gt?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_lt?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_gte?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_lte?: InputMaybe<Scalars["Int"]>;
  totalApprovedSubscriptions_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalApprovedSubscriptions_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfPools?: InputMaybe<Scalars["Int"]>;
  totalNumberOfPools_not?: InputMaybe<Scalars["Int"]>;
  totalNumberOfPools_gt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfPools_lt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfPools_gte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfPools_lte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfPools_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfPools_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfActivePools?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActivePools_not?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActivePools_gt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActivePools_lt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActivePools_gte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActivePools_lte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfActivePools_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfActivePools_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalMembershipsWithUnits?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_not?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_gt?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_lt?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_gte?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_lte?: InputMaybe<Scalars["Int"]>;
  totalMembershipsWithUnits_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalMembershipsWithUnits_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalConnectedMemberships?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_not?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_gt?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_lt?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_gte?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_lte?: InputMaybe<Scalars["Int"]>;
  totalConnectedMemberships_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalConnectedMemberships_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalDeposit?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_not?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_gt?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_lt?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_gte?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_lte?: InputMaybe<Scalars["BigInt"]>;
  totalDeposit_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalDeposit_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFADeposit?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_not?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_gt?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_lt?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_gte?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_lte?: InputMaybe<Scalars["BigInt"]>;
  totalCFADeposit_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFADeposit_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalGDADeposit?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_not?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_gt?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_lt?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_gte?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_lte?: InputMaybe<Scalars["BigInt"]>;
  totalGDADeposit_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalGDADeposit_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalOutflowRate?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_not?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  totalOutflowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalOutflowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFAOutflowRate?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_not?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  totalCFAOutflowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalCFAOutflowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalGDAOutflowRate?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_not?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_gt?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_lt?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_gte?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_lte?: InputMaybe<Scalars["BigInt"]>;
  totalGDAOutflowRate_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalGDAOutflowRate_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountStreamedUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedUntilUpdatedAt_not?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedUntilUpdatedAt_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedUntilUpdatedAt_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedUntilUpdatedAt_gte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedUntilUpdatedAt_lte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountStreamedUntilUpdatedAt_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalAmountStreamedUntilUpdatedAt_not_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalCFAAmountStreamedUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedUntilUpdatedAt_not?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedUntilUpdatedAt_gt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedUntilUpdatedAt_lt?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedUntilUpdatedAt_gte?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedUntilUpdatedAt_lte?: InputMaybe<Scalars["BigInt"]>;
  totalCFAAmountStreamedUntilUpdatedAt_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalCFAAmountStreamedUntilUpdatedAt_not_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalAmountTransferredUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferredUntilUpdatedAt_not?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferredUntilUpdatedAt_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferredUntilUpdatedAt_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferredUntilUpdatedAt_gte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferredUntilUpdatedAt_lte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountTransferredUntilUpdatedAt_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalAmountTransferredUntilUpdatedAt_not_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalAmountDistributedUntilUpdatedAt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_not?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_gt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_lt?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_gte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_lte?: InputMaybe<Scalars["BigInt"]>;
  totalAmountDistributedUntilUpdatedAt_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalAmountDistributedUntilUpdatedAt_not_in?: InputMaybe<
    Array<Scalars["BigInt"]>
  >;
  totalSupply?: InputMaybe<Scalars["BigInt"]>;
  totalSupply_not?: InputMaybe<Scalars["BigInt"]>;
  totalSupply_gt?: InputMaybe<Scalars["BigInt"]>;
  totalSupply_lt?: InputMaybe<Scalars["BigInt"]>;
  totalSupply_gte?: InputMaybe<Scalars["BigInt"]>;
  totalSupply_lte?: InputMaybe<Scalars["BigInt"]>;
  totalSupply_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalSupply_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  totalNumberOfAccounts?: InputMaybe<Scalars["Int"]>;
  totalNumberOfAccounts_not?: InputMaybe<Scalars["Int"]>;
  totalNumberOfAccounts_gt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfAccounts_lt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfAccounts_gte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfAccounts_lte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfAccounts_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfAccounts_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfHolders?: InputMaybe<Scalars["Int"]>;
  totalNumberOfHolders_not?: InputMaybe<Scalars["Int"]>;
  totalNumberOfHolders_gt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfHolders_lt?: InputMaybe<Scalars["Int"]>;
  totalNumberOfHolders_gte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfHolders_lte?: InputMaybe<Scalars["Int"]>;
  totalNumberOfHolders_in?: InputMaybe<Array<Scalars["Int"]>>;
  totalNumberOfHolders_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  token?: InputMaybe<Scalars["String"]>;
  token_not?: InputMaybe<Scalars["String"]>;
  token_gt?: InputMaybe<Scalars["String"]>;
  token_lt?: InputMaybe<Scalars["String"]>;
  token_gte?: InputMaybe<Scalars["String"]>;
  token_lte?: InputMaybe<Scalars["String"]>;
  token_in?: InputMaybe<Array<Scalars["String"]>>;
  token_not_in?: InputMaybe<Array<Scalars["String"]>>;
  token_contains?: InputMaybe<Scalars["String"]>;
  token_contains_nocase?: InputMaybe<Scalars["String"]>;
  token_not_contains?: InputMaybe<Scalars["String"]>;
  token_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  token_starts_with?: InputMaybe<Scalars["String"]>;
  token_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  token_not_starts_with?: InputMaybe<Scalars["String"]>;
  token_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  token_ends_with?: InputMaybe<Scalars["String"]>;
  token_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  token_not_ends_with?: InputMaybe<Scalars["String"]>;
  token_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  token_?: InputMaybe<Token_filter>;
  tokenStatisticLogs_?: InputMaybe<TokenStatisticLog_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<TokenStatistic_filter>>>;
  or?: InputMaybe<Array<InputMaybe<TokenStatistic_filter>>>;
};

export type TokenStatistic_orderBy =
  | "id"
  | "updatedAtTimestamp"
  | "updatedAtBlockNumber"
  | "totalNumberOfActiveStreams"
  | "totalCFANumberOfActiveStreams"
  | "totalGDANumberOfActiveStreams"
  | "totalNumberOfClosedStreams"
  | "totalCFANumberOfClosedStreams"
  | "totalGDANumberOfClosedStreams"
  | "totalNumberOfIndexes"
  | "totalNumberOfActiveIndexes"
  | "totalSubscriptionsWithUnits"
  | "totalApprovedSubscriptions"
  | "totalNumberOfPools"
  | "totalNumberOfActivePools"
  | "totalMembershipsWithUnits"
  | "totalConnectedMemberships"
  | "totalDeposit"
  | "totalCFADeposit"
  | "totalGDADeposit"
  | "totalOutflowRate"
  | "totalCFAOutflowRate"
  | "totalGDAOutflowRate"
  | "totalAmountStreamedUntilUpdatedAt"
  | "totalCFAAmountStreamedUntilUpdatedAt"
  | "totalAmountTransferredUntilUpdatedAt"
  | "totalAmountDistributedUntilUpdatedAt"
  | "totalSupply"
  | "totalNumberOfAccounts"
  | "totalNumberOfHolders"
  | "token"
  | "token__id"
  | "token__createdAtTimestamp"
  | "token__createdAtBlockNumber"
  | "token__decimals"
  | "token__name"
  | "token__symbol"
  | "token__isSuperToken"
  | "token__isNativeAssetSuperToken"
  | "token__isListed"
  | "token__underlyingAddress"
  | "tokenStatisticLogs";

export type TokenUpgradedEvent = Event & {
  id: Scalars["ID"];
  account: Account;
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `account`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  token: Scalars["Bytes"];
  amount: Scalars["BigInt"];
};

export type TokenUpgradedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  account?: InputMaybe<Scalars["String"]>;
  account_not?: InputMaybe<Scalars["String"]>;
  account_gt?: InputMaybe<Scalars["String"]>;
  account_lt?: InputMaybe<Scalars["String"]>;
  account_gte?: InputMaybe<Scalars["String"]>;
  account_lte?: InputMaybe<Scalars["String"]>;
  account_in?: InputMaybe<Array<Scalars["String"]>>;
  account_not_in?: InputMaybe<Array<Scalars["String"]>>;
  account_contains?: InputMaybe<Scalars["String"]>;
  account_contains_nocase?: InputMaybe<Scalars["String"]>;
  account_not_contains?: InputMaybe<Scalars["String"]>;
  account_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  account_starts_with?: InputMaybe<Scalars["String"]>;
  account_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  account_not_starts_with?: InputMaybe<Scalars["String"]>;
  account_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  account_ends_with?: InputMaybe<Scalars["String"]>;
  account_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  account_not_ends_with?: InputMaybe<Scalars["String"]>;
  account_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  account_?: InputMaybe<Account_filter>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  amount?: InputMaybe<Scalars["BigInt"]>;
  amount_not?: InputMaybe<Scalars["BigInt"]>;
  amount_gt?: InputMaybe<Scalars["BigInt"]>;
  amount_lt?: InputMaybe<Scalars["BigInt"]>;
  amount_gte?: InputMaybe<Scalars["BigInt"]>;
  amount_lte?: InputMaybe<Scalars["BigInt"]>;
  amount_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  amount_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<TokenUpgradedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<TokenUpgradedEvent_filter>>>;
};

export type TokenUpgradedEvent_orderBy =
  | "id"
  | "account"
  | "account__id"
  | "account__createdAtTimestamp"
  | "account__createdAtBlockNumber"
  | "account__updatedAtTimestamp"
  | "account__updatedAtBlockNumber"
  | "account__isSuperApp"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "token"
  | "amount";

export type Token_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  createdAtTimestamp?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtTimestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtTimestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  createdAtBlockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  createdAtBlockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  decimals?: InputMaybe<Scalars["Int"]>;
  decimals_not?: InputMaybe<Scalars["Int"]>;
  decimals_gt?: InputMaybe<Scalars["Int"]>;
  decimals_lt?: InputMaybe<Scalars["Int"]>;
  decimals_gte?: InputMaybe<Scalars["Int"]>;
  decimals_lte?: InputMaybe<Scalars["Int"]>;
  decimals_in?: InputMaybe<Array<Scalars["Int"]>>;
  decimals_not_in?: InputMaybe<Array<Scalars["Int"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  symbol?: InputMaybe<Scalars["String"]>;
  symbol_not?: InputMaybe<Scalars["String"]>;
  symbol_gt?: InputMaybe<Scalars["String"]>;
  symbol_lt?: InputMaybe<Scalars["String"]>;
  symbol_gte?: InputMaybe<Scalars["String"]>;
  symbol_lte?: InputMaybe<Scalars["String"]>;
  symbol_in?: InputMaybe<Array<Scalars["String"]>>;
  symbol_not_in?: InputMaybe<Array<Scalars["String"]>>;
  symbol_contains?: InputMaybe<Scalars["String"]>;
  symbol_contains_nocase?: InputMaybe<Scalars["String"]>;
  symbol_not_contains?: InputMaybe<Scalars["String"]>;
  symbol_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  symbol_starts_with?: InputMaybe<Scalars["String"]>;
  symbol_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  symbol_not_starts_with?: InputMaybe<Scalars["String"]>;
  symbol_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  symbol_ends_with?: InputMaybe<Scalars["String"]>;
  symbol_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  symbol_not_ends_with?: InputMaybe<Scalars["String"]>;
  symbol_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  isSuperToken?: InputMaybe<Scalars["Boolean"]>;
  isSuperToken_not?: InputMaybe<Scalars["Boolean"]>;
  isSuperToken_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  isSuperToken_not_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  isNativeAssetSuperToken?: InputMaybe<Scalars["Boolean"]>;
  isNativeAssetSuperToken_not?: InputMaybe<Scalars["Boolean"]>;
  isNativeAssetSuperToken_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  isNativeAssetSuperToken_not_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  isListed?: InputMaybe<Scalars["Boolean"]>;
  isListed_not?: InputMaybe<Scalars["Boolean"]>;
  isListed_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  isListed_not_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  underlyingAddress?: InputMaybe<Scalars["Bytes"]>;
  underlyingAddress_not?: InputMaybe<Scalars["Bytes"]>;
  underlyingAddress_gt?: InputMaybe<Scalars["Bytes"]>;
  underlyingAddress_lt?: InputMaybe<Scalars["Bytes"]>;
  underlyingAddress_gte?: InputMaybe<Scalars["Bytes"]>;
  underlyingAddress_lte?: InputMaybe<Scalars["Bytes"]>;
  underlyingAddress_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  underlyingAddress_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  underlyingAddress_contains?: InputMaybe<Scalars["Bytes"]>;
  underlyingAddress_not_contains?: InputMaybe<Scalars["Bytes"]>;
  underlyingToken?: InputMaybe<Scalars["String"]>;
  underlyingToken_not?: InputMaybe<Scalars["String"]>;
  underlyingToken_gt?: InputMaybe<Scalars["String"]>;
  underlyingToken_lt?: InputMaybe<Scalars["String"]>;
  underlyingToken_gte?: InputMaybe<Scalars["String"]>;
  underlyingToken_lte?: InputMaybe<Scalars["String"]>;
  underlyingToken_in?: InputMaybe<Array<Scalars["String"]>>;
  underlyingToken_not_in?: InputMaybe<Array<Scalars["String"]>>;
  underlyingToken_contains?: InputMaybe<Scalars["String"]>;
  underlyingToken_contains_nocase?: InputMaybe<Scalars["String"]>;
  underlyingToken_not_contains?: InputMaybe<Scalars["String"]>;
  underlyingToken_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  underlyingToken_starts_with?: InputMaybe<Scalars["String"]>;
  underlyingToken_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  underlyingToken_not_starts_with?: InputMaybe<Scalars["String"]>;
  underlyingToken_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  underlyingToken_ends_with?: InputMaybe<Scalars["String"]>;
  underlyingToken_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  underlyingToken_not_ends_with?: InputMaybe<Scalars["String"]>;
  underlyingToken_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  underlyingToken_?: InputMaybe<Token_filter>;
  governanceConfig?: InputMaybe<Scalars["String"]>;
  governanceConfig_not?: InputMaybe<Scalars["String"]>;
  governanceConfig_gt?: InputMaybe<Scalars["String"]>;
  governanceConfig_lt?: InputMaybe<Scalars["String"]>;
  governanceConfig_gte?: InputMaybe<Scalars["String"]>;
  governanceConfig_lte?: InputMaybe<Scalars["String"]>;
  governanceConfig_in?: InputMaybe<Array<Scalars["String"]>>;
  governanceConfig_not_in?: InputMaybe<Array<Scalars["String"]>>;
  governanceConfig_contains?: InputMaybe<Scalars["String"]>;
  governanceConfig_contains_nocase?: InputMaybe<Scalars["String"]>;
  governanceConfig_not_contains?: InputMaybe<Scalars["String"]>;
  governanceConfig_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  governanceConfig_starts_with?: InputMaybe<Scalars["String"]>;
  governanceConfig_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  governanceConfig_not_starts_with?: InputMaybe<Scalars["String"]>;
  governanceConfig_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  governanceConfig_ends_with?: InputMaybe<Scalars["String"]>;
  governanceConfig_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  governanceConfig_not_ends_with?: InputMaybe<Scalars["String"]>;
  governanceConfig_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  governanceConfig_?: InputMaybe<TokenGovernanceConfig_filter>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<Token_filter>>>;
  or?: InputMaybe<Array<InputMaybe<Token_filter>>>;
};

export type Token_orderBy =
  | "id"
  | "createdAtTimestamp"
  | "createdAtBlockNumber"
  | "decimals"
  | "name"
  | "symbol"
  | "isSuperToken"
  | "isNativeAssetSuperToken"
  | "isListed"
  | "underlyingAddress"
  | "underlyingToken"
  | "underlyingToken__id"
  | "underlyingToken__createdAtTimestamp"
  | "underlyingToken__createdAtBlockNumber"
  | "underlyingToken__decimals"
  | "underlyingToken__name"
  | "underlyingToken__symbol"
  | "underlyingToken__isSuperToken"
  | "underlyingToken__isNativeAssetSuperToken"
  | "underlyingToken__isListed"
  | "underlyingToken__underlyingAddress"
  | "governanceConfig"
  | "governanceConfig__id"
  | "governanceConfig__createdAtTimestamp"
  | "governanceConfig__createdAtBlockNumber"
  | "governanceConfig__updatedAtTimestamp"
  | "governanceConfig__updatedAtBlockNumber"
  | "governanceConfig__isDefault"
  | "governanceConfig__rewardAddress"
  | "governanceConfig__liquidationPeriod"
  | "governanceConfig__patricianPeriod"
  | "governanceConfig__minimumDeposit";

export type TransferEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken if `isNFTTransfer` is false, otherwise the ConstantOutflowNFT or ConstantInflowNFT)
   * addresses[1] = `from`
   * addresses[2] = `to`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  from: Account;
  to: Account;
  isNFTTransfer: Scalars["Boolean"];
  /**
   * If `isNFTTransfer` is true, value is the `tokenId` of the NFT transferred.
   *
   */
  value: Scalars["BigInt"];
  /**
   * If `isNFTTransfer` is true, value is the NFT address, else it is the SuperToken address.
   *
   */
  token: Scalars["Bytes"];
};

export type TransferEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  from?: InputMaybe<Scalars["String"]>;
  from_not?: InputMaybe<Scalars["String"]>;
  from_gt?: InputMaybe<Scalars["String"]>;
  from_lt?: InputMaybe<Scalars["String"]>;
  from_gte?: InputMaybe<Scalars["String"]>;
  from_lte?: InputMaybe<Scalars["String"]>;
  from_in?: InputMaybe<Array<Scalars["String"]>>;
  from_not_in?: InputMaybe<Array<Scalars["String"]>>;
  from_contains?: InputMaybe<Scalars["String"]>;
  from_contains_nocase?: InputMaybe<Scalars["String"]>;
  from_not_contains?: InputMaybe<Scalars["String"]>;
  from_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  from_starts_with?: InputMaybe<Scalars["String"]>;
  from_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  from_not_starts_with?: InputMaybe<Scalars["String"]>;
  from_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  from_ends_with?: InputMaybe<Scalars["String"]>;
  from_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  from_not_ends_with?: InputMaybe<Scalars["String"]>;
  from_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  from_?: InputMaybe<Account_filter>;
  to?: InputMaybe<Scalars["String"]>;
  to_not?: InputMaybe<Scalars["String"]>;
  to_gt?: InputMaybe<Scalars["String"]>;
  to_lt?: InputMaybe<Scalars["String"]>;
  to_gte?: InputMaybe<Scalars["String"]>;
  to_lte?: InputMaybe<Scalars["String"]>;
  to_in?: InputMaybe<Array<Scalars["String"]>>;
  to_not_in?: InputMaybe<Array<Scalars["String"]>>;
  to_contains?: InputMaybe<Scalars["String"]>;
  to_contains_nocase?: InputMaybe<Scalars["String"]>;
  to_not_contains?: InputMaybe<Scalars["String"]>;
  to_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  to_starts_with?: InputMaybe<Scalars["String"]>;
  to_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  to_not_starts_with?: InputMaybe<Scalars["String"]>;
  to_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  to_ends_with?: InputMaybe<Scalars["String"]>;
  to_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  to_not_ends_with?: InputMaybe<Scalars["String"]>;
  to_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  to_?: InputMaybe<Account_filter>;
  isNFTTransfer?: InputMaybe<Scalars["Boolean"]>;
  isNFTTransfer_not?: InputMaybe<Scalars["Boolean"]>;
  isNFTTransfer_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  isNFTTransfer_not_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  value?: InputMaybe<Scalars["BigInt"]>;
  value_not?: InputMaybe<Scalars["BigInt"]>;
  value_gt?: InputMaybe<Scalars["BigInt"]>;
  value_lt?: InputMaybe<Scalars["BigInt"]>;
  value_gte?: InputMaybe<Scalars["BigInt"]>;
  value_lte?: InputMaybe<Scalars["BigInt"]>;
  value_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  value_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  token?: InputMaybe<Scalars["Bytes"]>;
  token_not?: InputMaybe<Scalars["Bytes"]>;
  token_gt?: InputMaybe<Scalars["Bytes"]>;
  token_lt?: InputMaybe<Scalars["Bytes"]>;
  token_gte?: InputMaybe<Scalars["Bytes"]>;
  token_lte?: InputMaybe<Scalars["Bytes"]>;
  token_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  token_contains?: InputMaybe<Scalars["Bytes"]>;
  token_not_contains?: InputMaybe<Scalars["Bytes"]>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<TransferEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<TransferEvent_filter>>>;
};

export type TransferEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "from"
  | "from__id"
  | "from__createdAtTimestamp"
  | "from__createdAtBlockNumber"
  | "from__updatedAtTimestamp"
  | "from__updatedAtBlockNumber"
  | "from__isSuperApp"
  | "to"
  | "to__id"
  | "to__createdAtTimestamp"
  | "to__createdAtBlockNumber"
  | "to__updatedAtTimestamp"
  | "to__updatedAtBlockNumber"
  | "to__isSuperApp"
  | "isNFTTransfer"
  | "value"
  | "token";

export type TrustedForwarderChangedEvent = Event & {
  id: Scalars["ID"];
  transactionHash: Scalars["Bytes"];
  gasPrice: Scalars["BigInt"];
  gasUsed: Scalars["BigInt"];
  timestamp: Scalars["BigInt"];
  name: Scalars["String"];
  /**
   * The address of the governance contract the event was emitted from.
   *
   */
  governanceAddress: Scalars["Bytes"];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `governanceAddress`
   * addresses[1] = `host`
   * addresses[2] = `superToken`
   * addresses[3] = `forwarder`
   *
   */
  addresses: Array<Scalars["Bytes"]>;
  blockNumber: Scalars["BigInt"];
  logIndex: Scalars["BigInt"];
  order: Scalars["BigInt"];
  host: Scalars["Bytes"];
  superToken: Scalars["Bytes"];
  isKeySet: Scalars["Boolean"];
  forwarder: Scalars["Bytes"];
  enabled: Scalars["Boolean"];
};

export type TrustedForwarderChangedEvent_filter = {
  id?: InputMaybe<Scalars["ID"]>;
  id_not?: InputMaybe<Scalars["ID"]>;
  id_gt?: InputMaybe<Scalars["ID"]>;
  id_lt?: InputMaybe<Scalars["ID"]>;
  id_gte?: InputMaybe<Scalars["ID"]>;
  id_lte?: InputMaybe<Scalars["ID"]>;
  id_in?: InputMaybe<Array<Scalars["ID"]>>;
  id_not_in?: InputMaybe<Array<Scalars["ID"]>>;
  transactionHash?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lt?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_gte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_lte?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  transactionHash_contains?: InputMaybe<Scalars["Bytes"]>;
  transactionHash_not_contains?: InputMaybe<Scalars["Bytes"]>;
  gasPrice?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_not?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lt?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_gte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_lte?: InputMaybe<Scalars["BigInt"]>;
  gasPrice_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasPrice_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_not?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lt?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_gte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_lte?: InputMaybe<Scalars["BigInt"]>;
  gasUsed_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  gasUsed_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp?: InputMaybe<Scalars["BigInt"]>;
  timestamp_not?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lt?: InputMaybe<Scalars["BigInt"]>;
  timestamp_gte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_lte?: InputMaybe<Scalars["BigInt"]>;
  timestamp_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  timestamp_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  name?: InputMaybe<Scalars["String"]>;
  name_not?: InputMaybe<Scalars["String"]>;
  name_gt?: InputMaybe<Scalars["String"]>;
  name_lt?: InputMaybe<Scalars["String"]>;
  name_gte?: InputMaybe<Scalars["String"]>;
  name_lte?: InputMaybe<Scalars["String"]>;
  name_in?: InputMaybe<Array<Scalars["String"]>>;
  name_not_in?: InputMaybe<Array<Scalars["String"]>>;
  name_contains?: InputMaybe<Scalars["String"]>;
  name_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_not_contains?: InputMaybe<Scalars["String"]>;
  name_not_contains_nocase?: InputMaybe<Scalars["String"]>;
  name_starts_with?: InputMaybe<Scalars["String"]>;
  name_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_starts_with?: InputMaybe<Scalars["String"]>;
  name_not_starts_with_nocase?: InputMaybe<Scalars["String"]>;
  name_ends_with?: InputMaybe<Scalars["String"]>;
  name_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  name_not_ends_with?: InputMaybe<Scalars["String"]>;
  name_not_ends_with_nocase?: InputMaybe<Scalars["String"]>;
  governanceAddress?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_not?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_gt?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_lt?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_gte?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_lte?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  governanceAddress_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  governanceAddress_contains?: InputMaybe<Scalars["Bytes"]>;
  governanceAddress_not_contains?: InputMaybe<Scalars["Bytes"]>;
  addresses?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains?: InputMaybe<Array<Scalars["Bytes"]>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars["Bytes"]>>;
  blockNumber?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_not?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lt?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_gte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_lte?: InputMaybe<Scalars["BigInt"]>;
  blockNumber_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  blockNumber_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex?: InputMaybe<Scalars["BigInt"]>;
  logIndex_not?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lt?: InputMaybe<Scalars["BigInt"]>;
  logIndex_gte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_lte?: InputMaybe<Scalars["BigInt"]>;
  logIndex_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  logIndex_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order?: InputMaybe<Scalars["BigInt"]>;
  order_not?: InputMaybe<Scalars["BigInt"]>;
  order_gt?: InputMaybe<Scalars["BigInt"]>;
  order_lt?: InputMaybe<Scalars["BigInt"]>;
  order_gte?: InputMaybe<Scalars["BigInt"]>;
  order_lte?: InputMaybe<Scalars["BigInt"]>;
  order_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  order_not_in?: InputMaybe<Array<Scalars["BigInt"]>>;
  host?: InputMaybe<Scalars["Bytes"]>;
  host_not?: InputMaybe<Scalars["Bytes"]>;
  host_gt?: InputMaybe<Scalars["Bytes"]>;
  host_lt?: InputMaybe<Scalars["Bytes"]>;
  host_gte?: InputMaybe<Scalars["Bytes"]>;
  host_lte?: InputMaybe<Scalars["Bytes"]>;
  host_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  host_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  host_contains?: InputMaybe<Scalars["Bytes"]>;
  host_not_contains?: InputMaybe<Scalars["Bytes"]>;
  superToken?: InputMaybe<Scalars["Bytes"]>;
  superToken_not?: InputMaybe<Scalars["Bytes"]>;
  superToken_gt?: InputMaybe<Scalars["Bytes"]>;
  superToken_lt?: InputMaybe<Scalars["Bytes"]>;
  superToken_gte?: InputMaybe<Scalars["Bytes"]>;
  superToken_lte?: InputMaybe<Scalars["Bytes"]>;
  superToken_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  superToken_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  superToken_contains?: InputMaybe<Scalars["Bytes"]>;
  superToken_not_contains?: InputMaybe<Scalars["Bytes"]>;
  isKeySet?: InputMaybe<Scalars["Boolean"]>;
  isKeySet_not?: InputMaybe<Scalars["Boolean"]>;
  isKeySet_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  isKeySet_not_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  forwarder?: InputMaybe<Scalars["Bytes"]>;
  forwarder_not?: InputMaybe<Scalars["Bytes"]>;
  forwarder_gt?: InputMaybe<Scalars["Bytes"]>;
  forwarder_lt?: InputMaybe<Scalars["Bytes"]>;
  forwarder_gte?: InputMaybe<Scalars["Bytes"]>;
  forwarder_lte?: InputMaybe<Scalars["Bytes"]>;
  forwarder_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  forwarder_not_in?: InputMaybe<Array<Scalars["Bytes"]>>;
  forwarder_contains?: InputMaybe<Scalars["Bytes"]>;
  forwarder_not_contains?: InputMaybe<Scalars["Bytes"]>;
  enabled?: InputMaybe<Scalars["Boolean"]>;
  enabled_not?: InputMaybe<Scalars["Boolean"]>;
  enabled_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  enabled_not_in?: InputMaybe<Array<Scalars["Boolean"]>>;
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<TrustedForwarderChangedEvent_filter>>>;
  or?: InputMaybe<Array<InputMaybe<TrustedForwarderChangedEvent_filter>>>;
};

export type TrustedForwarderChangedEvent_orderBy =
  | "id"
  | "transactionHash"
  | "gasPrice"
  | "gasUsed"
  | "timestamp"
  | "name"
  | "governanceAddress"
  | "addresses"
  | "blockNumber"
  | "logIndex"
  | "order"
  | "host"
  | "superToken"
  | "isKeySet"
  | "forwarder"
  | "enabled";

export type _Block_ = {
  /** The hash of the block */
  hash?: Maybe<Scalars["Bytes"]>;
  /** The block number */
  number: Scalars["Int"];
  /** Integer representation of the timestamp stored in blocks for the chain */
  timestamp?: Maybe<Scalars["Int"]>;
};

/** The type for the top-level _meta field */
export type _Meta_ = {
  /**
   * Information about a specific subgraph block. The hash of the block
   * will be null if the _meta field has a block constraint that asks for
   * a block number. It will be filled if the _meta field has no block constraint
   * and therefore asks for the latest  block
   *
   */
  block: _Block_;
  /** The deployment ID */
  deployment: Scalars["String"];
  /** If `true`, the subgraph encountered indexing errors at some past block */
  hasIndexingErrors: Scalars["Boolean"];
};

export type _SubgraphErrorPolicy_ =
  /** Data will be returned even if the subgraph has indexing errors */
  | "allow"
  /** If the subgraph has indexing errors, data will be omitted. The default. */
  | "deny";

export type WithIndex<TObject> = TObject & Record<string, any>;
export type ResolversObject<TObject> = WithIndex<TObject>;

export type ResolverTypeWrapper<T> = Promise<T> | T;

export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type LegacyStitchingResolver<TResult, TParent, TContext, TArgs> = {
  fragment: string;
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type NewStitchingResolver<TResult, TParent, TContext, TArgs> = {
  selectionSet: string | ((fieldNode: FieldNode) => SelectionSetNode);
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type StitchingResolver<TResult, TParent, TContext, TArgs> =
  | LegacyStitchingResolver<TResult, TParent, TContext, TArgs>
  | NewStitchingResolver<TResult, TParent, TContext, TArgs>;
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | ResolverWithResolve<TResult, TParent, TContext, TArgs>
  | StitchingResolver<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs,
> {
  subscribe: SubscriptionSubscribeFn<
    { [key in TKey]: TResult },
    TParent,
    TContext,
    TArgs
  >;
  resolve?: SubscriptionResolveFn<
    TResult,
    { [key in TKey]: TResult },
    TContext,
    TArgs
  >;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs,
> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<
  TResult,
  TKey extends string,
  TParent = {},
  TContext = {},
  TArgs = {},
> =
  | ((
      ...args: any[]
    ) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo,
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (
  obj: T,
  context: TContext,
  info: GraphQLResolveInfo,
) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<
  TResult = {},
  TParent = {},
  TContext = {},
  TArgs = {},
> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = ResolversObject<{
  Account: ResolverTypeWrapper<Account>;
  AccountTokenSnapshot: ResolverTypeWrapper<AccountTokenSnapshot>;
  AccountTokenSnapshotLog: ResolverTypeWrapper<AccountTokenSnapshotLog>;
  AccountTokenSnapshotLog_filter: AccountTokenSnapshotLog_filter;
  AccountTokenSnapshotLog_orderBy: AccountTokenSnapshotLog_orderBy;
  AccountTokenSnapshot_filter: AccountTokenSnapshot_filter;
  AccountTokenSnapshot_orderBy: AccountTokenSnapshot_orderBy;
  Account_filter: Account_filter;
  Account_orderBy: Account_orderBy;
  AgreementClassRegisteredEvent: ResolverTypeWrapper<AgreementClassRegisteredEvent>;
  AgreementClassRegisteredEvent_filter: AgreementClassRegisteredEvent_filter;
  AgreementClassRegisteredEvent_orderBy: AgreementClassRegisteredEvent_orderBy;
  AgreementClassUpdatedEvent: ResolverTypeWrapper<AgreementClassUpdatedEvent>;
  AgreementClassUpdatedEvent_filter: AgreementClassUpdatedEvent_filter;
  AgreementClassUpdatedEvent_orderBy: AgreementClassUpdatedEvent_orderBy;
  AgreementLiquidatedByEvent: ResolverTypeWrapper<AgreementLiquidatedByEvent>;
  AgreementLiquidatedByEvent_filter: AgreementLiquidatedByEvent_filter;
  AgreementLiquidatedByEvent_orderBy: AgreementLiquidatedByEvent_orderBy;
  AgreementLiquidatedV2Event: ResolverTypeWrapper<AgreementLiquidatedV2Event>;
  AgreementLiquidatedV2Event_filter: AgreementLiquidatedV2Event_filter;
  AgreementLiquidatedV2Event_orderBy: AgreementLiquidatedV2Event_orderBy;
  AppRegisteredEvent: ResolverTypeWrapper<AppRegisteredEvent>;
  AppRegisteredEvent_filter: AppRegisteredEvent_filter;
  AppRegisteredEvent_orderBy: AppRegisteredEvent_orderBy;
  ApprovalEvent: ResolverTypeWrapper<ApprovalEvent>;
  ApprovalEvent_filter: ApprovalEvent_filter;
  ApprovalEvent_orderBy: ApprovalEvent_orderBy;
  ApprovalForAllEvent: ResolverTypeWrapper<ApprovalForAllEvent>;
  ApprovalForAllEvent_filter: ApprovalForAllEvent_filter;
  ApprovalForAllEvent_orderBy: ApprovalForAllEvent_orderBy;
  BigDecimal: ResolverTypeWrapper<Scalars["BigDecimal"]>;
  BigInt: ResolverTypeWrapper<Scalars["BigInt"]>;
  BlockChangedFilter: BlockChangedFilter;
  Block_height: Block_height;
  BondIncreasedEvent: ResolverTypeWrapper<BondIncreasedEvent>;
  BondIncreasedEvent_filter: BondIncreasedEvent_filter;
  BondIncreasedEvent_orderBy: BondIncreasedEvent_orderBy;
  Boolean: ResolverTypeWrapper<Scalars["Boolean"]>;
  BufferAdjustedEvent: ResolverTypeWrapper<BufferAdjustedEvent>;
  BufferAdjustedEvent_filter: BufferAdjustedEvent_filter;
  BufferAdjustedEvent_orderBy: BufferAdjustedEvent_orderBy;
  BurnedEvent: ResolverTypeWrapper<BurnedEvent>;
  BurnedEvent_filter: BurnedEvent_filter;
  BurnedEvent_orderBy: BurnedEvent_orderBy;
  Bytes: ResolverTypeWrapper<Scalars["Bytes"]>;
  CFAv1LiquidationPeriodChangedEvent: ResolverTypeWrapper<CFAv1LiquidationPeriodChangedEvent>;
  CFAv1LiquidationPeriodChangedEvent_filter: CFAv1LiquidationPeriodChangedEvent_filter;
  CFAv1LiquidationPeriodChangedEvent_orderBy: CFAv1LiquidationPeriodChangedEvent_orderBy;
  ConfigChangedEvent: ResolverTypeWrapper<ConfigChangedEvent>;
  ConfigChangedEvent_filter: ConfigChangedEvent_filter;
  ConfigChangedEvent_orderBy: ConfigChangedEvent_orderBy;
  CustomSuperTokenCreatedEvent: ResolverTypeWrapper<CustomSuperTokenCreatedEvent>;
  CustomSuperTokenCreatedEvent_filter: CustomSuperTokenCreatedEvent_filter;
  CustomSuperTokenCreatedEvent_orderBy: CustomSuperTokenCreatedEvent_orderBy;
  DistributionClaimedEvent: ResolverTypeWrapper<DistributionClaimedEvent>;
  DistributionClaimedEvent_filter: DistributionClaimedEvent_filter;
  DistributionClaimedEvent_orderBy: DistributionClaimedEvent_orderBy;
  Event:
    | ResolversTypes["AgreementClassRegisteredEvent"]
    | ResolversTypes["AgreementClassUpdatedEvent"]
    | ResolversTypes["AgreementLiquidatedByEvent"]
    | ResolversTypes["AgreementLiquidatedV2Event"]
    | ResolversTypes["AppRegisteredEvent"]
    | ResolversTypes["ApprovalEvent"]
    | ResolversTypes["ApprovalForAllEvent"]
    | ResolversTypes["BondIncreasedEvent"]
    | ResolversTypes["BufferAdjustedEvent"]
    | ResolversTypes["BurnedEvent"]
    | ResolversTypes["CFAv1LiquidationPeriodChangedEvent"]
    | ResolversTypes["ConfigChangedEvent"]
    | ResolversTypes["CustomSuperTokenCreatedEvent"]
    | ResolversTypes["DistributionClaimedEvent"]
    | ResolversTypes["ExitRateChangedEvent"]
    | ResolversTypes["FlowDistributionUpdatedEvent"]
    | ResolversTypes["FlowOperatorUpdatedEvent"]
    | ResolversTypes["FlowUpdatedEvent"]
    | ResolversTypes["GovernanceReplacedEvent"]
    | ResolversTypes["IndexCreatedEvent"]
    | ResolversTypes["IndexDistributionClaimedEvent"]
    | ResolversTypes["IndexSubscribedEvent"]
    | ResolversTypes["IndexUnitsUpdatedEvent"]
    | ResolversTypes["IndexUnsubscribedEvent"]
    | ResolversTypes["IndexUpdatedEvent"]
    | ResolversTypes["InstantDistributionUpdatedEvent"]
    | ResolversTypes["JailEvent"]
    | ResolversTypes["MemberUnitsUpdatedEvent"]
    | ResolversTypes["MetadataUpdateEvent"]
    | ResolversTypes["MintedEvent"]
    | ResolversTypes["NewPICEvent"]
    | ResolversTypes["PPPConfigurationChangedEvent"]
    | ResolversTypes["PoolConnectionUpdatedEvent"]
    | ResolversTypes["PoolCreatedEvent"]
    | ResolversTypes["RewardAddressChangedEvent"]
    | ResolversTypes["RoleAdminChangedEvent"]
    | ResolversTypes["RoleGrantedEvent"]
    | ResolversTypes["RoleRevokedEvent"]
    | ResolversTypes["SentEvent"]
    | ResolversTypes["SetEvent"]
    | ResolversTypes["SubscriptionApprovedEvent"]
    | ResolversTypes["SubscriptionDistributionClaimedEvent"]
    | ResolversTypes["SubscriptionRevokedEvent"]
    | ResolversTypes["SubscriptionUnitsUpdatedEvent"]
    | ResolversTypes["SuperTokenCreatedEvent"]
    | ResolversTypes["SuperTokenFactoryUpdatedEvent"]
    | ResolversTypes["SuperTokenLogicCreatedEvent"]
    | ResolversTypes["SuperTokenLogicUpdatedEvent"]
    | ResolversTypes["SuperTokenMinimumDepositChangedEvent"]
    | ResolversTypes["TokenDowngradedEvent"]
    | ResolversTypes["TokenUpgradedEvent"]
    | ResolversTypes["TransferEvent"]
    | ResolversTypes["TrustedForwarderChangedEvent"];
  Event_filter: Event_filter;
  Event_orderBy: Event_orderBy;
  ExitRateChangedEvent: ResolverTypeWrapper<ExitRateChangedEvent>;
  ExitRateChangedEvent_filter: ExitRateChangedEvent_filter;
  ExitRateChangedEvent_orderBy: ExitRateChangedEvent_orderBy;
  Float: ResolverTypeWrapper<Scalars["Float"]>;
  FlowDistributionUpdatedEvent: ResolverTypeWrapper<FlowDistributionUpdatedEvent>;
  FlowDistributionUpdatedEvent_filter: FlowDistributionUpdatedEvent_filter;
  FlowDistributionUpdatedEvent_orderBy: FlowDistributionUpdatedEvent_orderBy;
  FlowOperator: ResolverTypeWrapper<FlowOperator>;
  FlowOperatorUpdatedEvent: ResolverTypeWrapper<FlowOperatorUpdatedEvent>;
  FlowOperatorUpdatedEvent_filter: FlowOperatorUpdatedEvent_filter;
  FlowOperatorUpdatedEvent_orderBy: FlowOperatorUpdatedEvent_orderBy;
  FlowOperator_filter: FlowOperator_filter;
  FlowOperator_orderBy: FlowOperator_orderBy;
  FlowUpdatedEvent: ResolverTypeWrapper<FlowUpdatedEvent>;
  FlowUpdatedEvent_filter: FlowUpdatedEvent_filter;
  FlowUpdatedEvent_orderBy: FlowUpdatedEvent_orderBy;
  GovernanceReplacedEvent: ResolverTypeWrapper<GovernanceReplacedEvent>;
  GovernanceReplacedEvent_filter: GovernanceReplacedEvent_filter;
  GovernanceReplacedEvent_orderBy: GovernanceReplacedEvent_orderBy;
  ID: ResolverTypeWrapper<Scalars["ID"]>;
  Index: ResolverTypeWrapper<Index>;
  IndexCreatedEvent: ResolverTypeWrapper<IndexCreatedEvent>;
  IndexCreatedEvent_filter: IndexCreatedEvent_filter;
  IndexCreatedEvent_orderBy: IndexCreatedEvent_orderBy;
  IndexDistributionClaimedEvent: ResolverTypeWrapper<IndexDistributionClaimedEvent>;
  IndexDistributionClaimedEvent_filter: IndexDistributionClaimedEvent_filter;
  IndexDistributionClaimedEvent_orderBy: IndexDistributionClaimedEvent_orderBy;
  IndexSubscribedEvent: ResolverTypeWrapper<IndexSubscribedEvent>;
  IndexSubscribedEvent_filter: IndexSubscribedEvent_filter;
  IndexSubscribedEvent_orderBy: IndexSubscribedEvent_orderBy;
  IndexSubscription: ResolverTypeWrapper<IndexSubscription>;
  IndexSubscription_filter: IndexSubscription_filter;
  IndexSubscription_orderBy: IndexSubscription_orderBy;
  IndexUnitsUpdatedEvent: ResolverTypeWrapper<IndexUnitsUpdatedEvent>;
  IndexUnitsUpdatedEvent_filter: IndexUnitsUpdatedEvent_filter;
  IndexUnitsUpdatedEvent_orderBy: IndexUnitsUpdatedEvent_orderBy;
  IndexUnsubscribedEvent: ResolverTypeWrapper<IndexUnsubscribedEvent>;
  IndexUnsubscribedEvent_filter: IndexUnsubscribedEvent_filter;
  IndexUnsubscribedEvent_orderBy: IndexUnsubscribedEvent_orderBy;
  IndexUpdatedEvent: ResolverTypeWrapper<IndexUpdatedEvent>;
  IndexUpdatedEvent_filter: IndexUpdatedEvent_filter;
  IndexUpdatedEvent_orderBy: IndexUpdatedEvent_orderBy;
  Index_filter: Index_filter;
  Index_orderBy: Index_orderBy;
  InstantDistributionUpdatedEvent: ResolverTypeWrapper<InstantDistributionUpdatedEvent>;
  InstantDistributionUpdatedEvent_filter: InstantDistributionUpdatedEvent_filter;
  InstantDistributionUpdatedEvent_orderBy: InstantDistributionUpdatedEvent_orderBy;
  Int: ResolverTypeWrapper<Scalars["Int"]>;
  Int8: ResolverTypeWrapper<Scalars["Int8"]>;
  JailEvent: ResolverTypeWrapper<JailEvent>;
  JailEvent_filter: JailEvent_filter;
  JailEvent_orderBy: JailEvent_orderBy;
  MemberUnitsUpdatedEvent: ResolverTypeWrapper<MemberUnitsUpdatedEvent>;
  MemberUnitsUpdatedEvent_filter: MemberUnitsUpdatedEvent_filter;
  MemberUnitsUpdatedEvent_orderBy: MemberUnitsUpdatedEvent_orderBy;
  MetadataUpdateEvent: ResolverTypeWrapper<MetadataUpdateEvent>;
  MetadataUpdateEvent_filter: MetadataUpdateEvent_filter;
  MetadataUpdateEvent_orderBy: MetadataUpdateEvent_orderBy;
  MintedEvent: ResolverTypeWrapper<MintedEvent>;
  MintedEvent_filter: MintedEvent_filter;
  MintedEvent_orderBy: MintedEvent_orderBy;
  NewPICEvent: ResolverTypeWrapper<NewPICEvent>;
  NewPICEvent_filter: NewPICEvent_filter;
  NewPICEvent_orderBy: NewPICEvent_orderBy;
  OrderDirection: OrderDirection;
  PPPConfigurationChangedEvent: ResolverTypeWrapper<PPPConfigurationChangedEvent>;
  PPPConfigurationChangedEvent_filter: PPPConfigurationChangedEvent_filter;
  PPPConfigurationChangedEvent_orderBy: PPPConfigurationChangedEvent_orderBy;
  Pool: ResolverTypeWrapper<Pool>;
  PoolConnectionUpdatedEvent: ResolverTypeWrapper<PoolConnectionUpdatedEvent>;
  PoolConnectionUpdatedEvent_filter: PoolConnectionUpdatedEvent_filter;
  PoolConnectionUpdatedEvent_orderBy: PoolConnectionUpdatedEvent_orderBy;
  PoolCreatedEvent: ResolverTypeWrapper<PoolCreatedEvent>;
  PoolCreatedEvent_filter: PoolCreatedEvent_filter;
  PoolCreatedEvent_orderBy: PoolCreatedEvent_orderBy;
  PoolDistributor: ResolverTypeWrapper<PoolDistributor>;
  PoolDistributor_filter: PoolDistributor_filter;
  PoolDistributor_orderBy: PoolDistributor_orderBy;
  PoolMember: ResolverTypeWrapper<PoolMember>;
  PoolMember_filter: PoolMember_filter;
  PoolMember_orderBy: PoolMember_orderBy;
  Pool_filter: Pool_filter;
  Pool_orderBy: Pool_orderBy;
  Query: ResolverTypeWrapper<{}>;
  ResolverEntry: ResolverTypeWrapper<ResolverEntry>;
  ResolverEntry_filter: ResolverEntry_filter;
  ResolverEntry_orderBy: ResolverEntry_orderBy;
  RewardAddressChangedEvent: ResolverTypeWrapper<RewardAddressChangedEvent>;
  RewardAddressChangedEvent_filter: RewardAddressChangedEvent_filter;
  RewardAddressChangedEvent_orderBy: RewardAddressChangedEvent_orderBy;
  RoleAdminChangedEvent: ResolverTypeWrapper<RoleAdminChangedEvent>;
  RoleAdminChangedEvent_filter: RoleAdminChangedEvent_filter;
  RoleAdminChangedEvent_orderBy: RoleAdminChangedEvent_orderBy;
  RoleGrantedEvent: ResolverTypeWrapper<RoleGrantedEvent>;
  RoleGrantedEvent_filter: RoleGrantedEvent_filter;
  RoleGrantedEvent_orderBy: RoleGrantedEvent_orderBy;
  RoleRevokedEvent: ResolverTypeWrapper<RoleRevokedEvent>;
  RoleRevokedEvent_filter: RoleRevokedEvent_filter;
  RoleRevokedEvent_orderBy: RoleRevokedEvent_orderBy;
  SFMeta: ResolverTypeWrapper<SFMeta>;
  SFMeta_filter: SFMeta_filter;
  SFMeta_orderBy: SFMeta_orderBy;
  SentEvent: ResolverTypeWrapper<SentEvent>;
  SentEvent_filter: SentEvent_filter;
  SentEvent_orderBy: SentEvent_orderBy;
  SetEvent: ResolverTypeWrapper<SetEvent>;
  SetEvent_filter: SetEvent_filter;
  SetEvent_orderBy: SetEvent_orderBy;
  Stream: ResolverTypeWrapper<Stream>;
  StreamPeriod: ResolverTypeWrapper<StreamPeriod>;
  StreamPeriod_filter: StreamPeriod_filter;
  StreamPeriod_orderBy: StreamPeriod_orderBy;
  StreamRevision: ResolverTypeWrapper<StreamRevision>;
  StreamRevision_filter: StreamRevision_filter;
  StreamRevision_orderBy: StreamRevision_orderBy;
  Stream_filter: Stream_filter;
  Stream_orderBy: Stream_orderBy;
  String: ResolverTypeWrapper<Scalars["String"]>;
  Subscription: ResolverTypeWrapper<{}>;
  SubscriptionApprovedEvent: ResolverTypeWrapper<SubscriptionApprovedEvent>;
  SubscriptionApprovedEvent_filter: SubscriptionApprovedEvent_filter;
  SubscriptionApprovedEvent_orderBy: SubscriptionApprovedEvent_orderBy;
  SubscriptionDistributionClaimedEvent: ResolverTypeWrapper<SubscriptionDistributionClaimedEvent>;
  SubscriptionDistributionClaimedEvent_filter: SubscriptionDistributionClaimedEvent_filter;
  SubscriptionDistributionClaimedEvent_orderBy: SubscriptionDistributionClaimedEvent_orderBy;
  SubscriptionRevokedEvent: ResolverTypeWrapper<SubscriptionRevokedEvent>;
  SubscriptionRevokedEvent_filter: SubscriptionRevokedEvent_filter;
  SubscriptionRevokedEvent_orderBy: SubscriptionRevokedEvent_orderBy;
  SubscriptionUnitsUpdatedEvent: ResolverTypeWrapper<SubscriptionUnitsUpdatedEvent>;
  SubscriptionUnitsUpdatedEvent_filter: SubscriptionUnitsUpdatedEvent_filter;
  SubscriptionUnitsUpdatedEvent_orderBy: SubscriptionUnitsUpdatedEvent_orderBy;
  SuperTokenCreatedEvent: ResolverTypeWrapper<SuperTokenCreatedEvent>;
  SuperTokenCreatedEvent_filter: SuperTokenCreatedEvent_filter;
  SuperTokenCreatedEvent_orderBy: SuperTokenCreatedEvent_orderBy;
  SuperTokenFactoryUpdatedEvent: ResolverTypeWrapper<SuperTokenFactoryUpdatedEvent>;
  SuperTokenFactoryUpdatedEvent_filter: SuperTokenFactoryUpdatedEvent_filter;
  SuperTokenFactoryUpdatedEvent_orderBy: SuperTokenFactoryUpdatedEvent_orderBy;
  SuperTokenLogicCreatedEvent: ResolverTypeWrapper<SuperTokenLogicCreatedEvent>;
  SuperTokenLogicCreatedEvent_filter: SuperTokenLogicCreatedEvent_filter;
  SuperTokenLogicCreatedEvent_orderBy: SuperTokenLogicCreatedEvent_orderBy;
  SuperTokenLogicUpdatedEvent: ResolverTypeWrapper<SuperTokenLogicUpdatedEvent>;
  SuperTokenLogicUpdatedEvent_filter: SuperTokenLogicUpdatedEvent_filter;
  SuperTokenLogicUpdatedEvent_orderBy: SuperTokenLogicUpdatedEvent_orderBy;
  SuperTokenMinimumDepositChangedEvent: ResolverTypeWrapper<SuperTokenMinimumDepositChangedEvent>;
  SuperTokenMinimumDepositChangedEvent_filter: SuperTokenMinimumDepositChangedEvent_filter;
  SuperTokenMinimumDepositChangedEvent_orderBy: SuperTokenMinimumDepositChangedEvent_orderBy;
  Token: ResolverTypeWrapper<Token>;
  TokenDowngradedEvent: ResolverTypeWrapper<TokenDowngradedEvent>;
  TokenDowngradedEvent_filter: TokenDowngradedEvent_filter;
  TokenDowngradedEvent_orderBy: TokenDowngradedEvent_orderBy;
  TokenGovernanceConfig: ResolverTypeWrapper<TokenGovernanceConfig>;
  TokenGovernanceConfig_filter: TokenGovernanceConfig_filter;
  TokenGovernanceConfig_orderBy: TokenGovernanceConfig_orderBy;
  TokenStatistic: ResolverTypeWrapper<TokenStatistic>;
  TokenStatisticLog: ResolverTypeWrapper<TokenStatisticLog>;
  TokenStatisticLog_filter: TokenStatisticLog_filter;
  TokenStatisticLog_orderBy: TokenStatisticLog_orderBy;
  TokenStatistic_filter: TokenStatistic_filter;
  TokenStatistic_orderBy: TokenStatistic_orderBy;
  TokenUpgradedEvent: ResolverTypeWrapper<TokenUpgradedEvent>;
  TokenUpgradedEvent_filter: TokenUpgradedEvent_filter;
  TokenUpgradedEvent_orderBy: TokenUpgradedEvent_orderBy;
  Token_filter: Token_filter;
  Token_orderBy: Token_orderBy;
  TransferEvent: ResolverTypeWrapper<TransferEvent>;
  TransferEvent_filter: TransferEvent_filter;
  TransferEvent_orderBy: TransferEvent_orderBy;
  TrustedForwarderChangedEvent: ResolverTypeWrapper<TrustedForwarderChangedEvent>;
  TrustedForwarderChangedEvent_filter: TrustedForwarderChangedEvent_filter;
  TrustedForwarderChangedEvent_orderBy: TrustedForwarderChangedEvent_orderBy;
  _Block_: ResolverTypeWrapper<_Block_>;
  _Meta_: ResolverTypeWrapper<_Meta_>;
  _SubgraphErrorPolicy_: _SubgraphErrorPolicy_;
}>;

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = ResolversObject<{
  Account: Account;
  AccountTokenSnapshot: AccountTokenSnapshot;
  AccountTokenSnapshotLog: AccountTokenSnapshotLog;
  AccountTokenSnapshotLog_filter: AccountTokenSnapshotLog_filter;
  AccountTokenSnapshot_filter: AccountTokenSnapshot_filter;
  Account_filter: Account_filter;
  AgreementClassRegisteredEvent: AgreementClassRegisteredEvent;
  AgreementClassRegisteredEvent_filter: AgreementClassRegisteredEvent_filter;
  AgreementClassUpdatedEvent: AgreementClassUpdatedEvent;
  AgreementClassUpdatedEvent_filter: AgreementClassUpdatedEvent_filter;
  AgreementLiquidatedByEvent: AgreementLiquidatedByEvent;
  AgreementLiquidatedByEvent_filter: AgreementLiquidatedByEvent_filter;
  AgreementLiquidatedV2Event: AgreementLiquidatedV2Event;
  AgreementLiquidatedV2Event_filter: AgreementLiquidatedV2Event_filter;
  AppRegisteredEvent: AppRegisteredEvent;
  AppRegisteredEvent_filter: AppRegisteredEvent_filter;
  ApprovalEvent: ApprovalEvent;
  ApprovalEvent_filter: ApprovalEvent_filter;
  ApprovalForAllEvent: ApprovalForAllEvent;
  ApprovalForAllEvent_filter: ApprovalForAllEvent_filter;
  BigDecimal: Scalars["BigDecimal"];
  BigInt: Scalars["BigInt"];
  BlockChangedFilter: BlockChangedFilter;
  Block_height: Block_height;
  BondIncreasedEvent: BondIncreasedEvent;
  BondIncreasedEvent_filter: BondIncreasedEvent_filter;
  Boolean: Scalars["Boolean"];
  BufferAdjustedEvent: BufferAdjustedEvent;
  BufferAdjustedEvent_filter: BufferAdjustedEvent_filter;
  BurnedEvent: BurnedEvent;
  BurnedEvent_filter: BurnedEvent_filter;
  Bytes: Scalars["Bytes"];
  CFAv1LiquidationPeriodChangedEvent: CFAv1LiquidationPeriodChangedEvent;
  CFAv1LiquidationPeriodChangedEvent_filter: CFAv1LiquidationPeriodChangedEvent_filter;
  ConfigChangedEvent: ConfigChangedEvent;
  ConfigChangedEvent_filter: ConfigChangedEvent_filter;
  CustomSuperTokenCreatedEvent: CustomSuperTokenCreatedEvent;
  CustomSuperTokenCreatedEvent_filter: CustomSuperTokenCreatedEvent_filter;
  DistributionClaimedEvent: DistributionClaimedEvent;
  DistributionClaimedEvent_filter: DistributionClaimedEvent_filter;
  Event:
    | ResolversParentTypes["AgreementClassRegisteredEvent"]
    | ResolversParentTypes["AgreementClassUpdatedEvent"]
    | ResolversParentTypes["AgreementLiquidatedByEvent"]
    | ResolversParentTypes["AgreementLiquidatedV2Event"]
    | ResolversParentTypes["AppRegisteredEvent"]
    | ResolversParentTypes["ApprovalEvent"]
    | ResolversParentTypes["ApprovalForAllEvent"]
    | ResolversParentTypes["BondIncreasedEvent"]
    | ResolversParentTypes["BufferAdjustedEvent"]
    | ResolversParentTypes["BurnedEvent"]
    | ResolversParentTypes["CFAv1LiquidationPeriodChangedEvent"]
    | ResolversParentTypes["ConfigChangedEvent"]
    | ResolversParentTypes["CustomSuperTokenCreatedEvent"]
    | ResolversParentTypes["DistributionClaimedEvent"]
    | ResolversParentTypes["ExitRateChangedEvent"]
    | ResolversParentTypes["FlowDistributionUpdatedEvent"]
    | ResolversParentTypes["FlowOperatorUpdatedEvent"]
    | ResolversParentTypes["FlowUpdatedEvent"]
    | ResolversParentTypes["GovernanceReplacedEvent"]
    | ResolversParentTypes["IndexCreatedEvent"]
    | ResolversParentTypes["IndexDistributionClaimedEvent"]
    | ResolversParentTypes["IndexSubscribedEvent"]
    | ResolversParentTypes["IndexUnitsUpdatedEvent"]
    | ResolversParentTypes["IndexUnsubscribedEvent"]
    | ResolversParentTypes["IndexUpdatedEvent"]
    | ResolversParentTypes["InstantDistributionUpdatedEvent"]
    | ResolversParentTypes["JailEvent"]
    | ResolversParentTypes["MemberUnitsUpdatedEvent"]
    | ResolversParentTypes["MetadataUpdateEvent"]
    | ResolversParentTypes["MintedEvent"]
    | ResolversParentTypes["NewPICEvent"]
    | ResolversParentTypes["PPPConfigurationChangedEvent"]
    | ResolversParentTypes["PoolConnectionUpdatedEvent"]
    | ResolversParentTypes["PoolCreatedEvent"]
    | ResolversParentTypes["RewardAddressChangedEvent"]
    | ResolversParentTypes["RoleAdminChangedEvent"]
    | ResolversParentTypes["RoleGrantedEvent"]
    | ResolversParentTypes["RoleRevokedEvent"]
    | ResolversParentTypes["SentEvent"]
    | ResolversParentTypes["SetEvent"]
    | ResolversParentTypes["SubscriptionApprovedEvent"]
    | ResolversParentTypes["SubscriptionDistributionClaimedEvent"]
    | ResolversParentTypes["SubscriptionRevokedEvent"]
    | ResolversParentTypes["SubscriptionUnitsUpdatedEvent"]
    | ResolversParentTypes["SuperTokenCreatedEvent"]
    | ResolversParentTypes["SuperTokenFactoryUpdatedEvent"]
    | ResolversParentTypes["SuperTokenLogicCreatedEvent"]
    | ResolversParentTypes["SuperTokenLogicUpdatedEvent"]
    | ResolversParentTypes["SuperTokenMinimumDepositChangedEvent"]
    | ResolversParentTypes["TokenDowngradedEvent"]
    | ResolversParentTypes["TokenUpgradedEvent"]
    | ResolversParentTypes["TransferEvent"]
    | ResolversParentTypes["TrustedForwarderChangedEvent"];
  Event_filter: Event_filter;
  ExitRateChangedEvent: ExitRateChangedEvent;
  ExitRateChangedEvent_filter: ExitRateChangedEvent_filter;
  Float: Scalars["Float"];
  FlowDistributionUpdatedEvent: FlowDistributionUpdatedEvent;
  FlowDistributionUpdatedEvent_filter: FlowDistributionUpdatedEvent_filter;
  FlowOperator: FlowOperator;
  FlowOperatorUpdatedEvent: FlowOperatorUpdatedEvent;
  FlowOperatorUpdatedEvent_filter: FlowOperatorUpdatedEvent_filter;
  FlowOperator_filter: FlowOperator_filter;
  FlowUpdatedEvent: FlowUpdatedEvent;
  FlowUpdatedEvent_filter: FlowUpdatedEvent_filter;
  GovernanceReplacedEvent: GovernanceReplacedEvent;
  GovernanceReplacedEvent_filter: GovernanceReplacedEvent_filter;
  ID: Scalars["ID"];
  Index: Index;
  IndexCreatedEvent: IndexCreatedEvent;
  IndexCreatedEvent_filter: IndexCreatedEvent_filter;
  IndexDistributionClaimedEvent: IndexDistributionClaimedEvent;
  IndexDistributionClaimedEvent_filter: IndexDistributionClaimedEvent_filter;
  IndexSubscribedEvent: IndexSubscribedEvent;
  IndexSubscribedEvent_filter: IndexSubscribedEvent_filter;
  IndexSubscription: IndexSubscription;
  IndexSubscription_filter: IndexSubscription_filter;
  IndexUnitsUpdatedEvent: IndexUnitsUpdatedEvent;
  IndexUnitsUpdatedEvent_filter: IndexUnitsUpdatedEvent_filter;
  IndexUnsubscribedEvent: IndexUnsubscribedEvent;
  IndexUnsubscribedEvent_filter: IndexUnsubscribedEvent_filter;
  IndexUpdatedEvent: IndexUpdatedEvent;
  IndexUpdatedEvent_filter: IndexUpdatedEvent_filter;
  Index_filter: Index_filter;
  InstantDistributionUpdatedEvent: InstantDistributionUpdatedEvent;
  InstantDistributionUpdatedEvent_filter: InstantDistributionUpdatedEvent_filter;
  Int: Scalars["Int"];
  Int8: Scalars["Int8"];
  JailEvent: JailEvent;
  JailEvent_filter: JailEvent_filter;
  MemberUnitsUpdatedEvent: MemberUnitsUpdatedEvent;
  MemberUnitsUpdatedEvent_filter: MemberUnitsUpdatedEvent_filter;
  MetadataUpdateEvent: MetadataUpdateEvent;
  MetadataUpdateEvent_filter: MetadataUpdateEvent_filter;
  MintedEvent: MintedEvent;
  MintedEvent_filter: MintedEvent_filter;
  NewPICEvent: NewPICEvent;
  NewPICEvent_filter: NewPICEvent_filter;
  PPPConfigurationChangedEvent: PPPConfigurationChangedEvent;
  PPPConfigurationChangedEvent_filter: PPPConfigurationChangedEvent_filter;
  Pool: Pool;
  PoolConnectionUpdatedEvent: PoolConnectionUpdatedEvent;
  PoolConnectionUpdatedEvent_filter: PoolConnectionUpdatedEvent_filter;
  PoolCreatedEvent: PoolCreatedEvent;
  PoolCreatedEvent_filter: PoolCreatedEvent_filter;
  PoolDistributor: PoolDistributor;
  PoolDistributor_filter: PoolDistributor_filter;
  PoolMember: PoolMember;
  PoolMember_filter: PoolMember_filter;
  Pool_filter: Pool_filter;
  Query: {};
  ResolverEntry: ResolverEntry;
  ResolverEntry_filter: ResolverEntry_filter;
  RewardAddressChangedEvent: RewardAddressChangedEvent;
  RewardAddressChangedEvent_filter: RewardAddressChangedEvent_filter;
  RoleAdminChangedEvent: RoleAdminChangedEvent;
  RoleAdminChangedEvent_filter: RoleAdminChangedEvent_filter;
  RoleGrantedEvent: RoleGrantedEvent;
  RoleGrantedEvent_filter: RoleGrantedEvent_filter;
  RoleRevokedEvent: RoleRevokedEvent;
  RoleRevokedEvent_filter: RoleRevokedEvent_filter;
  SFMeta: SFMeta;
  SFMeta_filter: SFMeta_filter;
  SentEvent: SentEvent;
  SentEvent_filter: SentEvent_filter;
  SetEvent: SetEvent;
  SetEvent_filter: SetEvent_filter;
  Stream: Stream;
  StreamPeriod: StreamPeriod;
  StreamPeriod_filter: StreamPeriod_filter;
  StreamRevision: StreamRevision;
  StreamRevision_filter: StreamRevision_filter;
  Stream_filter: Stream_filter;
  String: Scalars["String"];
  Subscription: {};
  SubscriptionApprovedEvent: SubscriptionApprovedEvent;
  SubscriptionApprovedEvent_filter: SubscriptionApprovedEvent_filter;
  SubscriptionDistributionClaimedEvent: SubscriptionDistributionClaimedEvent;
  SubscriptionDistributionClaimedEvent_filter: SubscriptionDistributionClaimedEvent_filter;
  SubscriptionRevokedEvent: SubscriptionRevokedEvent;
  SubscriptionRevokedEvent_filter: SubscriptionRevokedEvent_filter;
  SubscriptionUnitsUpdatedEvent: SubscriptionUnitsUpdatedEvent;
  SubscriptionUnitsUpdatedEvent_filter: SubscriptionUnitsUpdatedEvent_filter;
  SuperTokenCreatedEvent: SuperTokenCreatedEvent;
  SuperTokenCreatedEvent_filter: SuperTokenCreatedEvent_filter;
  SuperTokenFactoryUpdatedEvent: SuperTokenFactoryUpdatedEvent;
  SuperTokenFactoryUpdatedEvent_filter: SuperTokenFactoryUpdatedEvent_filter;
  SuperTokenLogicCreatedEvent: SuperTokenLogicCreatedEvent;
  SuperTokenLogicCreatedEvent_filter: SuperTokenLogicCreatedEvent_filter;
  SuperTokenLogicUpdatedEvent: SuperTokenLogicUpdatedEvent;
  SuperTokenLogicUpdatedEvent_filter: SuperTokenLogicUpdatedEvent_filter;
  SuperTokenMinimumDepositChangedEvent: SuperTokenMinimumDepositChangedEvent;
  SuperTokenMinimumDepositChangedEvent_filter: SuperTokenMinimumDepositChangedEvent_filter;
  Token: Token;
  TokenDowngradedEvent: TokenDowngradedEvent;
  TokenDowngradedEvent_filter: TokenDowngradedEvent_filter;
  TokenGovernanceConfig: TokenGovernanceConfig;
  TokenGovernanceConfig_filter: TokenGovernanceConfig_filter;
  TokenStatistic: TokenStatistic;
  TokenStatisticLog: TokenStatisticLog;
  TokenStatisticLog_filter: TokenStatisticLog_filter;
  TokenStatistic_filter: TokenStatistic_filter;
  TokenUpgradedEvent: TokenUpgradedEvent;
  TokenUpgradedEvent_filter: TokenUpgradedEvent_filter;
  Token_filter: Token_filter;
  TransferEvent: TransferEvent;
  TransferEvent_filter: TransferEvent_filter;
  TrustedForwarderChangedEvent: TrustedForwarderChangedEvent;
  TrustedForwarderChangedEvent_filter: TrustedForwarderChangedEvent_filter;
  _Block_: _Block_;
  _Meta_: _Meta_;
}>;

export type entityDirectiveArgs = {};

export type entityDirectiveResolver<
  Result,
  Parent,
  ContextType = MeshContext,
  Args = entityDirectiveArgs,
> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type subgraphIdDirectiveArgs = {
  id: Scalars["String"];
};

export type subgraphIdDirectiveResolver<
  Result,
  Parent,
  ContextType = MeshContext,
  Args = subgraphIdDirectiveArgs,
> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type derivedFromDirectiveArgs = {
  field: Scalars["String"];
};

export type derivedFromDirectiveResolver<
  Result,
  Parent,
  ContextType = MeshContext,
  Args = derivedFromDirectiveArgs,
> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type AccountResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["Account"] = ResolversParentTypes["Account"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  createdAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  createdAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  isSuperApp?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  inflows?: Resolver<
    Array<ResolversTypes["Stream"]>,
    ParentType,
    ContextType,
    RequireFields<AccountinflowsArgs, "skip" | "first">
  >;
  outflows?: Resolver<
    Array<ResolversTypes["Stream"]>,
    ParentType,
    ContextType,
    RequireFields<AccountoutflowsArgs, "skip" | "first">
  >;
  subscriptions?: Resolver<
    Array<ResolversTypes["IndexSubscription"]>,
    ParentType,
    ContextType,
    RequireFields<AccountsubscriptionsArgs, "skip" | "first">
  >;
  publishedIndexes?: Resolver<
    Array<ResolversTypes["Index"]>,
    ParentType,
    ContextType,
    RequireFields<AccountpublishedIndexesArgs, "skip" | "first">
  >;
  pools?: Resolver<
    Array<ResolversTypes["Pool"]>,
    ParentType,
    ContextType,
    RequireFields<AccountpoolsArgs, "skip" | "first">
  >;
  poolMemberships?: Resolver<
    Array<ResolversTypes["PoolMember"]>,
    ParentType,
    ContextType,
    RequireFields<AccountpoolMembershipsArgs, "skip" | "first">
  >;
  sentTransferEvents?: Resolver<
    Array<ResolversTypes["TransferEvent"]>,
    ParentType,
    ContextType,
    RequireFields<AccountsentTransferEventsArgs, "skip" | "first">
  >;
  receivedTransferEvents?: Resolver<
    Array<ResolversTypes["TransferEvent"]>,
    ParentType,
    ContextType,
    RequireFields<AccountreceivedTransferEventsArgs, "skip" | "first">
  >;
  tokenUpgradedEvents?: Resolver<
    Array<ResolversTypes["TokenUpgradedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<AccounttokenUpgradedEventsArgs, "skip" | "first">
  >;
  tokenDowngradedEvents?: Resolver<
    Array<ResolversTypes["TokenDowngradedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<AccounttokenDowngradedEventsArgs, "skip" | "first">
  >;
  accountTokenSnapshots?: Resolver<
    Array<ResolversTypes["AccountTokenSnapshot"]>,
    ParentType,
    ContextType,
    RequireFields<AccountaccountTokenSnapshotsArgs, "skip" | "first">
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AccountTokenSnapshotResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["AccountTokenSnapshot"] = ResolversParentTypes["AccountTokenSnapshot"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  createdAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  createdAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  isLiquidationEstimateOptimistic?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  maybeCriticalAtTimestamp?: Resolver<
    Maybe<ResolversTypes["BigInt"]>,
    ParentType,
    ContextType
  >;
  totalNumberOfActiveStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalCFANumberOfActiveStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalGDANumberOfActiveStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  activeOutgoingStreamCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  activeCFAOutgoingStreamCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  activeGDAOutgoingStreamCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  activeIncomingStreamCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalNumberOfClosedStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalCFANumberOfClosedStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalGDANumberOfClosedStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  inactiveOutgoingStreamCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  inactiveCFAOutgoingStreamCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  inactiveGDAOutgoingStreamCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  inactiveIncomingStreamCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalSubscriptionsWithUnits?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalApprovedSubscriptions?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalMembershipsWithUnits?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalConnectedMemberships?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  balanceUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalDeposit?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalCFADeposit?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalGDADeposit?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalNetFlowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalCFANetFlowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalInflowRate?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalOutflowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalCFAOutflowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalGDAOutflowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalAmountStreamedInUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalAmountStreamedOutUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalCFAAmountStreamedOutUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalAmountStreamedUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalCFAAmountStreamedUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalAmountTransferredUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  account?: Resolver<ResolversTypes["Account"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  flowOperators?: Resolver<
    Array<ResolversTypes["FlowOperator"]>,
    ParentType,
    ContextType,
    RequireFields<AccountTokenSnapshotflowOperatorsArgs, "skip" | "first">
  >;
  accountTokenSnapshotLogs?: Resolver<
    Array<ResolversTypes["AccountTokenSnapshotLog"]>,
    ParentType,
    ContextType,
    RequireFields<
      AccountTokenSnapshotaccountTokenSnapshotLogsArgs,
      "skip" | "first"
    >
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AccountTokenSnapshotLogResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["AccountTokenSnapshotLog"] = ResolversParentTypes["AccountTokenSnapshotLog"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  triggeredByEventName?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  maybeCriticalAtTimestamp?: Resolver<
    Maybe<ResolversTypes["BigInt"]>,
    ParentType,
    ContextType
  >;
  totalNumberOfActiveStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalCFANumberOfActiveStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalGDANumberOfActiveStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  activeOutgoingStreamCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  activeCFAOutgoingStreamCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  activeGDAOutgoingStreamCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  activeIncomingStreamCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalNumberOfClosedStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalCFANumberOfClosedStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalGDANumberOfClosedStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  inactiveOutgoingStreamCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  inactiveCFAOutgoingStreamCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  inactiveGDAOutgoingStreamCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  inactiveIncomingStreamCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalSubscriptionsWithUnits?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalApprovedSubscriptions?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalMembershipsWithUnits?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalConnectedMemberships?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  balance?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalDeposit?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalCFADeposit?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalGDADeposit?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalNetFlowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalCFANetFlowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalInflowRate?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalOutflowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalCFAOutflowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalGDAOutflowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalAmountStreamedIn?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalAmountStreamedOut?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalCFAAmountStreamedOut?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalAmountStreamed?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalCFAAmountStreamed?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalAmountTransferred?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  account?: Resolver<ResolversTypes["Account"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  accountTokenSnapshot?: Resolver<
    ResolversTypes["AccountTokenSnapshot"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AgreementClassRegisteredEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["AgreementClassRegisteredEvent"] = ResolversParentTypes["AgreementClassRegisteredEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  agreementType?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  code?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AgreementClassUpdatedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["AgreementClassUpdatedEvent"] = ResolversParentTypes["AgreementClassUpdatedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  agreementType?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  code?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AgreementLiquidatedByEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["AgreementLiquidatedByEvent"] = ResolversParentTypes["AgreementLiquidatedByEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  liquidatorAccount?: Resolver<
    ResolversTypes["Bytes"],
    ParentType,
    ContextType
  >;
  agreementClass?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  agreementId?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  penaltyAccount?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  bondAccount?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  rewardAmount?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  bailoutAmount?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  deposit?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  flowRateAtLiquidation?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AgreementLiquidatedV2EventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["AgreementLiquidatedV2Event"] = ResolversParentTypes["AgreementLiquidatedV2Event"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  agreementClass?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  agreementId?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  liquidatorAccount?: Resolver<
    ResolversTypes["Bytes"],
    ParentType,
    ContextType
  >;
  targetAccount?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  rewardAmountReceiver?: Resolver<
    ResolversTypes["Bytes"],
    ParentType,
    ContextType
  >;
  rewardAmount?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  targetAccountBalanceDelta?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  version?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  liquidationType?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  deposit?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  flowRateAtLiquidation?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  rewardAccount?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AppRegisteredEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["AppRegisteredEvent"] = ResolversParentTypes["AppRegisteredEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  app?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ApprovalEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["ApprovalEvent"] = ResolversParentTypes["ApprovalEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes["Account"], ParentType, ContextType>;
  to?: Resolver<ResolversTypes["Account"], ParentType, ContextType>;
  isNFTApproval?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  amount?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  tokenId?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ApprovalForAllEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["ApprovalForAllEvent"] = ResolversParentTypes["ApprovalForAllEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes["Account"], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes["Account"], ParentType, ContextType>;
  approved?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface BigDecimalScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes["BigDecimal"], any> {
  name: "BigDecimal";
}

export interface BigIntScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes["BigInt"], any> {
  name: "BigInt";
}

export type BondIncreasedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["BondIncreasedEvent"] = ResolversParentTypes["BondIncreasedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  additionalBond?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BufferAdjustedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["BufferAdjustedEvent"] = ResolversParentTypes["BufferAdjustedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  bufferDelta?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  newBufferAmount?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalBufferAmount?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  pool?: Resolver<ResolversTypes["Pool"], ParentType, ContextType>;
  poolDistributor?: Resolver<
    ResolversTypes["PoolDistributor"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BurnedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["BurnedEvent"] = ResolversParentTypes["BurnedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  from?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  amount?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  data?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  operatorData?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface BytesScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes["Bytes"], any> {
  name: "Bytes";
}

export type CFAv1LiquidationPeriodChangedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["CFAv1LiquidationPeriodChangedEvent"] = ResolversParentTypes["CFAv1LiquidationPeriodChangedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  governanceAddress?: Resolver<
    ResolversTypes["Bytes"],
    ParentType,
    ContextType
  >;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  host?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  superToken?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  isKeySet?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  liquidationPeriod?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ConfigChangedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["ConfigChangedEvent"] = ResolversParentTypes["ConfigChangedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  governanceAddress?: Resolver<
    ResolversTypes["Bytes"],
    ParentType,
    ContextType
  >;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  host?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  superToken?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  key?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  isKeySet?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  value?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CustomSuperTokenCreatedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["CustomSuperTokenCreatedEvent"] = ResolversParentTypes["CustomSuperTokenCreatedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DistributionClaimedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["DistributionClaimedEvent"] = ResolversParentTypes["DistributionClaimedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  claimedAmount?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalClaimed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  pool?: Resolver<ResolversTypes["Pool"], ParentType, ContextType>;
  poolMember?: Resolver<ResolversTypes["PoolMember"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["Event"] = ResolversParentTypes["Event"],
> = ResolversObject<{
  __resolveType: TypeResolveFn<
    | "AgreementClassRegisteredEvent"
    | "AgreementClassUpdatedEvent"
    | "AgreementLiquidatedByEvent"
    | "AgreementLiquidatedV2Event"
    | "AppRegisteredEvent"
    | "ApprovalEvent"
    | "ApprovalForAllEvent"
    | "BondIncreasedEvent"
    | "BufferAdjustedEvent"
    | "BurnedEvent"
    | "CFAv1LiquidationPeriodChangedEvent"
    | "ConfigChangedEvent"
    | "CustomSuperTokenCreatedEvent"
    | "DistributionClaimedEvent"
    | "ExitRateChangedEvent"
    | "FlowDistributionUpdatedEvent"
    | "FlowOperatorUpdatedEvent"
    | "FlowUpdatedEvent"
    | "GovernanceReplacedEvent"
    | "IndexCreatedEvent"
    | "IndexDistributionClaimedEvent"
    | "IndexSubscribedEvent"
    | "IndexUnitsUpdatedEvent"
    | "IndexUnsubscribedEvent"
    | "IndexUpdatedEvent"
    | "InstantDistributionUpdatedEvent"
    | "JailEvent"
    | "MemberUnitsUpdatedEvent"
    | "MetadataUpdateEvent"
    | "MintedEvent"
    | "NewPICEvent"
    | "PPPConfigurationChangedEvent"
    | "PoolConnectionUpdatedEvent"
    | "PoolCreatedEvent"
    | "RewardAddressChangedEvent"
    | "RoleAdminChangedEvent"
    | "RoleGrantedEvent"
    | "RoleRevokedEvent"
    | "SentEvent"
    | "SetEvent"
    | "SubscriptionApprovedEvent"
    | "SubscriptionDistributionClaimedEvent"
    | "SubscriptionRevokedEvent"
    | "SubscriptionUnitsUpdatedEvent"
    | "SuperTokenCreatedEvent"
    | "SuperTokenFactoryUpdatedEvent"
    | "SuperTokenLogicCreatedEvent"
    | "SuperTokenLogicUpdatedEvent"
    | "SuperTokenMinimumDepositChangedEvent"
    | "TokenDowngradedEvent"
    | "TokenUpgradedEvent"
    | "TransferEvent"
    | "TrustedForwarderChangedEvent",
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
}>;

export type ExitRateChangedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["ExitRateChangedEvent"] = ResolversParentTypes["ExitRateChangedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  exitRate?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FlowDistributionUpdatedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["FlowDistributionUpdatedEvent"] = ResolversParentTypes["FlowDistributionUpdatedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  oldFlowRate?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  newDistributorToPoolFlowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  newTotalDistributionFlowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  adjustmentFlowRecipient?: Resolver<
    ResolversTypes["Bytes"],
    ParentType,
    ContextType
  >;
  adjustmentFlowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalUnits?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  userData?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  pool?: Resolver<ResolversTypes["Pool"], ParentType, ContextType>;
  poolDistributor?: Resolver<
    ResolversTypes["PoolDistributor"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FlowOperatorResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["FlowOperator"] = ResolversParentTypes["FlowOperator"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  createdAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  createdAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  permissions?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  flowRateAllowanceGranted?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  flowRateAllowanceRemaining?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  allowance?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  flowOperator?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  sender?: Resolver<ResolversTypes["Account"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  accountTokenSnapshot?: Resolver<
    ResolversTypes["AccountTokenSnapshot"],
    ParentType,
    ContextType
  >;
  flowOperatorUpdatedEvents?: Resolver<
    Array<ResolversTypes["FlowOperatorUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<FlowOperatorflowOperatorUpdatedEventsArgs, "skip" | "first">
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FlowOperatorUpdatedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["FlowOperatorUpdatedEvent"] = ResolversParentTypes["FlowOperatorUpdatedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  sender?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  permissions?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  flowRateAllowance?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  flowOperator?: Resolver<
    ResolversTypes["FlowOperator"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FlowUpdatedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["FlowUpdatedEvent"] = ResolversParentTypes["FlowUpdatedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  sender?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  receiver?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  flowOperator?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  flowRate?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalSenderFlowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalReceiverFlowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  deposit?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  userData?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  oldFlowRate?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  type?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  totalAmountStreamedUntilTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  stream?: Resolver<ResolversTypes["Stream"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GovernanceReplacedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["GovernanceReplacedEvent"] = ResolversParentTypes["GovernanceReplacedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  oldGovernance?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  newGovernance?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IndexResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["Index"] = ResolversParentTypes["Index"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  createdAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  createdAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  indexId?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  indexValue?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalSubscriptionsWithUnits?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalUnitsPending?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalUnitsApproved?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalUnits?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalAmountDistributedUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  token?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  publisher?: Resolver<ResolversTypes["Account"], ParentType, ContextType>;
  subscriptions?: Resolver<
    Array<ResolversTypes["IndexSubscription"]>,
    ParentType,
    ContextType,
    RequireFields<IndexsubscriptionsArgs, "skip" | "first">
  >;
  indexCreatedEvent?: Resolver<
    ResolversTypes["IndexCreatedEvent"],
    ParentType,
    ContextType
  >;
  indexDistributionClaimedEvents?: Resolver<
    Array<ResolversTypes["IndexDistributionClaimedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<IndexindexDistributionClaimedEventsArgs, "skip" | "first">
  >;
  indexUpdatedEvents?: Resolver<
    Array<ResolversTypes["IndexUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<IndexindexUpdatedEventsArgs, "skip" | "first">
  >;
  indexSubscribedEvents?: Resolver<
    Array<ResolversTypes["IndexSubscribedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<IndexindexSubscribedEventsArgs, "skip" | "first">
  >;
  indexUnitsUpdatedEvents?: Resolver<
    Array<ResolversTypes["IndexUnitsUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<IndexindexUnitsUpdatedEventsArgs, "skip" | "first">
  >;
  indexUnsubscribedEvents?: Resolver<
    Array<ResolversTypes["IndexUnsubscribedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<IndexindexUnsubscribedEventsArgs, "skip" | "first">
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IndexCreatedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["IndexCreatedEvent"] = ResolversParentTypes["IndexCreatedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  publisher?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  indexId?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  userData?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  index?: Resolver<ResolversTypes["Index"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IndexDistributionClaimedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["IndexDistributionClaimedEvent"] = ResolversParentTypes["IndexDistributionClaimedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  publisher?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  indexId?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  subscriber?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  amount?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  index?: Resolver<ResolversTypes["Index"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IndexSubscribedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["IndexSubscribedEvent"] = ResolversParentTypes["IndexSubscribedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  publisher?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  indexId?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  subscriber?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  userData?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  index?: Resolver<ResolversTypes["Index"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IndexSubscriptionResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["IndexSubscription"] = ResolversParentTypes["IndexSubscription"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  createdAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  createdAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  subscriber?: Resolver<ResolversTypes["Account"], ParentType, ContextType>;
  approved?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  units?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalAmountReceivedUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  indexValueUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  index?: Resolver<ResolversTypes["Index"], ParentType, ContextType>;
  subscriptionApprovedEvents?: Resolver<
    Array<ResolversTypes["SubscriptionApprovedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      IndexSubscriptionsubscriptionApprovedEventsArgs,
      "skip" | "first"
    >
  >;
  subscriptionDistributionClaimedEvents?: Resolver<
    Array<ResolversTypes["SubscriptionDistributionClaimedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      IndexSubscriptionsubscriptionDistributionClaimedEventsArgs,
      "skip" | "first"
    >
  >;
  subscriptionRevokedEvents?: Resolver<
    Array<ResolversTypes["SubscriptionRevokedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      IndexSubscriptionsubscriptionRevokedEventsArgs,
      "skip" | "first"
    >
  >;
  subscriptionUnitsUpdatedEvents?: Resolver<
    Array<ResolversTypes["SubscriptionUnitsUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      IndexSubscriptionsubscriptionUnitsUpdatedEventsArgs,
      "skip" | "first"
    >
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IndexUnitsUpdatedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["IndexUnitsUpdatedEvent"] = ResolversParentTypes["IndexUnitsUpdatedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  publisher?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  indexId?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  subscriber?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  units?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  userData?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  oldUnits?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  index?: Resolver<ResolversTypes["Index"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IndexUnsubscribedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["IndexUnsubscribedEvent"] = ResolversParentTypes["IndexUnsubscribedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  publisher?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  indexId?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  subscriber?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  userData?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  index?: Resolver<ResolversTypes["Index"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IndexUpdatedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["IndexUpdatedEvent"] = ResolversParentTypes["IndexUpdatedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  publisher?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  indexId?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  oldIndexValue?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  newIndexValue?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalUnitsPending?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalUnitsApproved?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  userData?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  index?: Resolver<ResolversTypes["Index"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type InstantDistributionUpdatedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["InstantDistributionUpdatedEvent"] = ResolversParentTypes["InstantDistributionUpdatedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  requestedAmount?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  actualAmount?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalUnits?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  userData?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  pool?: Resolver<ResolversTypes["Pool"], ParentType, ContextType>;
  poolDistributor?: Resolver<
    ResolversTypes["PoolDistributor"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface Int8ScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes["Int8"], any> {
  name: "Int8";
}

export type JailEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["JailEvent"] = ResolversParentTypes["JailEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  app?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  reason?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MemberUnitsUpdatedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["MemberUnitsUpdatedEvent"] = ResolversParentTypes["MemberUnitsUpdatedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  oldUnits?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  units?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalUnits?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  pool?: Resolver<ResolversTypes["Pool"], ParentType, ContextType>;
  poolMember?: Resolver<ResolversTypes["PoolMember"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MetadataUpdateEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["MetadataUpdateEvent"] = ResolversParentTypes["MetadataUpdateEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  tokenId?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MintedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["MintedEvent"] = ResolversParentTypes["MintedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  to?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  amount?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  data?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  operatorData?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NewPICEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["NewPICEvent"] = ResolversParentTypes["NewPICEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  pic?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  bond?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  exitRate?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PPPConfigurationChangedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["PPPConfigurationChangedEvent"] = ResolversParentTypes["PPPConfigurationChangedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  governanceAddress?: Resolver<
    ResolversTypes["Bytes"],
    ParentType,
    ContextType
  >;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  host?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  superToken?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  isKeySet?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  liquidationPeriod?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  patricianPeriod?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PoolResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["Pool"] = ResolversParentTypes["Pool"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  createdAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  createdAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalUnits?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalConnectedUnits?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalDisconnectedUnits?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalAmountInstantlyDistributedUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalAmountFlowedDistributedUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalAmountDistributedUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalFlowAdjustmentAmountDistributedUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  perUnitSettledValue?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  perUnitFlowRate?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalMembers?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  totalConnectedMembers?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalDisconnectedMembers?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  adjustmentFlowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  flowRate?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalBuffer?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  admin?: Resolver<ResolversTypes["Account"], ParentType, ContextType>;
  poolDistributors?: Resolver<
    Array<ResolversTypes["PoolDistributor"]>,
    ParentType,
    ContextType,
    RequireFields<PoolpoolDistributorsArgs, "skip" | "first">
  >;
  poolMembers?: Resolver<
    Array<ResolversTypes["PoolMember"]>,
    ParentType,
    ContextType,
    RequireFields<PoolpoolMembersArgs, "skip" | "first">
  >;
  poolCreatedEvent?: Resolver<
    ResolversTypes["PoolCreatedEvent"],
    ParentType,
    ContextType
  >;
  poolConnectionUpdatedEvents?: Resolver<
    Array<ResolversTypes["PoolConnectionUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<PoolpoolConnectionUpdatedEventsArgs, "skip" | "first">
  >;
  bufferAdjustedEvents?: Resolver<
    Array<ResolversTypes["BufferAdjustedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<PoolbufferAdjustedEventsArgs, "skip" | "first">
  >;
  instantDistributionUpdatedEvents?: Resolver<
    Array<ResolversTypes["InstantDistributionUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<PoolinstantDistributionUpdatedEventsArgs, "skip" | "first">
  >;
  flowDistributionUpdatedEvents?: Resolver<
    Array<ResolversTypes["FlowDistributionUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<PoolflowDistributionUpdatedEventsArgs, "skip" | "first">
  >;
  memberUnitsUpdatedEvents?: Resolver<
    Array<ResolversTypes["MemberUnitsUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<PoolmemberUnitsUpdatedEventsArgs, "skip" | "first">
  >;
  distributionClaimedEvents?: Resolver<
    Array<ResolversTypes["DistributionClaimedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<PooldistributionClaimedEventsArgs, "skip" | "first">
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PoolConnectionUpdatedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["PoolConnectionUpdatedEvent"] = ResolversParentTypes["PoolConnectionUpdatedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  connected?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  userData?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  pool?: Resolver<ResolversTypes["Pool"], ParentType, ContextType>;
  poolMember?: Resolver<ResolversTypes["PoolMember"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PoolCreatedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["PoolCreatedEvent"] = ResolversParentTypes["PoolCreatedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  caller?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  admin?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  pool?: Resolver<ResolversTypes["Pool"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PoolDistributorResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["PoolDistributor"] = ResolversParentTypes["PoolDistributor"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  createdAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  createdAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalAmountInstantlyDistributedUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalAmountFlowedDistributedUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalAmountDistributedUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalBuffer?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  flowRate?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  account?: Resolver<ResolversTypes["Account"], ParentType, ContextType>;
  pool?: Resolver<ResolversTypes["Pool"], ParentType, ContextType>;
  bufferAdjustedEvents?: Resolver<
    Array<ResolversTypes["BufferAdjustedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<PoolDistributorbufferAdjustedEventsArgs, "skip" | "first">
  >;
  instantDistributionUpdatedEvents?: Resolver<
    Array<ResolversTypes["InstantDistributionUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      PoolDistributorinstantDistributionUpdatedEventsArgs,
      "skip" | "first"
    >
  >;
  flowDistributionUpdatedEvents?: Resolver<
    Array<ResolversTypes["FlowDistributionUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      PoolDistributorflowDistributionUpdatedEventsArgs,
      "skip" | "first"
    >
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PoolMemberResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["PoolMember"] = ResolversParentTypes["PoolMember"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  createdAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  createdAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  units?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  isConnected?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  totalAmountClaimed?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  poolTotalAmountDistributedUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalAmountReceivedUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  syncedPerUnitSettledValue?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  syncedPerUnitFlowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  account?: Resolver<ResolversTypes["Account"], ParentType, ContextType>;
  pool?: Resolver<ResolversTypes["Pool"], ParentType, ContextType>;
  poolConnectionUpdatedEvents?: Resolver<
    Array<ResolversTypes["PoolConnectionUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<PoolMemberpoolConnectionUpdatedEventsArgs, "skip" | "first">
  >;
  memberUnitsUpdatedEvents?: Resolver<
    Array<ResolversTypes["MemberUnitsUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<PoolMembermemberUnitsUpdatedEventsArgs, "skip" | "first">
  >;
  distributionClaimedEvents?: Resolver<
    Array<ResolversTypes["DistributionClaimedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<PoolMemberdistributionClaimedEventsArgs, "skip" | "first">
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QueryResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["Query"] = ResolversParentTypes["Query"],
> = ResolversObject<{
  flowUpdatedEvent?: Resolver<
    Maybe<ResolversTypes["FlowUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryflowUpdatedEventArgs, "id" | "subgraphError">
  >;
  flowUpdatedEvents?: Resolver<
    Array<ResolversTypes["FlowUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryflowUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  flowOperatorUpdatedEvent?: Resolver<
    Maybe<ResolversTypes["FlowOperatorUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryflowOperatorUpdatedEventArgs, "id" | "subgraphError">
  >;
  flowOperatorUpdatedEvents?: Resolver<
    Array<ResolversTypes["FlowOperatorUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryflowOperatorUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  indexCreatedEvent?: Resolver<
    Maybe<ResolversTypes["IndexCreatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryindexCreatedEventArgs, "id" | "subgraphError">
  >;
  indexCreatedEvents?: Resolver<
    Array<ResolversTypes["IndexCreatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryindexCreatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  indexDistributionClaimedEvent?: Resolver<
    Maybe<ResolversTypes["IndexDistributionClaimedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryindexDistributionClaimedEventArgs,
      "id" | "subgraphError"
    >
  >;
  indexDistributionClaimedEvents?: Resolver<
    Array<ResolversTypes["IndexDistributionClaimedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryindexDistributionClaimedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  indexUpdatedEvent?: Resolver<
    Maybe<ResolversTypes["IndexUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryindexUpdatedEventArgs, "id" | "subgraphError">
  >;
  indexUpdatedEvents?: Resolver<
    Array<ResolversTypes["IndexUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryindexUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  indexSubscribedEvent?: Resolver<
    Maybe<ResolversTypes["IndexSubscribedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryindexSubscribedEventArgs, "id" | "subgraphError">
  >;
  indexSubscribedEvents?: Resolver<
    Array<ResolversTypes["IndexSubscribedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryindexSubscribedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  indexUnitsUpdatedEvent?: Resolver<
    Maybe<ResolversTypes["IndexUnitsUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryindexUnitsUpdatedEventArgs, "id" | "subgraphError">
  >;
  indexUnitsUpdatedEvents?: Resolver<
    Array<ResolversTypes["IndexUnitsUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryindexUnitsUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  indexUnsubscribedEvent?: Resolver<
    Maybe<ResolversTypes["IndexUnsubscribedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryindexUnsubscribedEventArgs, "id" | "subgraphError">
  >;
  indexUnsubscribedEvents?: Resolver<
    Array<ResolversTypes["IndexUnsubscribedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryindexUnsubscribedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  subscriptionApprovedEvent?: Resolver<
    Maybe<ResolversTypes["SubscriptionApprovedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerysubscriptionApprovedEventArgs, "id" | "subgraphError">
  >;
  subscriptionApprovedEvents?: Resolver<
    Array<ResolversTypes["SubscriptionApprovedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerysubscriptionApprovedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  subscriptionDistributionClaimedEvent?: Resolver<
    Maybe<ResolversTypes["SubscriptionDistributionClaimedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerysubscriptionDistributionClaimedEventArgs,
      "id" | "subgraphError"
    >
  >;
  subscriptionDistributionClaimedEvents?: Resolver<
    Array<ResolversTypes["SubscriptionDistributionClaimedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerysubscriptionDistributionClaimedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  subscriptionRevokedEvent?: Resolver<
    Maybe<ResolversTypes["SubscriptionRevokedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerysubscriptionRevokedEventArgs, "id" | "subgraphError">
  >;
  subscriptionRevokedEvents?: Resolver<
    Array<ResolversTypes["SubscriptionRevokedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerysubscriptionRevokedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  subscriptionUnitsUpdatedEvent?: Resolver<
    Maybe<ResolversTypes["SubscriptionUnitsUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerysubscriptionUnitsUpdatedEventArgs,
      "id" | "subgraphError"
    >
  >;
  subscriptionUnitsUpdatedEvents?: Resolver<
    Array<ResolversTypes["SubscriptionUnitsUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerysubscriptionUnitsUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  poolCreatedEvent?: Resolver<
    Maybe<ResolversTypes["PoolCreatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerypoolCreatedEventArgs, "id" | "subgraphError">
  >;
  poolCreatedEvents?: Resolver<
    Array<ResolversTypes["PoolCreatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerypoolCreatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  poolConnectionUpdatedEvent?: Resolver<
    Maybe<ResolversTypes["PoolConnectionUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerypoolConnectionUpdatedEventArgs, "id" | "subgraphError">
  >;
  poolConnectionUpdatedEvents?: Resolver<
    Array<ResolversTypes["PoolConnectionUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerypoolConnectionUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  bufferAdjustedEvent?: Resolver<
    Maybe<ResolversTypes["BufferAdjustedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerybufferAdjustedEventArgs, "id" | "subgraphError">
  >;
  bufferAdjustedEvents?: Resolver<
    Array<ResolversTypes["BufferAdjustedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerybufferAdjustedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  instantDistributionUpdatedEvent?: Resolver<
    Maybe<ResolversTypes["InstantDistributionUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryinstantDistributionUpdatedEventArgs,
      "id" | "subgraphError"
    >
  >;
  instantDistributionUpdatedEvents?: Resolver<
    Array<ResolversTypes["InstantDistributionUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryinstantDistributionUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  flowDistributionUpdatedEvent?: Resolver<
    Maybe<ResolversTypes["FlowDistributionUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryflowDistributionUpdatedEventArgs, "id" | "subgraphError">
  >;
  flowDistributionUpdatedEvents?: Resolver<
    Array<ResolversTypes["FlowDistributionUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryflowDistributionUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  distributionClaimedEvent?: Resolver<
    Maybe<ResolversTypes["DistributionClaimedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerydistributionClaimedEventArgs, "id" | "subgraphError">
  >;
  distributionClaimedEvents?: Resolver<
    Array<ResolversTypes["DistributionClaimedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerydistributionClaimedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  memberUnitsUpdatedEvent?: Resolver<
    Maybe<ResolversTypes["MemberUnitsUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerymemberUnitsUpdatedEventArgs, "id" | "subgraphError">
  >;
  memberUnitsUpdatedEvents?: Resolver<
    Array<ResolversTypes["MemberUnitsUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerymemberUnitsUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  agreementClassRegisteredEvent?: Resolver<
    Maybe<ResolversTypes["AgreementClassRegisteredEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryagreementClassRegisteredEventArgs,
      "id" | "subgraphError"
    >
  >;
  agreementClassRegisteredEvents?: Resolver<
    Array<ResolversTypes["AgreementClassRegisteredEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryagreementClassRegisteredEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  agreementClassUpdatedEvent?: Resolver<
    Maybe<ResolversTypes["AgreementClassUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryagreementClassUpdatedEventArgs, "id" | "subgraphError">
  >;
  agreementClassUpdatedEvents?: Resolver<
    Array<ResolversTypes["AgreementClassUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryagreementClassUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  appRegisteredEvent?: Resolver<
    Maybe<ResolversTypes["AppRegisteredEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryappRegisteredEventArgs, "id" | "subgraphError">
  >;
  appRegisteredEvents?: Resolver<
    Array<ResolversTypes["AppRegisteredEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryappRegisteredEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  governanceReplacedEvent?: Resolver<
    Maybe<ResolversTypes["GovernanceReplacedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerygovernanceReplacedEventArgs, "id" | "subgraphError">
  >;
  governanceReplacedEvents?: Resolver<
    Array<ResolversTypes["GovernanceReplacedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerygovernanceReplacedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  jailEvent?: Resolver<
    Maybe<ResolversTypes["JailEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryjailEventArgs, "id" | "subgraphError">
  >;
  jailEvents?: Resolver<
    Array<ResolversTypes["JailEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryjailEventsArgs, "skip" | "first" | "subgraphError">
  >;
  superTokenFactoryUpdatedEvent?: Resolver<
    Maybe<ResolversTypes["SuperTokenFactoryUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerysuperTokenFactoryUpdatedEventArgs,
      "id" | "subgraphError"
    >
  >;
  superTokenFactoryUpdatedEvents?: Resolver<
    Array<ResolversTypes["SuperTokenFactoryUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerysuperTokenFactoryUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  superTokenLogicUpdatedEvent?: Resolver<
    Maybe<ResolversTypes["SuperTokenLogicUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerysuperTokenLogicUpdatedEventArgs, "id" | "subgraphError">
  >;
  superTokenLogicUpdatedEvents?: Resolver<
    Array<ResolversTypes["SuperTokenLogicUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerysuperTokenLogicUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  roleAdminChangedEvent?: Resolver<
    Maybe<ResolversTypes["RoleAdminChangedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryroleAdminChangedEventArgs, "id" | "subgraphError">
  >;
  roleAdminChangedEvents?: Resolver<
    Array<ResolversTypes["RoleAdminChangedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryroleAdminChangedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  roleGrantedEvent?: Resolver<
    Maybe<ResolversTypes["RoleGrantedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryroleGrantedEventArgs, "id" | "subgraphError">
  >;
  roleGrantedEvents?: Resolver<
    Array<ResolversTypes["RoleGrantedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryroleGrantedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  roleRevokedEvent?: Resolver<
    Maybe<ResolversTypes["RoleRevokedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryroleRevokedEventArgs, "id" | "subgraphError">
  >;
  roleRevokedEvents?: Resolver<
    Array<ResolversTypes["RoleRevokedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryroleRevokedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  setEvent?: Resolver<
    Maybe<ResolversTypes["SetEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerysetEventArgs, "id" | "subgraphError">
  >;
  setEvents?: Resolver<
    Array<ResolversTypes["SetEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerysetEventsArgs, "skip" | "first" | "subgraphError">
  >;
  cfav1LiquidationPeriodChangedEvent?: Resolver<
    Maybe<ResolversTypes["CFAv1LiquidationPeriodChangedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      Querycfav1LiquidationPeriodChangedEventArgs,
      "id" | "subgraphError"
    >
  >;
  cfav1LiquidationPeriodChangedEvents?: Resolver<
    Array<ResolversTypes["CFAv1LiquidationPeriodChangedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      Querycfav1LiquidationPeriodChangedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  configChangedEvent?: Resolver<
    Maybe<ResolversTypes["ConfigChangedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryconfigChangedEventArgs, "id" | "subgraphError">
  >;
  configChangedEvents?: Resolver<
    Array<ResolversTypes["ConfigChangedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryconfigChangedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  rewardAddressChangedEvent?: Resolver<
    Maybe<ResolversTypes["RewardAddressChangedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryrewardAddressChangedEventArgs, "id" | "subgraphError">
  >;
  rewardAddressChangedEvents?: Resolver<
    Array<ResolversTypes["RewardAddressChangedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryrewardAddressChangedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  pppconfigurationChangedEvent?: Resolver<
    Maybe<ResolversTypes["PPPConfigurationChangedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerypppconfigurationChangedEventArgs, "id" | "subgraphError">
  >;
  pppconfigurationChangedEvents?: Resolver<
    Array<ResolversTypes["PPPConfigurationChangedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerypppconfigurationChangedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  superTokenMinimumDepositChangedEvent?: Resolver<
    Maybe<ResolversTypes["SuperTokenMinimumDepositChangedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerysuperTokenMinimumDepositChangedEventArgs,
      "id" | "subgraphError"
    >
  >;
  superTokenMinimumDepositChangedEvents?: Resolver<
    Array<ResolversTypes["SuperTokenMinimumDepositChangedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerysuperTokenMinimumDepositChangedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  trustedForwarderChangedEvent?: Resolver<
    Maybe<ResolversTypes["TrustedForwarderChangedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerytrustedForwarderChangedEventArgs, "id" | "subgraphError">
  >;
  trustedForwarderChangedEvents?: Resolver<
    Array<ResolversTypes["TrustedForwarderChangedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerytrustedForwarderChangedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  agreementLiquidatedByEvent?: Resolver<
    Maybe<ResolversTypes["AgreementLiquidatedByEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryagreementLiquidatedByEventArgs, "id" | "subgraphError">
  >;
  agreementLiquidatedByEvents?: Resolver<
    Array<ResolversTypes["AgreementLiquidatedByEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryagreementLiquidatedByEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  agreementLiquidatedV2Event?: Resolver<
    Maybe<ResolversTypes["AgreementLiquidatedV2Event"]>,
    ParentType,
    ContextType,
    RequireFields<QueryagreementLiquidatedV2EventArgs, "id" | "subgraphError">
  >;
  agreementLiquidatedV2Events?: Resolver<
    Array<ResolversTypes["AgreementLiquidatedV2Event"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryagreementLiquidatedV2EventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  burnedEvent?: Resolver<
    Maybe<ResolversTypes["BurnedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryburnedEventArgs, "id" | "subgraphError">
  >;
  burnedEvents?: Resolver<
    Array<ResolversTypes["BurnedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryburnedEventsArgs, "skip" | "first" | "subgraphError">
  >;
  mintedEvent?: Resolver<
    Maybe<ResolversTypes["MintedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerymintedEventArgs, "id" | "subgraphError">
  >;
  mintedEvents?: Resolver<
    Array<ResolversTypes["MintedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerymintedEventsArgs, "skip" | "first" | "subgraphError">
  >;
  sentEvent?: Resolver<
    Maybe<ResolversTypes["SentEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerysentEventArgs, "id" | "subgraphError">
  >;
  sentEvents?: Resolver<
    Array<ResolversTypes["SentEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerysentEventsArgs, "skip" | "first" | "subgraphError">
  >;
  transferEvent?: Resolver<
    Maybe<ResolversTypes["TransferEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerytransferEventArgs, "id" | "subgraphError">
  >;
  transferEvents?: Resolver<
    Array<ResolversTypes["TransferEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerytransferEventsArgs, "skip" | "first" | "subgraphError">
  >;
  tokenDowngradedEvent?: Resolver<
    Maybe<ResolversTypes["TokenDowngradedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerytokenDowngradedEventArgs, "id" | "subgraphError">
  >;
  tokenDowngradedEvents?: Resolver<
    Array<ResolversTypes["TokenDowngradedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerytokenDowngradedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  tokenUpgradedEvent?: Resolver<
    Maybe<ResolversTypes["TokenUpgradedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerytokenUpgradedEventArgs, "id" | "subgraphError">
  >;
  tokenUpgradedEvents?: Resolver<
    Array<ResolversTypes["TokenUpgradedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerytokenUpgradedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  approvalEvent?: Resolver<
    Maybe<ResolversTypes["ApprovalEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryapprovalEventArgs, "id" | "subgraphError">
  >;
  approvalEvents?: Resolver<
    Array<ResolversTypes["ApprovalEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryapprovalEventsArgs, "skip" | "first" | "subgraphError">
  >;
  approvalForAllEvent?: Resolver<
    Maybe<ResolversTypes["ApprovalForAllEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryapprovalForAllEventArgs, "id" | "subgraphError">
  >;
  approvalForAllEvents?: Resolver<
    Array<ResolversTypes["ApprovalForAllEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryapprovalForAllEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  metadataUpdateEvent?: Resolver<
    Maybe<ResolversTypes["MetadataUpdateEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerymetadataUpdateEventArgs, "id" | "subgraphError">
  >;
  metadataUpdateEvents?: Resolver<
    Array<ResolversTypes["MetadataUpdateEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerymetadataUpdateEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  customSuperTokenCreatedEvent?: Resolver<
    Maybe<ResolversTypes["CustomSuperTokenCreatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerycustomSuperTokenCreatedEventArgs, "id" | "subgraphError">
  >;
  customSuperTokenCreatedEvents?: Resolver<
    Array<ResolversTypes["CustomSuperTokenCreatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerycustomSuperTokenCreatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  superTokenCreatedEvent?: Resolver<
    Maybe<ResolversTypes["SuperTokenCreatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerysuperTokenCreatedEventArgs, "id" | "subgraphError">
  >;
  superTokenCreatedEvents?: Resolver<
    Array<ResolversTypes["SuperTokenCreatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerysuperTokenCreatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  superTokenLogicCreatedEvent?: Resolver<
    Maybe<ResolversTypes["SuperTokenLogicCreatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerysuperTokenLogicCreatedEventArgs, "id" | "subgraphError">
  >;
  superTokenLogicCreatedEvents?: Resolver<
    Array<ResolversTypes["SuperTokenLogicCreatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerysuperTokenLogicCreatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  newPICEvent?: Resolver<
    Maybe<ResolversTypes["NewPICEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerynewPICEventArgs, "id" | "subgraphError">
  >;
  newPICEvents?: Resolver<
    Array<ResolversTypes["NewPICEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerynewPICEventsArgs, "skip" | "first" | "subgraphError">
  >;
  exitRateChangedEvent?: Resolver<
    Maybe<ResolversTypes["ExitRateChangedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QueryexitRateChangedEventArgs, "id" | "subgraphError">
  >;
  exitRateChangedEvents?: Resolver<
    Array<ResolversTypes["ExitRateChangedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryexitRateChangedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  bondIncreasedEvent?: Resolver<
    Maybe<ResolversTypes["BondIncreasedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<QuerybondIncreasedEventArgs, "id" | "subgraphError">
  >;
  bondIncreasedEvents?: Resolver<
    Array<ResolversTypes["BondIncreasedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerybondIncreasedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  account?: Resolver<
    Maybe<ResolversTypes["Account"]>,
    ParentType,
    ContextType,
    RequireFields<QueryaccountArgs, "id" | "subgraphError">
  >;
  accounts?: Resolver<
    Array<ResolversTypes["Account"]>,
    ParentType,
    ContextType,
    RequireFields<QueryaccountsArgs, "skip" | "first" | "subgraphError">
  >;
  pool?: Resolver<
    Maybe<ResolversTypes["Pool"]>,
    ParentType,
    ContextType,
    RequireFields<QuerypoolArgs, "id" | "subgraphError">
  >;
  pools?: Resolver<
    Array<ResolversTypes["Pool"]>,
    ParentType,
    ContextType,
    RequireFields<QuerypoolsArgs, "skip" | "first" | "subgraphError">
  >;
  poolMember?: Resolver<
    Maybe<ResolversTypes["PoolMember"]>,
    ParentType,
    ContextType,
    RequireFields<QuerypoolMemberArgs, "id" | "subgraphError">
  >;
  poolMembers?: Resolver<
    Array<ResolversTypes["PoolMember"]>,
    ParentType,
    ContextType,
    RequireFields<QuerypoolMembersArgs, "skip" | "first" | "subgraphError">
  >;
  poolDistributor?: Resolver<
    Maybe<ResolversTypes["PoolDistributor"]>,
    ParentType,
    ContextType,
    RequireFields<QuerypoolDistributorArgs, "id" | "subgraphError">
  >;
  poolDistributors?: Resolver<
    Array<ResolversTypes["PoolDistributor"]>,
    ParentType,
    ContextType,
    RequireFields<QuerypoolDistributorsArgs, "skip" | "first" | "subgraphError">
  >;
  index?: Resolver<
    Maybe<ResolversTypes["Index"]>,
    ParentType,
    ContextType,
    RequireFields<QueryindexArgs, "id" | "subgraphError">
  >;
  indexes?: Resolver<
    Array<ResolversTypes["Index"]>,
    ParentType,
    ContextType,
    RequireFields<QueryindexesArgs, "skip" | "first" | "subgraphError">
  >;
  indexSubscription?: Resolver<
    Maybe<ResolversTypes["IndexSubscription"]>,
    ParentType,
    ContextType,
    RequireFields<QueryindexSubscriptionArgs, "id" | "subgraphError">
  >;
  indexSubscriptions?: Resolver<
    Array<ResolversTypes["IndexSubscription"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryindexSubscriptionsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  stream?: Resolver<
    Maybe<ResolversTypes["Stream"]>,
    ParentType,
    ContextType,
    RequireFields<QuerystreamArgs, "id" | "subgraphError">
  >;
  streams?: Resolver<
    Array<ResolversTypes["Stream"]>,
    ParentType,
    ContextType,
    RequireFields<QuerystreamsArgs, "skip" | "first" | "subgraphError">
  >;
  flowOperator?: Resolver<
    Maybe<ResolversTypes["FlowOperator"]>,
    ParentType,
    ContextType,
    RequireFields<QueryflowOperatorArgs, "id" | "subgraphError">
  >;
  flowOperators?: Resolver<
    Array<ResolversTypes["FlowOperator"]>,
    ParentType,
    ContextType,
    RequireFields<QueryflowOperatorsArgs, "skip" | "first" | "subgraphError">
  >;
  streamPeriod?: Resolver<
    Maybe<ResolversTypes["StreamPeriod"]>,
    ParentType,
    ContextType,
    RequireFields<QuerystreamPeriodArgs, "id" | "subgraphError">
  >;
  streamPeriods?: Resolver<
    Array<ResolversTypes["StreamPeriod"]>,
    ParentType,
    ContextType,
    RequireFields<QuerystreamPeriodsArgs, "skip" | "first" | "subgraphError">
  >;
  tokenGovernanceConfig?: Resolver<
    Maybe<ResolversTypes["TokenGovernanceConfig"]>,
    ParentType,
    ContextType,
    RequireFields<QuerytokenGovernanceConfigArgs, "id" | "subgraphError">
  >;
  tokenGovernanceConfigs?: Resolver<
    Array<ResolversTypes["TokenGovernanceConfig"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerytokenGovernanceConfigsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  streamRevision?: Resolver<
    Maybe<ResolversTypes["StreamRevision"]>,
    ParentType,
    ContextType,
    RequireFields<QuerystreamRevisionArgs, "id" | "subgraphError">
  >;
  streamRevisions?: Resolver<
    Array<ResolversTypes["StreamRevision"]>,
    ParentType,
    ContextType,
    RequireFields<QuerystreamRevisionsArgs, "skip" | "first" | "subgraphError">
  >;
  token?: Resolver<
    Maybe<ResolversTypes["Token"]>,
    ParentType,
    ContextType,
    RequireFields<QuerytokenArgs, "id" | "subgraphError">
  >;
  tokens?: Resolver<
    Array<ResolversTypes["Token"]>,
    ParentType,
    ContextType,
    RequireFields<QuerytokensArgs, "skip" | "first" | "subgraphError">
  >;
  resolverEntry?: Resolver<
    Maybe<ResolversTypes["ResolverEntry"]>,
    ParentType,
    ContextType,
    RequireFields<QueryresolverEntryArgs, "id" | "subgraphError">
  >;
  resolverEntries?: Resolver<
    Array<ResolversTypes["ResolverEntry"]>,
    ParentType,
    ContextType,
    RequireFields<QueryresolverEntriesArgs, "skip" | "first" | "subgraphError">
  >;
  accountTokenSnapshot?: Resolver<
    Maybe<ResolversTypes["AccountTokenSnapshot"]>,
    ParentType,
    ContextType,
    RequireFields<QueryaccountTokenSnapshotArgs, "id" | "subgraphError">
  >;
  accountTokenSnapshots?: Resolver<
    Array<ResolversTypes["AccountTokenSnapshot"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryaccountTokenSnapshotsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  accountTokenSnapshotLog?: Resolver<
    Maybe<ResolversTypes["AccountTokenSnapshotLog"]>,
    ParentType,
    ContextType,
    RequireFields<QueryaccountTokenSnapshotLogArgs, "id" | "subgraphError">
  >;
  accountTokenSnapshotLogs?: Resolver<
    Array<ResolversTypes["AccountTokenSnapshotLog"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryaccountTokenSnapshotLogsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  tokenStatistic?: Resolver<
    Maybe<ResolversTypes["TokenStatistic"]>,
    ParentType,
    ContextType,
    RequireFields<QuerytokenStatisticArgs, "id" | "subgraphError">
  >;
  tokenStatistics?: Resolver<
    Array<ResolversTypes["TokenStatistic"]>,
    ParentType,
    ContextType,
    RequireFields<QuerytokenStatisticsArgs, "skip" | "first" | "subgraphError">
  >;
  tokenStatisticLog?: Resolver<
    Maybe<ResolversTypes["TokenStatisticLog"]>,
    ParentType,
    ContextType,
    RequireFields<QuerytokenStatisticLogArgs, "id" | "subgraphError">
  >;
  tokenStatisticLogs?: Resolver<
    Array<ResolversTypes["TokenStatisticLog"]>,
    ParentType,
    ContextType,
    RequireFields<
      QuerytokenStatisticLogsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  sfmeta?: Resolver<
    Maybe<ResolversTypes["SFMeta"]>,
    ParentType,
    ContextType,
    RequireFields<QuerysfmetaArgs, "id" | "subgraphError">
  >;
  sfmetas?: Resolver<
    Array<ResolversTypes["SFMeta"]>,
    ParentType,
    ContextType,
    RequireFields<QuerysfmetasArgs, "skip" | "first" | "subgraphError">
  >;
  event?: Resolver<
    Maybe<ResolversTypes["Event"]>,
    ParentType,
    ContextType,
    RequireFields<QueryeventArgs, "id" | "subgraphError">
  >;
  events?: Resolver<
    Array<ResolversTypes["Event"]>,
    ParentType,
    ContextType,
    RequireFields<QueryeventsArgs, "skip" | "first" | "subgraphError">
  >;
  _meta?: Resolver<
    Maybe<ResolversTypes["_Meta_"]>,
    ParentType,
    ContextType,
    Partial<Query_metaArgs>
  >;
}>;

export type ResolverEntryResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["ResolverEntry"] = ResolversParentTypes["ResolverEntry"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  createdAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  createdAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  targetAddress?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  isToken?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isListed?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  setEvents?: Resolver<
    Array<ResolversTypes["SetEvent"]>,
    ParentType,
    ContextType,
    RequireFields<ResolverEntrysetEventsArgs, "skip" | "first">
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RewardAddressChangedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["RewardAddressChangedEvent"] = ResolversParentTypes["RewardAddressChangedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  governanceAddress?: Resolver<
    ResolversTypes["Bytes"],
    ParentType,
    ContextType
  >;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  host?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  superToken?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  isKeySet?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  rewardAddress?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RoleAdminChangedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["RoleAdminChangedEvent"] = ResolversParentTypes["RoleAdminChangedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  role?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  previousAdminRole?: Resolver<
    ResolversTypes["Bytes"],
    ParentType,
    ContextType
  >;
  newAdminRole?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RoleGrantedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["RoleGrantedEvent"] = ResolversParentTypes["RoleGrantedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  role?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  account?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  sender?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RoleRevokedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["RoleRevokedEvent"] = ResolversParentTypes["RoleRevokedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  role?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  account?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  sender?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SFMetaResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["SFMeta"] = ResolversParentTypes["SFMeta"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  configuration?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  branch?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  packageVersion?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SentEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["SentEvent"] = ResolversParentTypes["SentEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  from?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  to?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  amount?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  data?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  operatorData?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SetEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["SetEvent"] = ResolversParentTypes["SetEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  hashedName?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  target?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  resolverEntry?: Resolver<
    ResolversTypes["ResolverEntry"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StreamResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["Stream"] = ResolversParentTypes["Stream"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  createdAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  createdAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  currentFlowRate?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  deposit?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  streamedUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  token?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  sender?: Resolver<ResolversTypes["Account"], ParentType, ContextType>;
  receiver?: Resolver<ResolversTypes["Account"], ParentType, ContextType>;
  userData?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  flowUpdatedEvents?: Resolver<
    Array<ResolversTypes["FlowUpdatedEvent"]>,
    ParentType,
    ContextType,
    RequireFields<StreamflowUpdatedEventsArgs, "skip" | "first">
  >;
  streamPeriods?: Resolver<
    Array<ResolversTypes["StreamPeriod"]>,
    ParentType,
    ContextType,
    RequireFields<StreamstreamPeriodsArgs, "skip" | "first">
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StreamPeriodResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["StreamPeriod"] = ResolversParentTypes["StreamPeriod"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  stream?: Resolver<ResolversTypes["Stream"], ParentType, ContextType>;
  sender?: Resolver<ResolversTypes["Account"], ParentType, ContextType>;
  receiver?: Resolver<ResolversTypes["Account"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  flowRate?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  deposit?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  startedAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  startedAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  startedAtEvent?: Resolver<
    ResolversTypes["FlowUpdatedEvent"],
    ParentType,
    ContextType
  >;
  stoppedAtTimestamp?: Resolver<
    Maybe<ResolversTypes["BigInt"]>,
    ParentType,
    ContextType
  >;
  stoppedAtBlockNumber?: Resolver<
    Maybe<ResolversTypes["BigInt"]>,
    ParentType,
    ContextType
  >;
  stoppedAtEvent?: Resolver<
    Maybe<ResolversTypes["FlowUpdatedEvent"]>,
    ParentType,
    ContextType
  >;
  totalAmountStreamed?: Resolver<
    Maybe<ResolversTypes["BigInt"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StreamRevisionResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["StreamRevision"] = ResolversParentTypes["StreamRevision"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  revisionIndex?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  periodRevisionIndex?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  mostRecentStream?: Resolver<
    ResolversTypes["Stream"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SubscriptionResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["Subscription"] = ResolversParentTypes["Subscription"],
> = ResolversObject<{
  flowUpdatedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["FlowUpdatedEvent"]>,
    "flowUpdatedEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptionflowUpdatedEventArgs, "id" | "subgraphError">
  >;
  flowUpdatedEvents?: SubscriptionResolver<
    Array<ResolversTypes["FlowUpdatedEvent"]>,
    "flowUpdatedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionflowUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  flowOperatorUpdatedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["FlowOperatorUpdatedEvent"]>,
    "flowOperatorUpdatedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionflowOperatorUpdatedEventArgs,
      "id" | "subgraphError"
    >
  >;
  flowOperatorUpdatedEvents?: SubscriptionResolver<
    Array<ResolversTypes["FlowOperatorUpdatedEvent"]>,
    "flowOperatorUpdatedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionflowOperatorUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  indexCreatedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["IndexCreatedEvent"]>,
    "indexCreatedEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptionindexCreatedEventArgs, "id" | "subgraphError">
  >;
  indexCreatedEvents?: SubscriptionResolver<
    Array<ResolversTypes["IndexCreatedEvent"]>,
    "indexCreatedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionindexCreatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  indexDistributionClaimedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["IndexDistributionClaimedEvent"]>,
    "indexDistributionClaimedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionindexDistributionClaimedEventArgs,
      "id" | "subgraphError"
    >
  >;
  indexDistributionClaimedEvents?: SubscriptionResolver<
    Array<ResolversTypes["IndexDistributionClaimedEvent"]>,
    "indexDistributionClaimedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionindexDistributionClaimedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  indexUpdatedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["IndexUpdatedEvent"]>,
    "indexUpdatedEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptionindexUpdatedEventArgs, "id" | "subgraphError">
  >;
  indexUpdatedEvents?: SubscriptionResolver<
    Array<ResolversTypes["IndexUpdatedEvent"]>,
    "indexUpdatedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionindexUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  indexSubscribedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["IndexSubscribedEvent"]>,
    "indexSubscribedEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptionindexSubscribedEventArgs, "id" | "subgraphError">
  >;
  indexSubscribedEvents?: SubscriptionResolver<
    Array<ResolversTypes["IndexSubscribedEvent"]>,
    "indexSubscribedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionindexSubscribedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  indexUnitsUpdatedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["IndexUnitsUpdatedEvent"]>,
    "indexUnitsUpdatedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionindexUnitsUpdatedEventArgs,
      "id" | "subgraphError"
    >
  >;
  indexUnitsUpdatedEvents?: SubscriptionResolver<
    Array<ResolversTypes["IndexUnitsUpdatedEvent"]>,
    "indexUnitsUpdatedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionindexUnitsUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  indexUnsubscribedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["IndexUnsubscribedEvent"]>,
    "indexUnsubscribedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionindexUnsubscribedEventArgs,
      "id" | "subgraphError"
    >
  >;
  indexUnsubscribedEvents?: SubscriptionResolver<
    Array<ResolversTypes["IndexUnsubscribedEvent"]>,
    "indexUnsubscribedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionindexUnsubscribedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  subscriptionApprovedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["SubscriptionApprovedEvent"]>,
    "subscriptionApprovedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionsubscriptionApprovedEventArgs,
      "id" | "subgraphError"
    >
  >;
  subscriptionApprovedEvents?: SubscriptionResolver<
    Array<ResolversTypes["SubscriptionApprovedEvent"]>,
    "subscriptionApprovedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionsubscriptionApprovedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  subscriptionDistributionClaimedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["SubscriptionDistributionClaimedEvent"]>,
    "subscriptionDistributionClaimedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionsubscriptionDistributionClaimedEventArgs,
      "id" | "subgraphError"
    >
  >;
  subscriptionDistributionClaimedEvents?: SubscriptionResolver<
    Array<ResolversTypes["SubscriptionDistributionClaimedEvent"]>,
    "subscriptionDistributionClaimedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionsubscriptionDistributionClaimedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  subscriptionRevokedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["SubscriptionRevokedEvent"]>,
    "subscriptionRevokedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionsubscriptionRevokedEventArgs,
      "id" | "subgraphError"
    >
  >;
  subscriptionRevokedEvents?: SubscriptionResolver<
    Array<ResolversTypes["SubscriptionRevokedEvent"]>,
    "subscriptionRevokedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionsubscriptionRevokedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  subscriptionUnitsUpdatedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["SubscriptionUnitsUpdatedEvent"]>,
    "subscriptionUnitsUpdatedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionsubscriptionUnitsUpdatedEventArgs,
      "id" | "subgraphError"
    >
  >;
  subscriptionUnitsUpdatedEvents?: SubscriptionResolver<
    Array<ResolversTypes["SubscriptionUnitsUpdatedEvent"]>,
    "subscriptionUnitsUpdatedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionsubscriptionUnitsUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  poolCreatedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["PoolCreatedEvent"]>,
    "poolCreatedEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptionpoolCreatedEventArgs, "id" | "subgraphError">
  >;
  poolCreatedEvents?: SubscriptionResolver<
    Array<ResolversTypes["PoolCreatedEvent"]>,
    "poolCreatedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionpoolCreatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  poolConnectionUpdatedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["PoolConnectionUpdatedEvent"]>,
    "poolConnectionUpdatedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionpoolConnectionUpdatedEventArgs,
      "id" | "subgraphError"
    >
  >;
  poolConnectionUpdatedEvents?: SubscriptionResolver<
    Array<ResolversTypes["PoolConnectionUpdatedEvent"]>,
    "poolConnectionUpdatedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionpoolConnectionUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  bufferAdjustedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["BufferAdjustedEvent"]>,
    "bufferAdjustedEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptionbufferAdjustedEventArgs, "id" | "subgraphError">
  >;
  bufferAdjustedEvents?: SubscriptionResolver<
    Array<ResolversTypes["BufferAdjustedEvent"]>,
    "bufferAdjustedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionbufferAdjustedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  instantDistributionUpdatedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["InstantDistributionUpdatedEvent"]>,
    "instantDistributionUpdatedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptioninstantDistributionUpdatedEventArgs,
      "id" | "subgraphError"
    >
  >;
  instantDistributionUpdatedEvents?: SubscriptionResolver<
    Array<ResolversTypes["InstantDistributionUpdatedEvent"]>,
    "instantDistributionUpdatedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptioninstantDistributionUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  flowDistributionUpdatedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["FlowDistributionUpdatedEvent"]>,
    "flowDistributionUpdatedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionflowDistributionUpdatedEventArgs,
      "id" | "subgraphError"
    >
  >;
  flowDistributionUpdatedEvents?: SubscriptionResolver<
    Array<ResolversTypes["FlowDistributionUpdatedEvent"]>,
    "flowDistributionUpdatedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionflowDistributionUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  distributionClaimedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["DistributionClaimedEvent"]>,
    "distributionClaimedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptiondistributionClaimedEventArgs,
      "id" | "subgraphError"
    >
  >;
  distributionClaimedEvents?: SubscriptionResolver<
    Array<ResolversTypes["DistributionClaimedEvent"]>,
    "distributionClaimedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptiondistributionClaimedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  memberUnitsUpdatedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["MemberUnitsUpdatedEvent"]>,
    "memberUnitsUpdatedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionmemberUnitsUpdatedEventArgs,
      "id" | "subgraphError"
    >
  >;
  memberUnitsUpdatedEvents?: SubscriptionResolver<
    Array<ResolversTypes["MemberUnitsUpdatedEvent"]>,
    "memberUnitsUpdatedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionmemberUnitsUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  agreementClassRegisteredEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["AgreementClassRegisteredEvent"]>,
    "agreementClassRegisteredEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionagreementClassRegisteredEventArgs,
      "id" | "subgraphError"
    >
  >;
  agreementClassRegisteredEvents?: SubscriptionResolver<
    Array<ResolversTypes["AgreementClassRegisteredEvent"]>,
    "agreementClassRegisteredEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionagreementClassRegisteredEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  agreementClassUpdatedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["AgreementClassUpdatedEvent"]>,
    "agreementClassUpdatedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionagreementClassUpdatedEventArgs,
      "id" | "subgraphError"
    >
  >;
  agreementClassUpdatedEvents?: SubscriptionResolver<
    Array<ResolversTypes["AgreementClassUpdatedEvent"]>,
    "agreementClassUpdatedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionagreementClassUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  appRegisteredEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["AppRegisteredEvent"]>,
    "appRegisteredEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptionappRegisteredEventArgs, "id" | "subgraphError">
  >;
  appRegisteredEvents?: SubscriptionResolver<
    Array<ResolversTypes["AppRegisteredEvent"]>,
    "appRegisteredEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionappRegisteredEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  governanceReplacedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["GovernanceReplacedEvent"]>,
    "governanceReplacedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptiongovernanceReplacedEventArgs,
      "id" | "subgraphError"
    >
  >;
  governanceReplacedEvents?: SubscriptionResolver<
    Array<ResolversTypes["GovernanceReplacedEvent"]>,
    "governanceReplacedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptiongovernanceReplacedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  jailEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["JailEvent"]>,
    "jailEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptionjailEventArgs, "id" | "subgraphError">
  >;
  jailEvents?: SubscriptionResolver<
    Array<ResolversTypes["JailEvent"]>,
    "jailEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionjailEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  superTokenFactoryUpdatedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["SuperTokenFactoryUpdatedEvent"]>,
    "superTokenFactoryUpdatedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionsuperTokenFactoryUpdatedEventArgs,
      "id" | "subgraphError"
    >
  >;
  superTokenFactoryUpdatedEvents?: SubscriptionResolver<
    Array<ResolversTypes["SuperTokenFactoryUpdatedEvent"]>,
    "superTokenFactoryUpdatedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionsuperTokenFactoryUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  superTokenLogicUpdatedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["SuperTokenLogicUpdatedEvent"]>,
    "superTokenLogicUpdatedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionsuperTokenLogicUpdatedEventArgs,
      "id" | "subgraphError"
    >
  >;
  superTokenLogicUpdatedEvents?: SubscriptionResolver<
    Array<ResolversTypes["SuperTokenLogicUpdatedEvent"]>,
    "superTokenLogicUpdatedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionsuperTokenLogicUpdatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  roleAdminChangedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["RoleAdminChangedEvent"]>,
    "roleAdminChangedEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptionroleAdminChangedEventArgs, "id" | "subgraphError">
  >;
  roleAdminChangedEvents?: SubscriptionResolver<
    Array<ResolversTypes["RoleAdminChangedEvent"]>,
    "roleAdminChangedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionroleAdminChangedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  roleGrantedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["RoleGrantedEvent"]>,
    "roleGrantedEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptionroleGrantedEventArgs, "id" | "subgraphError">
  >;
  roleGrantedEvents?: SubscriptionResolver<
    Array<ResolversTypes["RoleGrantedEvent"]>,
    "roleGrantedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionroleGrantedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  roleRevokedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["RoleRevokedEvent"]>,
    "roleRevokedEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptionroleRevokedEventArgs, "id" | "subgraphError">
  >;
  roleRevokedEvents?: SubscriptionResolver<
    Array<ResolversTypes["RoleRevokedEvent"]>,
    "roleRevokedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionroleRevokedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  setEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["SetEvent"]>,
    "setEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptionsetEventArgs, "id" | "subgraphError">
  >;
  setEvents?: SubscriptionResolver<
    Array<ResolversTypes["SetEvent"]>,
    "setEvents",
    ParentType,
    ContextType,
    RequireFields<SubscriptionsetEventsArgs, "skip" | "first" | "subgraphError">
  >;
  cfav1LiquidationPeriodChangedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["CFAv1LiquidationPeriodChangedEvent"]>,
    "cfav1LiquidationPeriodChangedEvent",
    ParentType,
    ContextType,
    RequireFields<
      Subscriptioncfav1LiquidationPeriodChangedEventArgs,
      "id" | "subgraphError"
    >
  >;
  cfav1LiquidationPeriodChangedEvents?: SubscriptionResolver<
    Array<ResolversTypes["CFAv1LiquidationPeriodChangedEvent"]>,
    "cfav1LiquidationPeriodChangedEvents",
    ParentType,
    ContextType,
    RequireFields<
      Subscriptioncfav1LiquidationPeriodChangedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  configChangedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["ConfigChangedEvent"]>,
    "configChangedEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptionconfigChangedEventArgs, "id" | "subgraphError">
  >;
  configChangedEvents?: SubscriptionResolver<
    Array<ResolversTypes["ConfigChangedEvent"]>,
    "configChangedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionconfigChangedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  rewardAddressChangedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["RewardAddressChangedEvent"]>,
    "rewardAddressChangedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionrewardAddressChangedEventArgs,
      "id" | "subgraphError"
    >
  >;
  rewardAddressChangedEvents?: SubscriptionResolver<
    Array<ResolversTypes["RewardAddressChangedEvent"]>,
    "rewardAddressChangedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionrewardAddressChangedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  pppconfigurationChangedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["PPPConfigurationChangedEvent"]>,
    "pppconfigurationChangedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionpppconfigurationChangedEventArgs,
      "id" | "subgraphError"
    >
  >;
  pppconfigurationChangedEvents?: SubscriptionResolver<
    Array<ResolversTypes["PPPConfigurationChangedEvent"]>,
    "pppconfigurationChangedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionpppconfigurationChangedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  superTokenMinimumDepositChangedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["SuperTokenMinimumDepositChangedEvent"]>,
    "superTokenMinimumDepositChangedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionsuperTokenMinimumDepositChangedEventArgs,
      "id" | "subgraphError"
    >
  >;
  superTokenMinimumDepositChangedEvents?: SubscriptionResolver<
    Array<ResolversTypes["SuperTokenMinimumDepositChangedEvent"]>,
    "superTokenMinimumDepositChangedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionsuperTokenMinimumDepositChangedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  trustedForwarderChangedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["TrustedForwarderChangedEvent"]>,
    "trustedForwarderChangedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptiontrustedForwarderChangedEventArgs,
      "id" | "subgraphError"
    >
  >;
  trustedForwarderChangedEvents?: SubscriptionResolver<
    Array<ResolversTypes["TrustedForwarderChangedEvent"]>,
    "trustedForwarderChangedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptiontrustedForwarderChangedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  agreementLiquidatedByEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["AgreementLiquidatedByEvent"]>,
    "agreementLiquidatedByEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionagreementLiquidatedByEventArgs,
      "id" | "subgraphError"
    >
  >;
  agreementLiquidatedByEvents?: SubscriptionResolver<
    Array<ResolversTypes["AgreementLiquidatedByEvent"]>,
    "agreementLiquidatedByEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionagreementLiquidatedByEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  agreementLiquidatedV2Event?: SubscriptionResolver<
    Maybe<ResolversTypes["AgreementLiquidatedV2Event"]>,
    "agreementLiquidatedV2Event",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionagreementLiquidatedV2EventArgs,
      "id" | "subgraphError"
    >
  >;
  agreementLiquidatedV2Events?: SubscriptionResolver<
    Array<ResolversTypes["AgreementLiquidatedV2Event"]>,
    "agreementLiquidatedV2Events",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionagreementLiquidatedV2EventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  burnedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["BurnedEvent"]>,
    "burnedEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptionburnedEventArgs, "id" | "subgraphError">
  >;
  burnedEvents?: SubscriptionResolver<
    Array<ResolversTypes["BurnedEvent"]>,
    "burnedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionburnedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  mintedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["MintedEvent"]>,
    "mintedEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptionmintedEventArgs, "id" | "subgraphError">
  >;
  mintedEvents?: SubscriptionResolver<
    Array<ResolversTypes["MintedEvent"]>,
    "mintedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionmintedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  sentEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["SentEvent"]>,
    "sentEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptionsentEventArgs, "id" | "subgraphError">
  >;
  sentEvents?: SubscriptionResolver<
    Array<ResolversTypes["SentEvent"]>,
    "sentEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionsentEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  transferEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["TransferEvent"]>,
    "transferEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptiontransferEventArgs, "id" | "subgraphError">
  >;
  transferEvents?: SubscriptionResolver<
    Array<ResolversTypes["TransferEvent"]>,
    "transferEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptiontransferEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  tokenDowngradedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["TokenDowngradedEvent"]>,
    "tokenDowngradedEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptiontokenDowngradedEventArgs, "id" | "subgraphError">
  >;
  tokenDowngradedEvents?: SubscriptionResolver<
    Array<ResolversTypes["TokenDowngradedEvent"]>,
    "tokenDowngradedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptiontokenDowngradedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  tokenUpgradedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["TokenUpgradedEvent"]>,
    "tokenUpgradedEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptiontokenUpgradedEventArgs, "id" | "subgraphError">
  >;
  tokenUpgradedEvents?: SubscriptionResolver<
    Array<ResolversTypes["TokenUpgradedEvent"]>,
    "tokenUpgradedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptiontokenUpgradedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  approvalEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["ApprovalEvent"]>,
    "approvalEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptionapprovalEventArgs, "id" | "subgraphError">
  >;
  approvalEvents?: SubscriptionResolver<
    Array<ResolversTypes["ApprovalEvent"]>,
    "approvalEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionapprovalEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  approvalForAllEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["ApprovalForAllEvent"]>,
    "approvalForAllEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptionapprovalForAllEventArgs, "id" | "subgraphError">
  >;
  approvalForAllEvents?: SubscriptionResolver<
    Array<ResolversTypes["ApprovalForAllEvent"]>,
    "approvalForAllEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionapprovalForAllEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  metadataUpdateEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["MetadataUpdateEvent"]>,
    "metadataUpdateEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptionmetadataUpdateEventArgs, "id" | "subgraphError">
  >;
  metadataUpdateEvents?: SubscriptionResolver<
    Array<ResolversTypes["MetadataUpdateEvent"]>,
    "metadataUpdateEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionmetadataUpdateEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  customSuperTokenCreatedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["CustomSuperTokenCreatedEvent"]>,
    "customSuperTokenCreatedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptioncustomSuperTokenCreatedEventArgs,
      "id" | "subgraphError"
    >
  >;
  customSuperTokenCreatedEvents?: SubscriptionResolver<
    Array<ResolversTypes["CustomSuperTokenCreatedEvent"]>,
    "customSuperTokenCreatedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptioncustomSuperTokenCreatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  superTokenCreatedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["SuperTokenCreatedEvent"]>,
    "superTokenCreatedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionsuperTokenCreatedEventArgs,
      "id" | "subgraphError"
    >
  >;
  superTokenCreatedEvents?: SubscriptionResolver<
    Array<ResolversTypes["SuperTokenCreatedEvent"]>,
    "superTokenCreatedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionsuperTokenCreatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  superTokenLogicCreatedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["SuperTokenLogicCreatedEvent"]>,
    "superTokenLogicCreatedEvent",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionsuperTokenLogicCreatedEventArgs,
      "id" | "subgraphError"
    >
  >;
  superTokenLogicCreatedEvents?: SubscriptionResolver<
    Array<ResolversTypes["SuperTokenLogicCreatedEvent"]>,
    "superTokenLogicCreatedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionsuperTokenLogicCreatedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  newPICEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["NewPICEvent"]>,
    "newPICEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptionnewPICEventArgs, "id" | "subgraphError">
  >;
  newPICEvents?: SubscriptionResolver<
    Array<ResolversTypes["NewPICEvent"]>,
    "newPICEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionnewPICEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  exitRateChangedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["ExitRateChangedEvent"]>,
    "exitRateChangedEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptionexitRateChangedEventArgs, "id" | "subgraphError">
  >;
  exitRateChangedEvents?: SubscriptionResolver<
    Array<ResolversTypes["ExitRateChangedEvent"]>,
    "exitRateChangedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionexitRateChangedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  bondIncreasedEvent?: SubscriptionResolver<
    Maybe<ResolversTypes["BondIncreasedEvent"]>,
    "bondIncreasedEvent",
    ParentType,
    ContextType,
    RequireFields<SubscriptionbondIncreasedEventArgs, "id" | "subgraphError">
  >;
  bondIncreasedEvents?: SubscriptionResolver<
    Array<ResolversTypes["BondIncreasedEvent"]>,
    "bondIncreasedEvents",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionbondIncreasedEventsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  account?: SubscriptionResolver<
    Maybe<ResolversTypes["Account"]>,
    "account",
    ParentType,
    ContextType,
    RequireFields<SubscriptionaccountArgs, "id" | "subgraphError">
  >;
  accounts?: SubscriptionResolver<
    Array<ResolversTypes["Account"]>,
    "accounts",
    ParentType,
    ContextType,
    RequireFields<SubscriptionaccountsArgs, "skip" | "first" | "subgraphError">
  >;
  pool?: SubscriptionResolver<
    Maybe<ResolversTypes["Pool"]>,
    "pool",
    ParentType,
    ContextType,
    RequireFields<SubscriptionpoolArgs, "id" | "subgraphError">
  >;
  pools?: SubscriptionResolver<
    Array<ResolversTypes["Pool"]>,
    "pools",
    ParentType,
    ContextType,
    RequireFields<SubscriptionpoolsArgs, "skip" | "first" | "subgraphError">
  >;
  poolMember?: SubscriptionResolver<
    Maybe<ResolversTypes["PoolMember"]>,
    "poolMember",
    ParentType,
    ContextType,
    RequireFields<SubscriptionpoolMemberArgs, "id" | "subgraphError">
  >;
  poolMembers?: SubscriptionResolver<
    Array<ResolversTypes["PoolMember"]>,
    "poolMembers",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionpoolMembersArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  poolDistributor?: SubscriptionResolver<
    Maybe<ResolversTypes["PoolDistributor"]>,
    "poolDistributor",
    ParentType,
    ContextType,
    RequireFields<SubscriptionpoolDistributorArgs, "id" | "subgraphError">
  >;
  poolDistributors?: SubscriptionResolver<
    Array<ResolversTypes["PoolDistributor"]>,
    "poolDistributors",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionpoolDistributorsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  index?: SubscriptionResolver<
    Maybe<ResolversTypes["Index"]>,
    "index",
    ParentType,
    ContextType,
    RequireFields<SubscriptionindexArgs, "id" | "subgraphError">
  >;
  indexes?: SubscriptionResolver<
    Array<ResolversTypes["Index"]>,
    "indexes",
    ParentType,
    ContextType,
    RequireFields<SubscriptionindexesArgs, "skip" | "first" | "subgraphError">
  >;
  indexSubscription?: SubscriptionResolver<
    Maybe<ResolversTypes["IndexSubscription"]>,
    "indexSubscription",
    ParentType,
    ContextType,
    RequireFields<SubscriptionindexSubscriptionArgs, "id" | "subgraphError">
  >;
  indexSubscriptions?: SubscriptionResolver<
    Array<ResolversTypes["IndexSubscription"]>,
    "indexSubscriptions",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionindexSubscriptionsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  stream?: SubscriptionResolver<
    Maybe<ResolversTypes["Stream"]>,
    "stream",
    ParentType,
    ContextType,
    RequireFields<SubscriptionstreamArgs, "id" | "subgraphError">
  >;
  streams?: SubscriptionResolver<
    Array<ResolversTypes["Stream"]>,
    "streams",
    ParentType,
    ContextType,
    RequireFields<SubscriptionstreamsArgs, "skip" | "first" | "subgraphError">
  >;
  flowOperator?: SubscriptionResolver<
    Maybe<ResolversTypes["FlowOperator"]>,
    "flowOperator",
    ParentType,
    ContextType,
    RequireFields<SubscriptionflowOperatorArgs, "id" | "subgraphError">
  >;
  flowOperators?: SubscriptionResolver<
    Array<ResolversTypes["FlowOperator"]>,
    "flowOperators",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionflowOperatorsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  streamPeriod?: SubscriptionResolver<
    Maybe<ResolversTypes["StreamPeriod"]>,
    "streamPeriod",
    ParentType,
    ContextType,
    RequireFields<SubscriptionstreamPeriodArgs, "id" | "subgraphError">
  >;
  streamPeriods?: SubscriptionResolver<
    Array<ResolversTypes["StreamPeriod"]>,
    "streamPeriods",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionstreamPeriodsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  tokenGovernanceConfig?: SubscriptionResolver<
    Maybe<ResolversTypes["TokenGovernanceConfig"]>,
    "tokenGovernanceConfig",
    ParentType,
    ContextType,
    RequireFields<SubscriptiontokenGovernanceConfigArgs, "id" | "subgraphError">
  >;
  tokenGovernanceConfigs?: SubscriptionResolver<
    Array<ResolversTypes["TokenGovernanceConfig"]>,
    "tokenGovernanceConfigs",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptiontokenGovernanceConfigsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  streamRevision?: SubscriptionResolver<
    Maybe<ResolversTypes["StreamRevision"]>,
    "streamRevision",
    ParentType,
    ContextType,
    RequireFields<SubscriptionstreamRevisionArgs, "id" | "subgraphError">
  >;
  streamRevisions?: SubscriptionResolver<
    Array<ResolversTypes["StreamRevision"]>,
    "streamRevisions",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionstreamRevisionsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  token?: SubscriptionResolver<
    Maybe<ResolversTypes["Token"]>,
    "token",
    ParentType,
    ContextType,
    RequireFields<SubscriptiontokenArgs, "id" | "subgraphError">
  >;
  tokens?: SubscriptionResolver<
    Array<ResolversTypes["Token"]>,
    "tokens",
    ParentType,
    ContextType,
    RequireFields<SubscriptiontokensArgs, "skip" | "first" | "subgraphError">
  >;
  resolverEntry?: SubscriptionResolver<
    Maybe<ResolversTypes["ResolverEntry"]>,
    "resolverEntry",
    ParentType,
    ContextType,
    RequireFields<SubscriptionresolverEntryArgs, "id" | "subgraphError">
  >;
  resolverEntries?: SubscriptionResolver<
    Array<ResolversTypes["ResolverEntry"]>,
    "resolverEntries",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionresolverEntriesArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  accountTokenSnapshot?: SubscriptionResolver<
    Maybe<ResolversTypes["AccountTokenSnapshot"]>,
    "accountTokenSnapshot",
    ParentType,
    ContextType,
    RequireFields<SubscriptionaccountTokenSnapshotArgs, "id" | "subgraphError">
  >;
  accountTokenSnapshots?: SubscriptionResolver<
    Array<ResolversTypes["AccountTokenSnapshot"]>,
    "accountTokenSnapshots",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionaccountTokenSnapshotsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  accountTokenSnapshotLog?: SubscriptionResolver<
    Maybe<ResolversTypes["AccountTokenSnapshotLog"]>,
    "accountTokenSnapshotLog",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionaccountTokenSnapshotLogArgs,
      "id" | "subgraphError"
    >
  >;
  accountTokenSnapshotLogs?: SubscriptionResolver<
    Array<ResolversTypes["AccountTokenSnapshotLog"]>,
    "accountTokenSnapshotLogs",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptionaccountTokenSnapshotLogsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  tokenStatistic?: SubscriptionResolver<
    Maybe<ResolversTypes["TokenStatistic"]>,
    "tokenStatistic",
    ParentType,
    ContextType,
    RequireFields<SubscriptiontokenStatisticArgs, "id" | "subgraphError">
  >;
  tokenStatistics?: SubscriptionResolver<
    Array<ResolversTypes["TokenStatistic"]>,
    "tokenStatistics",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptiontokenStatisticsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  tokenStatisticLog?: SubscriptionResolver<
    Maybe<ResolversTypes["TokenStatisticLog"]>,
    "tokenStatisticLog",
    ParentType,
    ContextType,
    RequireFields<SubscriptiontokenStatisticLogArgs, "id" | "subgraphError">
  >;
  tokenStatisticLogs?: SubscriptionResolver<
    Array<ResolversTypes["TokenStatisticLog"]>,
    "tokenStatisticLogs",
    ParentType,
    ContextType,
    RequireFields<
      SubscriptiontokenStatisticLogsArgs,
      "skip" | "first" | "subgraphError"
    >
  >;
  sfmeta?: SubscriptionResolver<
    Maybe<ResolversTypes["SFMeta"]>,
    "sfmeta",
    ParentType,
    ContextType,
    RequireFields<SubscriptionsfmetaArgs, "id" | "subgraphError">
  >;
  sfmetas?: SubscriptionResolver<
    Array<ResolversTypes["SFMeta"]>,
    "sfmetas",
    ParentType,
    ContextType,
    RequireFields<SubscriptionsfmetasArgs, "skip" | "first" | "subgraphError">
  >;
  event?: SubscriptionResolver<
    Maybe<ResolversTypes["Event"]>,
    "event",
    ParentType,
    ContextType,
    RequireFields<SubscriptioneventArgs, "id" | "subgraphError">
  >;
  events?: SubscriptionResolver<
    Array<ResolversTypes["Event"]>,
    "events",
    ParentType,
    ContextType,
    RequireFields<SubscriptioneventsArgs, "skip" | "first" | "subgraphError">
  >;
  _meta?: SubscriptionResolver<
    Maybe<ResolversTypes["_Meta_"]>,
    "_meta",
    ParentType,
    ContextType,
    Partial<Subscription_metaArgs>
  >;
}>;

export type SubscriptionApprovedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["SubscriptionApprovedEvent"] = ResolversParentTypes["SubscriptionApprovedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  subscriber?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  publisher?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  indexId?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  userData?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  subscription?: Resolver<
    ResolversTypes["IndexSubscription"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SubscriptionDistributionClaimedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["SubscriptionDistributionClaimedEvent"] = ResolversParentTypes["SubscriptionDistributionClaimedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  subscriber?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  publisher?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  indexId?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  amount?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  subscription?: Resolver<
    ResolversTypes["IndexSubscription"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SubscriptionRevokedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["SubscriptionRevokedEvent"] = ResolversParentTypes["SubscriptionRevokedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  subscriber?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  publisher?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  indexId?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  userData?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  subscription?: Resolver<
    ResolversTypes["IndexSubscription"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SubscriptionUnitsUpdatedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["SubscriptionUnitsUpdatedEvent"] = ResolversParentTypes["SubscriptionUnitsUpdatedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  subscriber?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  publisher?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  indexId?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  units?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  userData?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  oldUnits?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  subscription?: Resolver<
    ResolversTypes["IndexSubscription"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SuperTokenCreatedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["SuperTokenCreatedEvent"] = ResolversParentTypes["SuperTokenCreatedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SuperTokenFactoryUpdatedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["SuperTokenFactoryUpdatedEvent"] = ResolversParentTypes["SuperTokenFactoryUpdatedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  newFactory?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SuperTokenLogicCreatedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["SuperTokenLogicCreatedEvent"] = ResolversParentTypes["SuperTokenLogicCreatedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  tokenLogic?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SuperTokenLogicUpdatedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["SuperTokenLogicUpdatedEvent"] = ResolversParentTypes["SuperTokenLogicUpdatedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  code?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SuperTokenMinimumDepositChangedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["SuperTokenMinimumDepositChangedEvent"] = ResolversParentTypes["SuperTokenMinimumDepositChangedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  governanceAddress?: Resolver<
    ResolversTypes["Bytes"],
    ParentType,
    ContextType
  >;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  host?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  superToken?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  isKeySet?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  minimumDeposit?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TokenResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["Token"] = ResolversParentTypes["Token"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  createdAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  createdAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  decimals?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  symbol?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  isSuperToken?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isNativeAssetSuperToken?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isListed?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  underlyingAddress?: Resolver<
    ResolversTypes["Bytes"],
    ParentType,
    ContextType
  >;
  underlyingToken?: Resolver<
    Maybe<ResolversTypes["Token"]>,
    ParentType,
    ContextType
  >;
  governanceConfig?: Resolver<
    Maybe<ResolversTypes["TokenGovernanceConfig"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TokenDowngradedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["TokenDowngradedEvent"] = ResolversParentTypes["TokenDowngradedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  account?: Resolver<ResolversTypes["Account"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  amount?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TokenGovernanceConfigResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["TokenGovernanceConfig"] = ResolversParentTypes["TokenGovernanceConfig"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  createdAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  createdAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  isDefault?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  rewardAddress?: Resolver<
    Maybe<ResolversTypes["Bytes"]>,
    ParentType,
    ContextType
  >;
  liquidationPeriod?: Resolver<
    Maybe<ResolversTypes["BigInt"]>,
    ParentType,
    ContextType
  >;
  patricianPeriod?: Resolver<
    Maybe<ResolversTypes["BigInt"]>,
    ParentType,
    ContextType
  >;
  minimumDeposit?: Resolver<
    Maybe<ResolversTypes["BigInt"]>,
    ParentType,
    ContextType
  >;
  token?: Resolver<Maybe<ResolversTypes["Token"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TokenStatisticResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["TokenStatistic"] = ResolversParentTypes["TokenStatistic"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  updatedAtTimestamp?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  updatedAtBlockNumber?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalNumberOfActiveStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalCFANumberOfActiveStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalGDANumberOfActiveStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalNumberOfClosedStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalCFANumberOfClosedStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalGDANumberOfClosedStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalNumberOfIndexes?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalNumberOfActiveIndexes?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalSubscriptionsWithUnits?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalApprovedSubscriptions?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalNumberOfPools?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  totalNumberOfActivePools?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalMembershipsWithUnits?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalConnectedMemberships?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalDeposit?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalCFADeposit?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalGDADeposit?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalOutflowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalCFAOutflowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalGDAOutflowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalAmountStreamedUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalCFAAmountStreamedUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalAmountTransferredUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalAmountDistributedUntilUpdatedAt?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalSupply?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalNumberOfAccounts?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalNumberOfHolders?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  token?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  tokenStatisticLogs?: Resolver<
    Array<ResolversTypes["TokenStatisticLog"]>,
    ParentType,
    ContextType,
    RequireFields<TokenStatistictokenStatisticLogsArgs, "skip" | "first">
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TokenStatisticLogResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["TokenStatisticLog"] = ResolversParentTypes["TokenStatisticLog"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  triggeredByEventName?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalNumberOfActiveStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalCFANumberOfActiveStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalGDANumberOfActiveStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalNumberOfClosedStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalCFANumberOfClosedStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalGDANumberOfClosedStreams?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalNumberOfIndexes?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalNumberOfActiveIndexes?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalSubscriptionsWithUnits?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalApprovedSubscriptions?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalNumberOfPools?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  totalNumberOfActivePools?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalMembershipsWithUnits?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalConnectedMemberships?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalDeposit?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalCFADeposit?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalGDADeposit?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalOutflowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalCFAOutflowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalGDAOutflowRate?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalAmountStreamed?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalCFAAmountStreamed?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalAmountTransferred?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalAmountDistributed?: Resolver<
    ResolversTypes["BigInt"],
    ParentType,
    ContextType
  >;
  totalSupply?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  totalNumberOfAccounts?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalNumberOfHolders?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  token?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  tokenStatistic?: Resolver<
    ResolversTypes["TokenStatistic"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TokenUpgradedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["TokenUpgradedEvent"] = ResolversParentTypes["TokenUpgradedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  account?: Resolver<ResolversTypes["Account"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  amount?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TransferEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["TransferEvent"] = ResolversParentTypes["TransferEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  from?: Resolver<ResolversTypes["Account"], ParentType, ContextType>;
  to?: Resolver<ResolversTypes["Account"], ParentType, ContextType>;
  isNFTTransfer?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  value?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TrustedForwarderChangedEventResolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["TrustedForwarderChangedEvent"] = ResolversParentTypes["TrustedForwarderChangedEvent"],
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  transactionHash?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  gasUsed?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  governanceAddress?: Resolver<
    ResolversTypes["Bytes"],
    ParentType,
    ContextType
  >;
  addresses?: Resolver<Array<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  blockNumber?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  logIndex?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  order?: Resolver<ResolversTypes["BigInt"], ParentType, ContextType>;
  host?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  superToken?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  isKeySet?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  forwarder?: Resolver<ResolversTypes["Bytes"], ParentType, ContextType>;
  enabled?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type _Block_Resolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["_Block_"] = ResolversParentTypes["_Block_"],
> = ResolversObject<{
  hash?: Resolver<Maybe<ResolversTypes["Bytes"]>, ParentType, ContextType>;
  number?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type _Meta_Resolvers<
  ContextType = MeshContext,
  ParentType extends
    ResolversParentTypes["_Meta_"] = ResolversParentTypes["_Meta_"],
> = ResolversObject<{
  block?: Resolver<ResolversTypes["_Block_"], ParentType, ContextType>;
  deployment?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  hasIndexingErrors?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Resolvers<ContextType = MeshContext> = ResolversObject<{
  Account?: AccountResolvers<ContextType>;
  AccountTokenSnapshot?: AccountTokenSnapshotResolvers<ContextType>;
  AccountTokenSnapshotLog?: AccountTokenSnapshotLogResolvers<ContextType>;
  AgreementClassRegisteredEvent?: AgreementClassRegisteredEventResolvers<ContextType>;
  AgreementClassUpdatedEvent?: AgreementClassUpdatedEventResolvers<ContextType>;
  AgreementLiquidatedByEvent?: AgreementLiquidatedByEventResolvers<ContextType>;
  AgreementLiquidatedV2Event?: AgreementLiquidatedV2EventResolvers<ContextType>;
  AppRegisteredEvent?: AppRegisteredEventResolvers<ContextType>;
  ApprovalEvent?: ApprovalEventResolvers<ContextType>;
  ApprovalForAllEvent?: ApprovalForAllEventResolvers<ContextType>;
  BigDecimal?: GraphQLScalarType;
  BigInt?: GraphQLScalarType;
  BondIncreasedEvent?: BondIncreasedEventResolvers<ContextType>;
  BufferAdjustedEvent?: BufferAdjustedEventResolvers<ContextType>;
  BurnedEvent?: BurnedEventResolvers<ContextType>;
  Bytes?: GraphQLScalarType;
  CFAv1LiquidationPeriodChangedEvent?: CFAv1LiquidationPeriodChangedEventResolvers<ContextType>;
  ConfigChangedEvent?: ConfigChangedEventResolvers<ContextType>;
  CustomSuperTokenCreatedEvent?: CustomSuperTokenCreatedEventResolvers<ContextType>;
  DistributionClaimedEvent?: DistributionClaimedEventResolvers<ContextType>;
  Event?: EventResolvers<ContextType>;
  ExitRateChangedEvent?: ExitRateChangedEventResolvers<ContextType>;
  FlowDistributionUpdatedEvent?: FlowDistributionUpdatedEventResolvers<ContextType>;
  FlowOperator?: FlowOperatorResolvers<ContextType>;
  FlowOperatorUpdatedEvent?: FlowOperatorUpdatedEventResolvers<ContextType>;
  FlowUpdatedEvent?: FlowUpdatedEventResolvers<ContextType>;
  GovernanceReplacedEvent?: GovernanceReplacedEventResolvers<ContextType>;
  Index?: IndexResolvers<ContextType>;
  IndexCreatedEvent?: IndexCreatedEventResolvers<ContextType>;
  IndexDistributionClaimedEvent?: IndexDistributionClaimedEventResolvers<ContextType>;
  IndexSubscribedEvent?: IndexSubscribedEventResolvers<ContextType>;
  IndexSubscription?: IndexSubscriptionResolvers<ContextType>;
  IndexUnitsUpdatedEvent?: IndexUnitsUpdatedEventResolvers<ContextType>;
  IndexUnsubscribedEvent?: IndexUnsubscribedEventResolvers<ContextType>;
  IndexUpdatedEvent?: IndexUpdatedEventResolvers<ContextType>;
  InstantDistributionUpdatedEvent?: InstantDistributionUpdatedEventResolvers<ContextType>;
  Int8?: GraphQLScalarType;
  JailEvent?: JailEventResolvers<ContextType>;
  MemberUnitsUpdatedEvent?: MemberUnitsUpdatedEventResolvers<ContextType>;
  MetadataUpdateEvent?: MetadataUpdateEventResolvers<ContextType>;
  MintedEvent?: MintedEventResolvers<ContextType>;
  NewPICEvent?: NewPICEventResolvers<ContextType>;
  PPPConfigurationChangedEvent?: PPPConfigurationChangedEventResolvers<ContextType>;
  Pool?: PoolResolvers<ContextType>;
  PoolConnectionUpdatedEvent?: PoolConnectionUpdatedEventResolvers<ContextType>;
  PoolCreatedEvent?: PoolCreatedEventResolvers<ContextType>;
  PoolDistributor?: PoolDistributorResolvers<ContextType>;
  PoolMember?: PoolMemberResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  ResolverEntry?: ResolverEntryResolvers<ContextType>;
  RewardAddressChangedEvent?: RewardAddressChangedEventResolvers<ContextType>;
  RoleAdminChangedEvent?: RoleAdminChangedEventResolvers<ContextType>;
  RoleGrantedEvent?: RoleGrantedEventResolvers<ContextType>;
  RoleRevokedEvent?: RoleRevokedEventResolvers<ContextType>;
  SFMeta?: SFMetaResolvers<ContextType>;
  SentEvent?: SentEventResolvers<ContextType>;
  SetEvent?: SetEventResolvers<ContextType>;
  Stream?: StreamResolvers<ContextType>;
  StreamPeriod?: StreamPeriodResolvers<ContextType>;
  StreamRevision?: StreamRevisionResolvers<ContextType>;
  Subscription?: SubscriptionResolvers<ContextType>;
  SubscriptionApprovedEvent?: SubscriptionApprovedEventResolvers<ContextType>;
  SubscriptionDistributionClaimedEvent?: SubscriptionDistributionClaimedEventResolvers<ContextType>;
  SubscriptionRevokedEvent?: SubscriptionRevokedEventResolvers<ContextType>;
  SubscriptionUnitsUpdatedEvent?: SubscriptionUnitsUpdatedEventResolvers<ContextType>;
  SuperTokenCreatedEvent?: SuperTokenCreatedEventResolvers<ContextType>;
  SuperTokenFactoryUpdatedEvent?: SuperTokenFactoryUpdatedEventResolvers<ContextType>;
  SuperTokenLogicCreatedEvent?: SuperTokenLogicCreatedEventResolvers<ContextType>;
  SuperTokenLogicUpdatedEvent?: SuperTokenLogicUpdatedEventResolvers<ContextType>;
  SuperTokenMinimumDepositChangedEvent?: SuperTokenMinimumDepositChangedEventResolvers<ContextType>;
  Token?: TokenResolvers<ContextType>;
  TokenDowngradedEvent?: TokenDowngradedEventResolvers<ContextType>;
  TokenGovernanceConfig?: TokenGovernanceConfigResolvers<ContextType>;
  TokenStatistic?: TokenStatisticResolvers<ContextType>;
  TokenStatisticLog?: TokenStatisticLogResolvers<ContextType>;
  TokenUpgradedEvent?: TokenUpgradedEventResolvers<ContextType>;
  TransferEvent?: TransferEventResolvers<ContextType>;
  TrustedForwarderChangedEvent?: TrustedForwarderChangedEventResolvers<ContextType>;
  _Block_?: _Block_Resolvers<ContextType>;
  _Meta_?: _Meta_Resolvers<ContextType>;
}>;

export type DirectiveResolvers<ContextType = MeshContext> = ResolversObject<{
  entity?: entityDirectiveResolver<any, any, ContextType>;
  subgraphId?: subgraphIdDirectiveResolver<any, any, ContextType>;
  derivedFrom?: derivedFromDirectiveResolver<any, any, ContextType>;
}>;

export type MeshContext = ProtocolTypes.Context & BaseMeshContext;

const baseDir = pathModule.join(
  typeof __dirname === "string" ? __dirname : "/",
  "..",
);

const importFn: ImportFn = <T>(moduleId: string) => {
  const relativeModuleId = (
    pathModule.isAbsolute(moduleId)
      ? pathModule.relative(baseDir, moduleId)
      : moduleId
  )
    .split("\\")
    .join("/")
    .replace(baseDir + "/", "");
  switch (relativeModuleId) {
    case ".graphclient/sources/protocol/introspectionSchema":
      return Promise.resolve(importedModule$0) as T;

    default:
      return Promise.reject(
        new Error(`Cannot find module '${relativeModuleId}'.`),
      );
  }
};

const rootStore = new MeshStore(
  ".graphclient",
  new FsStoreStorageAdapter({
    cwd: baseDir,
    importFn,
    fileType: "ts",
  }),
  {
    readonly: true,
    validate: false,
  },
);

export const rawServeConfig: YamlConfig.Config["serve"] = undefined as any;
export async function getMeshOptions(): Promise<GetMeshOptions> {
  const pubsub = new PubSub();
  const sourcesStore = rootStore.child("sources");
  const logger = new DefaultLogger("GraphClient");
  const cache = new (MeshCache as any)({
    ...({} as any),
    importFn,
    store: rootStore.child("cache"),
    pubsub,
    logger,
  } as any);

  const sources: MeshResolvedSource[] = [];
  const transforms: MeshTransform[] = [];
  const additionalEnvelopPlugins: MeshPlugin<any>[] = [];
  const protocolTransforms = [];
  const additionalTypeDefs = [] as any[];
  const protocolHandler = new GraphqlHandler({
    name: "protocol",
    config: {
      endpoint:
        "{context.url:https://polygon-mainnet.subgraph.x.superfluid.dev/}",
      retry: 5,
    },
    baseDir,
    cache,
    pubsub,
    store: sourcesStore.child("protocol"),
    logger: logger.child("protocol"),
    importFn,
  });
  sources[0] = {
    name: "protocol",
    handler: protocolHandler,
    transforms: protocolTransforms,
  };
  const additionalResolvers = [] as any[];
  const merger = new (BareMerger as any)({
    cache,
    pubsub,
    logger: logger.child("bareMerger"),
    store: rootStore.child("bareMerger"),
  });

  return {
    sources,
    transforms,
    additionalTypeDefs,
    additionalResolvers,
    cache,
    pubsub,
    merger,
    logger,
    additionalEnvelopPlugins,
    get documents() {
      return [
        {
          document: AllRelevantEntitiesDocument,
          get rawSDL() {
            return printWithCache(AllRelevantEntitiesDocument);
          },
          location: "AllRelevantEntitiesDocument.graphql",
        },
      ];
    },
    fetchFn,
  };
}

export function createBuiltMeshHTTPHandler<
  TServerContext = {},
>(): MeshHTTPHandler<TServerContext> {
  return createMeshHTTPHandler<TServerContext>({
    baseDir,
    getBuiltMesh: getBuiltGraphClient,
    rawServeConfig: undefined,
  });
}

let meshInstance$: Promise<MeshInstance> | undefined;

export function getBuiltGraphClient(): Promise<MeshInstance> {
  if (meshInstance$ == null) {
    meshInstance$ = getMeshOptions()
      .then((meshOptions) => getMesh(meshOptions))
      .then((mesh) => {
        const id = mesh.pubsub.subscribe("destroy", () => {
          meshInstance$ = undefined;
          mesh.pubsub.unsubscribe(id);
        });
        return mesh;
      });
  }
  return meshInstance$;
}

export const execute: ExecuteMeshFn = (...args) =>
  getBuiltGraphClient().then(({ execute }) => execute(...args));

export const subscribe: SubscribeMeshFn = (...args) =>
  getBuiltGraphClient().then(({ subscribe }) => subscribe(...args));
export function getBuiltGraphSDK<TGlobalContext = any, TOperationContext = any>(
  globalContext?: TGlobalContext,
) {
  const sdkRequester$ = getBuiltGraphClient().then(({ sdkRequesterFactory }) =>
    sdkRequesterFactory(globalContext),
  );
  return getSdk<TOperationContext, TGlobalContext>((...args) =>
    sdkRequester$.then((sdkRequester) => sdkRequester(...args)),
  );
}
export type AllRelevantEntitiesQueryVariables = Exact<{
  block?: InputMaybe<Block_height>;
  accounts: Array<Scalars["String"]> | Scalars["String"];
  accounts_bytes: Array<Scalars["ID"]> | Scalars["ID"];
  tokens: Array<Scalars["String"]> | Scalars["String"];
}>;

export type AllRelevantEntitiesQuery = {
  poolDistributors: Array<
    Pick<
      PoolDistributor,
      | "createdAtBlockNumber"
      | "createdAtTimestamp"
      | "updatedAtBlockNumber"
      | "updatedAtTimestamp"
      | "flowRate"
    > & {
      account: Pick<Account, "id" | "isSuperApp">;
      pool: Pick<
        Pool,
        | "createdAtBlockNumber"
        | "createdAtTimestamp"
        | "updatedAtBlockNumber"
        | "updatedAtTimestamp"
        | "id"
      > & { token: Pick<Token, "id" | "symbol"> };
    }
  >;
  poolMembers: Array<
    Pick<
      PoolMember,
      | "createdAtBlockNumber"
      | "createdAtTimestamp"
      | "updatedAtBlockNumber"
      | "updatedAtTimestamp"
      | "units"
    > & {
      account: Pick<Account, "id" | "isSuperApp">;
      pool: Pick<
        Pool,
        | "createdAtBlockNumber"
        | "createdAtTimestamp"
        | "updatedAtBlockNumber"
        | "updatedAtTimestamp"
        | "id"
        | "flowRate"
        | "totalUnits"
      > & { token: Pick<Token, "id" | "symbol"> };
    }
  >;
  streams: Array<
    Pick<
      Stream,
      | "createdAtBlockNumber"
      | "createdAtTimestamp"
      | "updatedAtBlockNumber"
      | "updatedAtTimestamp"
      | "currentFlowRate"
    > & {
      receiver: Pick<Account, "id" | "isSuperApp">;
      sender: Pick<Account, "id" | "isSuperApp">;
      token: Pick<Token, "id" | "symbol">;
    }
  >;
  selectedAccounts: Array<
    Pick<
      Account,
      | "id"
      | "isSuperApp"
      | "createdAtBlockNumber"
      | "createdAtTimestamp"
      | "updatedAtBlockNumber"
      | "updatedAtTimestamp"
    > & {
      accountTokenSnapshots: Array<
        Pick<
          AccountTokenSnapshot,
          | "createdAtBlockNumber"
          | "createdAtTimestamp"
          | "updatedAtBlockNumber"
          | "updatedAtTimestamp"
        >
      >;
    }
  >;
  selectedPools: Array<
    Pick<
      Pool,
      | "id"
      | "createdAtBlockNumber"
      | "createdAtTimestamp"
      | "updatedAtBlockNumber"
      | "updatedAtTimestamp"
    > & {
      poolMembers: Array<
        Pick<
          PoolMember,
          | "createdAtBlockNumber"
          | "createdAtTimestamp"
          | "updatedAtBlockNumber"
          | "updatedAtTimestamp"
          | "units"
        > & {
          account: Pick<Account, "id" | "isSuperApp">;
          pool: Pick<
            Pool,
            | "createdAtBlockNumber"
            | "createdAtTimestamp"
            | "updatedAtBlockNumber"
            | "updatedAtTimestamp"
            | "id"
            | "flowRate"
            | "totalUnits"
          > & { token: Pick<Token, "id" | "symbol"> };
        }
      >;
      poolDistributors: Array<
        Pick<
          PoolDistributor,
          | "createdAtBlockNumber"
          | "createdAtTimestamp"
          | "updatedAtBlockNumber"
          | "updatedAtTimestamp"
          | "flowRate"
        > & {
          account: Pick<Account, "id" | "isSuperApp">;
          pool: Pick<
            Pool,
            | "createdAtBlockNumber"
            | "createdAtTimestamp"
            | "updatedAtBlockNumber"
            | "updatedAtTimestamp"
            | "id"
          > & { token: Pick<Token, "id" | "symbol"> };
        }
      >;
    }
  >;
  _meta?: Maybe<{ block: Pick<_Block_, "number" | "timestamp"> }>;
};

export const AllRelevantEntitiesDocument = gql`
  query AllRelevantEntities(
    $block: Block_height
    $accounts: [String!]!
    $accounts_bytes: [ID!]!
    $tokens: [String!]!
  ) {
    poolDistributors(
      block: $block
      first: 1000
      where: {
        account_in: $accounts
        pool_: { token_in: $tokens }
        flowRate_not: "0"
      }
    ) {
      createdAtBlockNumber
      createdAtTimestamp
      updatedAtBlockNumber
      updatedAtTimestamp
      flowRate
      account {
        id
        isSuperApp
      }
      pool {
        createdAtBlockNumber
        createdAtTimestamp
        updatedAtBlockNumber
        updatedAtTimestamp
        id
        token {
          id
          symbol
        }
      }
    }
    poolMembers(
      block: $block
      first: 1000
      where: {
        account_in: $accounts
        units_not: "0"
        pool_: { flowRate_not: "0" }
      }
    ) {
      createdAtBlockNumber
      createdAtTimestamp
      updatedAtBlockNumber
      updatedAtTimestamp
      units
      account {
        id
        isSuperApp
      }
      pool {
        createdAtBlockNumber
        createdAtTimestamp
        updatedAtBlockNumber
        updatedAtTimestamp
        id
        flowRate
        totalUnits
        token {
          id
          symbol
        }
      }
    }
    streams(
      block: $block
      first: 1000
      where: {
        or: [
          { receiver_in: $accounts, token_in: $tokens, currentFlowRate_gt: 0 }
          { sender_in: $accounts, token_in: $tokens, currentFlowRate_gt: 0 }
        ]
      }
    ) {
      createdAtBlockNumber
      createdAtTimestamp
      updatedAtBlockNumber
      updatedAtTimestamp
      receiver {
        id
        isSuperApp
      }
      sender {
        id
        isSuperApp
      }
      token {
        id
        symbol
      }
      currentFlowRate
    }
    selectedAccounts: accounts(first: 1000, where: { id_in: $accounts_bytes }) {
      id
      isSuperApp
      createdAtBlockNumber
      createdAtTimestamp
      updatedAtBlockNumber
      updatedAtTimestamp
      accountTokenSnapshots(where: { token_in: $tokens }) {
        createdAtBlockNumber
        createdAtTimestamp
        updatedAtBlockNumber
        updatedAtTimestamp
      }
    }
    selectedPools: pools(
      block: $block
      first: 1000
      where: { id_in: $accounts_bytes }
    ) {
      id
      createdAtBlockNumber
      createdAtTimestamp
      updatedAtBlockNumber
      updatedAtTimestamp
      poolMembers(
        first: 1000
        where: { units_not: "0", pool_: { flowRate_not: "0" } }
      ) {
        createdAtBlockNumber
        createdAtTimestamp
        updatedAtBlockNumber
        updatedAtTimestamp
        units
        account {
          id
          isSuperApp
        }
        pool {
          createdAtBlockNumber
          createdAtTimestamp
          updatedAtBlockNumber
          updatedAtTimestamp
          id
          flowRate
          totalUnits
          token {
            id
            symbol
          }
        }
      }
      poolDistributors(
        first: 1000
        where: { pool_: { token_in: $tokens }, flowRate_not: "0" }
      ) {
        createdAtBlockNumber
        createdAtTimestamp
        updatedAtBlockNumber
        updatedAtTimestamp
        flowRate
        account {
          id
          isSuperApp
        }
        pool {
          createdAtBlockNumber
          createdAtTimestamp
          updatedAtBlockNumber
          updatedAtTimestamp
          id
          token {
            id
            symbol
          }
        }
      }
    }
    _meta {
      block {
        number
        timestamp
      }
    }
  }
` as unknown as DocumentNode<
  AllRelevantEntitiesQuery,
  AllRelevantEntitiesQueryVariables
>;

export type Requester<C = {}, E = unknown> = <R, V>(
  doc: DocumentNode,
  vars?: V,
  options?: C,
) => Promise<R> | AsyncIterable<R>;
export function getSdk<C, E>(requester: Requester<C, E>) {
  return {
    AllRelevantEntities(
      variables: AllRelevantEntitiesQueryVariables,
      options?: C,
    ): Promise<AllRelevantEntitiesQuery> {
      return requester<
        AllRelevantEntitiesQuery,
        AllRelevantEntitiesQueryVariables
      >(
        AllRelevantEntitiesDocument,
        variables,
        options,
      ) as Promise<AllRelevantEntitiesQuery>;
    },
  };
}
export type Sdk = ReturnType<typeof getSdk>;
